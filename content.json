[{"title":"前端面试汇总","path":"2022/04/22/7f255ae33214/","text":"前端面试汇总JS部分1.作用域与作用域链一段程序中用到的名字，限制名字可用性的代码范围就是这个名字的作用域scope。JS的作用域为静态作用域，也可称词法作用域。JS常用的作用域有函数作用域，块级作用域let，const。 作用域链，由多级作用域连续引用的链式结果，先在局部作用域找，如果每找到再向父级作用域找。 2.原型与原型链 3.js的事件异步单线程 JS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。 宏任务（macrotask）：常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I&#x2F;O、postMessage、messageChannel、setImmediate（node.js环境） 微任务（microtask）：如Promise、MutaionObserver、process.nextTick(node.js环境) JS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。 JS引擎线程和GUI渲染线程是互斥的 宏任务、微任务、DOM渲染执行顺序： 先清空Call Stack 然后执行当前的微任务 接下来渲染DOM 宏任务 Event Loop event loop在执行各种任务时也将任务队列分为Task Queue和MicroTask Queue。 不同的执行环境中，Event Loop的执行机制是不同的。 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 4.浏览器DOM渲染及阻塞问题 阻塞型： 内联JS 外联普通JS 外联defer属性JS 内联CSS script标签之前的外联CSS 非阻塞型： 外联sync属性JS img标签 iframe script标签后的外联css 5. new关键字与Object.create()的区别1234567891011121314// new 关键字 const a = new Foo();let o = new Object();o.__proto__ = Foo.prototype;Foo.call(o);a = o;// Object.create() a = Object.create(old);Object.myCreate = function(obj) &#123; function F()&#123;&#125;; F.prototype = obj; return new F();&#125; 6. typeof和instance oftypeof用于检测数据类型，对象、数组、null返回值是object，函数返回值是function，undefined返回值是undefined。 instanceof本意是用来判断A是否是B的实例对象，其检测的是原型。如下面的例子 12console.log([] instanceof Array); // trueconsole.log([] instanceof Object); // true 7.AjaxAsynchronous JavaScript And XML（异步Javascript和XML）。 核心是XMLHttpRequest对象，可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。 一个Ajax请求的步骤： 创建异步对象，即XMLHttpRequest对象 使用open方法设置请求参数。open(method, url, async) 发送请求。send() 注册事件，注册onreadystatechange事件，状态改变时就会调用。 服务端响应，获取返回的数据 1234567891011121314151617// 创建XMLHttpRequest对象let xmlHttp = new XMLHttpRequest();// 设置请求的参数，调用open只是启动一个请求以备发送// 第三个参数true（异步），false（同步）xmlHttp.open(&#x27;get&#x27;, &#x27;test.php&#x27;, false);// 发送请求，sned方法接收一个参数，要作为请求主体发送的数据，若不需要通过请求主体发送数据，// 则必须传入nullxmlHttp.send(null);// 注册事件xmlHttp.onreadystatechange = function () &#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status === 200) &#123; console.log(&#x27;success&#x27; + JSON.stringify(xmlhttp.responseText)); &#125;&#125;; 在收到响应后，响应的数据会自动填充XHR对象的属性： responseText：作为响应主体被返回的文本 responseXML：如果响应的内容类型是”text&#x2F;xml”或”application&#x2F;xml”，这个属性中将保存包含响应数据的XML DOM文档。 status：响应的HTTP状态 statusText：HTTP状态的说明 readyState属性 多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下： 0：未初始化，尚未调用open()方法 1：启动，已经调用open()方法，但尚未调用send()方法 2：发送，已经调用send()方法，但尚未接收到响应 3：接收，已经接收到部分响应数据 4：完成，已经接收到全部的响应数据，已经可以在客户端使用了 每次readyState属性值发生变动，都会触发一次readystatechange事件。 8.PromisePromise对象的三个状态 初始化（等待中）：pending 成功：fulfilled 失败：rejected Promise处理失败的写法 通过catch方法统一捕获状态变为reject的promise，在promise链中，只要有一个请求失败，就直接执行catch()。 then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行，这种写法不影响promise链的执行。 9.async &#x2F; await本质是Generator的语法糖 async返回Promise实例对象，await得到异步结果。 await等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。 如果等到的不是一个Promise对象，await运算结果就是它等到的量。 如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。） 10.对象的内部属性和方法 configurable：能否使用delete、能否修改属性特性、能否修改访问器属性 enumerable：对象属性能否通过for-in循环 writable：对象属性是否能修改 value：对象属性的默认值 1234567let obj = &#123;&#125;;Object.defineProperties(obj, &#x27;name&#x27;, &#123; configurable: false, enumable: false, writable: false, value: &#x27;zrtty&#x27;&#125;); 11.模块化 服务器端规范：CommonJS，Node.js使用的模块化规范 浏览器端规范： AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。 CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。 ES6：import，export 12.Array的方法**splice(index, howmany, item1,…itemx); **返回删除的项 index-规定添加或删除的位置，使用负数，从数组尾部规定位置 howmany-要删除的数量，如果为0，则不删除项目 item1…itemx-向数组添加的新项目 操作方法 方法 描述 备注 concat() 合并数组，返回一个新的数组 不会改变原数组 slice() 从数组中提取指定的一个或多个元素，返回结果为新的数组 不会改变原数组 splice() 从数组中删除指定的一个或多个元素，返回结果为被删除元素组成的新数组 会改变原数组 splice()有三种使用方法： 删除：传入两参。起始位置，删除的项数 插入：传入三个或三个以上的参数。起始位置，0，插入的元素 替换：传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素 位置方法 方法 描述 备注 indexOf() 从前往后索引，检索一个数组中是否含有指定的元素 lastIndexOf() 从后往前索引，检索一个数组中是否含有指定的元素 迭代方法 方法 描述 备注 every() 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true filter() 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为新的数组 不会改变原数组 forEach() 和 for 循环类似，但需要兼容 IE8 以上 forEach() 没有返回值。也就是说，它的返回值是 undefined map() 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为新的数组 不会改变原数组 some() 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true 一真即真。只要有一项返回 true，最终的结果就返回 true 重排序方法 方法 描述 备注 reverse() 对数组反转 sort() 按升序排列数组项，按照Unicode编码，对每个数组项调用toString() 如果在使用sort()方法不带参，默认按照Unicode编码，对数组元素从小到大排序。 12let arr = [1, 2, 3, 5, 10, 11];console.log(arr.sort()); // [ 1, 10, 11, 2, 3, 5 ] 可以看到，数字11排在了2的前面，因为sort()方法是按照Unicode编码进行排序的。 sort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。 浏览器会根据回调函数的返回值来决定元素的排序： 如果返回一个大于 0 的值，则元素会交换位置 如果返回一个小于 0 的值，则元素位置不变 如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置 下面是一个简单的比较函数： 12345678910111213let arr = [1, 2, 3, 5, 10, 11];function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0 &#125;&#125;console.log(arr.sort(compare)); // [ 1, 2, 3, 5, 10, 11 ] 更简化的写法： 1234567let arr = [1, 2, 3, 5, 10, 11];let result = arr.sort(function (a, b)&#123; return a - b; // 升序&#125;);console.log(result); // [ 1, 2, 3, 5, 10, 11 ] 或箭头函数（推荐）： 12345let arr = [1, 2, 3, 5, 10, 11];let result = arr.sort((a, b) =&gt; a - b);console.log(result); // [ 1, 2, 3, 5, 10, 11 ] 13.防抖与节流12345678// 防抖function debounce(fn, delay = 200) &#123; let timeout; return function()&#123; timeout &amp;&amp; clearTimeout(timeout); timeout = setTimeout(fn.bind(this), delay); &#125;&#125; 123456789101112131415// 节流function throttle(fn, threshold = 200) &#123; let timeout; let start = new Date(); return function()&#123; const current = new Date() - 0; timeout &amp;&amp; clearTimeout(timeout); if (current - start &gt;= threshold) &#123; fn.call(this, ...arguments); start = current; &#125; else &#123; timeout = setTimeout(fn.bind(this), threshold, ...arguments); &#125; &#125;&#125; HTML部分标签语义化HTML 标签语义化是让大家直观的认识标签(markup)和属性(attribute)的用途和作用。 如&lt;header&gt;，&lt;footer&gt;，&lt;article&gt;，&lt;section&gt; CSS部分1.css元素权重 行内样式 1000 ID选择器 0100 class选择器 0010 标签、伪类 0001 * 0000 2.position定位属性 static：默认正常流 absolute：完全脱标，完全不占位置，父类要有定位（relative，absolute，fixed），若没有则以Document文档定位 relative：相对于其在标准流中的位置，不脱标，占据原来位置 fixed：完全脱标，完全不占位置，只认浏览器的可视窗口 sticky：根据正常文档流定位，不脱标 3.display属性 inline：行内元素 block：块级元素 inline-block：行内块元素 flex：弹性盒，单轴 grid：网格，双轴 4.浮动属性相邻浮动的块元素可以并在一行，超出父级宽度就换行。浮动让行内元素或块元素转化为行内块元素（不确定）。 高度塌陷：父元素如果没有设置尺寸，父元素内整体浮动的元素无法撑开父元素，父元素需要清除浮动。 在父元素内部最后添加一个没有高度的元素，设置clear: both; 使用::after伪类为父元素添加后标签 通过对父元素设置overflow属性，使父元素形成BFC，父元素高度计算会包括浮动元素的高度。 6.圣杯与双飞翼布局两种布局都是三栏布局，两边固定宽度，中间自适应，中间栏要放在文挡流前面以优先渲染。 圣杯布局 首先设置三栏浮动，设置中间div宽度100%，左右div被挤到后一行。此时给中间div设置左右padding以便给左右div留出位置。为了让左div回到上一行，设置其position为relative并margin-left设为-100%，再添加left: -300px使其回到第一行最左侧。同理，右div设置position为relative并margin-left：-200px，right：-200px。 双飞翼布局 中间的div多了一个子容器，通过控制其子容器的margin或padding空出左右两列的宽度。 7.居中问题水平居中 行内元素一行文字 12345.content &#123; height: 200px; background-color: khaki; text-align: center;&#125; 123&lt;div class=&quot;content&quot;&gt; &lt;p&gt;okkkk&lt;/p&gt;&lt;/div&gt; 行内元素多行文字 1234.content p &#123; padding: 10px; margin: 0;&#125; 123456&lt;div class=&quot;content&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Facere eius praesentium saepe, exercitationem enim magni a. Ea aut fugit recusandae a quod animi quibusdam repellendus vel? Dolorem molestiae eius fugiat?Lorem ipsum, dolor sit amet consectetur adipisicing elit. Consectetur quis ratione est optio expedita vero hic sapiente enim minima placeat mollitia recusandae deserunt sed, laboriosam dolore. Odit beatae provident nisi!&lt;/p&gt;&lt;/div&gt; 块级元素方法一 123456.inner &#123; background-color: coral; height: 100px; width: 100px; margin: 0 auto;&#125; 123&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; 块级元素方法二 先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。 1234567891011121314.content &#123; height: 200px; background-color: khaki; position: relative;&#125;.inner &#123; background-color: coral; height: 100px; width: 100px; position: absolute; left: 50%; transform: translateX(-50%);&#125; 块级元素方法三 通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 123456.content &#123; height: 200px; background-color: khaki; justify-content: center; display: flex;&#125; 块级元素方法四 通过flex将父容器设置为为Flex布局，再设置子元素居中。 123456789.content &#123; height: 200px; background-color: khaki; display: flex;&#125;.inner &#123; margin: 0 auto;&#125; 垂直居中 单行行内元素 12345.content &#123; height: 200px; background-color: khaki; line-height: 200px;&#125; 多行内联元素垂直居中 flex 123456.content &#123; height: 200px; background-color: khaki; display: flex; justify-content: center;&#125; 多行内联元素垂直居中 table 12345678910.content &#123; height: 200px; background-color: khaki; display: table;&#125;.content p &#123; display: table-cell; vertical-align: middle;&#125; 块级元素垂直居中一 通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半 1234567891011121314.content &#123; height: 200px; background-color: khaki; position: relative;&#125;.inner &#123; background-color: coral; height: 100px; width: 100px; position: absolute; top: 50%; margin-top: -50px;&#125; 块级元素垂直居中二 当垂直居中的元素的高度和宽度未知时，可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中。 1234567891011121314.content &#123; height: 200px; background-color: khaki; position: relative;&#125;.inner &#123; background-color: coral; height: 100px; width: 100px; position: absolute; top: 50%; transform: translateY(-50%);&#125; 块级元素垂直居中三 flex 123456.content &#123; height: 200px; background-color: khaki; display: flex; align-items: center;&#125; 8.性能优化算法部分排序算法冒泡12345678910let temp;for (let i = 0; i &lt; arr.length; ++i) &#123; for (let j = i + 1 ; j &lt; arr.length; ++j) &#123; if (arr[j] &lt; arr[i]) &#123; temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 时间复杂度O(n^2) 选择排序12345678910111213141516function selectionSort(arr) &#123; let len = arr.length; let temp; for (let i = 0; i &lt; len - 1; ++i) &#123; let minIndex = i; for (let j = i + 1; j &lt; len; ++j) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 时间复杂度O(n^2) 插入排序1234567891011121314function insertionSort(arr) &#123; let len = arr.length; let preIndex, current; for (let i = 1; i &lt; len; ++i) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125; 时间复杂度O(n^2) 快排123456789101112131415161718function quickSort(arr, left, right) &#123; let temp, l = left, r = right; if (left &gt;= right) &#123; return; &#125; temp = arr[left]; while (left &lt; right) &#123; //先从右往左开始搜索, 直到找到一个比temp小的数字 while (arr[right] &gt;= temp &amp;&amp; left &lt; right) right--; arr[left] = arr[right]; //从左往右开始搜索，直到找到一个比temp大的数字 while (arr[left] &lt;= temp &amp;&amp; left &lt; right) left++; arr[right] = arr[left]; &#125; arr[left] = temp; quickSort(arr, l, left); quickSort(arr, left + 1, r);&#125; 时间复杂度最差O(n^2)，平均为O(nlogn) 桶排序1 为使桶排序更加高效，需要做到两点： 额外空间充足下，尽可能增加桶的数量 使用的映射函数能够将输入的N个数据均匀的分配到K个桶中 堆排序归并排序二分查找二叉树前序遍历1 中序遍历后序遍历层序遍历图BFS（广度优先）DFS（深度优先）贪心算法网络部分1.OSI七层模型应用层：HTTP、HTTPS、FTP、SSH 表示层 会话层 传输层：TCP、UDP 网络层：IP、ARP 数据链路层 物理层 2.HTTP协议常用状态码1xx：信息，请求收到，继续处理2xx：成功，行为被成功地接受、理解和采纳 2003xx：重定向，为了完成请求，必须进一步执行的动作 4xx：客户端错误，请求包含语法错误或者请求无法实现 400 403 4045xx：服务器错误，服务器不能实现一种明显无效的请求 500 502 3.tcp三次握手四次挥手 第四次挥手释放连接，等待2MSL的意义？ MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。 两个理由： 保证客户端发送的最后一个ACK报文段能够到达服务端。这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。 防止“已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。 4.http与httpshttp协议以明文方式传输，易被中间人窃取。HTTPS在HTTP的基础上加入了SSL&#x2F;TLS协议，依靠证书来验证服务器的身份，并为浏览器与服务器之间的通信加密。 5.Http简述Http协议是超文本传输协议的缩写，是位于应用层的协议，是基于TCP&#x2F;IP通信协议来传递数据，HTTP不提供任何方式的数据加密。 框架部分1.vue的生命周期 2.双向绑定Vue2.x 实现核心是数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()，对data的每个属性进行了getter和setter的拦截。 1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4、mvvm入口函数，整合以上三者 3.diff算法vue的diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。 diff整体策略为：深度优先，同层比较 比较只会在同层级进行, 不会跨层级比较 比较的过程中，循环从两边向中间收拢"},{"title":"31天JavaScript学习-第22天","path":"2022/03/26/5e459e0f0ffb/","text":"模块化（一）：CommonJS 模块化规范 服务器端规范：CommonJS，Node.js使用的模块化规范 浏览器端规范： AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。 CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。 CommonJS基本语法CommonJS规定：每个文件都可以当作一个模块，每个模块内部内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口对象。加载某个模块，其实是加载该模块的module.exports对象。 在服务器端，模块的加载时运行时同步加载的；在浏览器端，模块需要提前编译打包。 模块的暴露与引入Node.js中，每个模块都有一个exports接口对象，我们可以把公共的变量、方法挂载到这个接口对象中，其他模块通过引入该接口对象以实现引入。 暴露模块方式一：exports exports对象用来导出当前模块的公共方法或属性。其他模块通过require函数调用时，得到的就是当前模块的exports对象。 注意关键字是exports，并非ES6中的export/import导出导入模块规范。 1234567const name = &#x27;zrtty&#x27;;const foo = function (value) &#123; return value * 2;&#125;;exports.name = name;exports.foo = foo; 注意：导出模块时优先使用module.exports。因为Node为每个模块提供一个exports变量，该变量指向module.exports。等同于每个模块头部有一句const exports = module.exports;。 暴露模块方式二：module.exports module.exports用来导出一个默认对象，没有指定对象名。 1234567const name = &#x27;zrtty&#x27;;const foo = function (value) &#123; return value * 2;&#125;;module.exports = name;module.exports.foo = foo; 注：Node中每个模块的最后，都会执行return module.exports 引入模块：require require用来在一个模块中引入另外一个模块。传入模块名，返回模块导出的对象。 1const module1 = require(&#x27;module name&#x27;); 其中引入的模块名的写法： 内置模块则引入包名 下载的第三方模块则引入包名 自定义模块则引入文件路径，后缀.js可以省略 注：一个模块中的JS代码仅在模块第一次使用时执行一次，并在使用过程中初始化，然后被缓存起来，便于后续继续使用。 12345678// array.jsvar a = 1;function add() &#123; return ++a;&#125;exports.add = add; 123456// main.jsconst myModule1 = require(&#x27;./array&#x27;);const myModule2 = require(&#x27;./array&#x27;);console.log(myModule1.add()); // 2console.log(myModule2.add()); // 3 可以看到，array.js被引用两次，但只初始化了一次。"},{"title":"31天JavaScript学习-第21天","path":"2022/03/25/a475fcf4753b/","text":"CSS CSS的渲染步骤 浏览器载入HTML文件（比如从网络上获取）。 将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。 接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。 浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。 上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。 网页展示在屏幕上（这一步被称为着色）。 选择器基本选择器 选择器 示例 描述 * * 选择所有元素 element div 选择所有div类型元素 .class .footer 选择所有class&#x3D;’footer’的元素 #id #username 选择所有id&#x3D;’username’的元素 element, element div, p 选择所有div和p类型元素 element&gt;element div&gt;p 选择所有父元素为div的所有p元素，不包括孙子 element+element div+p 选择紧接在div后面的p元素 element~element p~ul 选择与p元素同级并在p后面的所有ul元素 伪类选择器为元素的不同状态或为不确定存在的元素设置样式规则 状态 示例 说明 :link a:link 选择所有未被访问的链接 :visited a:visited 选择所有已被访问的链接 :hover a:hover 鼠标移动到元素上时 :active a:active 点击正在发生时 :focus input::focus 选择获得焦点的 input 元素 :root :root 选择文档的根元素即html。 :empty p:empty 选择没有子元素的每个元素（包括文本节点）。 :first-child p:first-child 选择属于父元素的第一个子元素的每个元素 :last-child p:last-child 选择属于其父元素最后一个子元素每个元素。 :first-of-type p:first-of-type 选择属于其父元素的首个元素的每个元素 :last-of-type p:last-of-type 选择属于其父元素的最后元素的每个元素。 :only-of-type p:only-of-type 选择属于其父元素唯一的元素的每个元素。 :only-child p:only-child 选择属于其父元素的唯一子元素的每个元素。 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个元素。 :nth-child(odd) p:nth-child(odd) 选择属于其父元素的奇数元素。 :nth-child(even) p:nth-child(even) 选择属于其父元素的偶数元素。 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个元素的每个元素。 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 :not(selector) :not(p) 选择非元素的每个元素 css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说：伪类和伪元素是用来修饰不在文档树中的部分。 伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的。例如：当用户悬停在指定元素时，可以通过:hover来描述这个元素的状态，虽然它和一般css相似，可以为已有元素添加样式，但是它只有处于DOM树无法描述的状态下才能为元素添加样式，所以称为伪类。 伪元素：用于创建一些不在DOM树中的元素，并为其添加样式。例如，我们可以通过:before来在一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看见这些文本，但是它实际上并不在DOM文档中。 css3规范中要求使用双冒号（::）表示伪元素，以此来区分伪类和伪元素，比如::before和::after等伪元素使用双冒号（::），:hover和:active伪类使用单冒号（:）。 盒子模型浮动布局定位布局弹性布局栅格系统"},{"title":"31天JavaScript学习-第20天","path":"2022/03/20/c85657f1c7ec/","text":"Async&#x2F;Await async&#x2F;await是ES8引入的新语法，是另外一种异步编程解决方案。 其本质是Generator的语法糖 async返回Promise实例对象，await可以得到异步结果。 async先查看一下async返回的结果 123456async function testAsync() &#123; return &#x27;okk&#x27;;&#125;const result = testAsync();console.log(result); // Promise &#123; &#x27;okk&#x27; &#125; 可以看到，async函数返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通过Promise.resolve()封装成一个Promise对象。因此，我们可以用then()来处理这个Promise对象 123testAsync().then(res =&gt; &#123; console.log(res);&#125;); // okk 由上一节可以知道，Promise对象的生成是同步代码，在Promise对象中调用的resolve()和reject()才是异步任务。因此，在没有await的情况下执行async函数，它会按照同步顺序执行，返回一个Promise对象。 awaitawait等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。 1234567891011121314151617181920212223function func1() &#123; return &#x27;func1&#x27;;&#125;async function func2() &#123; return &#x27;func2&#x27;; // return Promise.resolve(&#x27;func2&#x27;);&#125;async function test() &#123; let v1 = func1(); let v2 = func2(); console.log(v1); // func1 console.log(v2); // Promise &#123; &#x27;func2&#x27; &#125; const res1 = await func1(); const res2 = await func2(); console.log(res1); // func1 console.log(res2); // func2&#125;test(); 如果等到的不是一个Promise对象，await运算结果就是它等到的量。 如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。） 组合使用首先看一下Promise与async&#x2F;await的写法区别 123456789function waitForAwhile() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&#x27;long_time_step&#x27;), 2000); &#125;);&#125;waitForAwhile().then(v =&gt; &#123; console.log(&#x27;got&#x27;, v);&#125;); // got long_time_step 123456789101112function waitForAwhile() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&#x27;long_time_step&#x27;), 2000); &#125;);&#125;async function test () &#123; const v = await waitForAwhile(); console.log(v);&#125;test(); async&#x2F;await的优势是在处理多个Promise的then链 1234567891011121314151617181920function waitForAwhile(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return waitForAwhile(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return waitForAwhile(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return waitForAwhile(n);&#125; 如果使用Promise来处理该步骤 123456789101112function doIt() &#123; console.log(&#x27;doIt&#x27;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.log(&quot;finish&quot;); &#125;);&#125;doIt(); 如果用async&#x2F;await来处理该步骤 1234567891011async function doIt() &#123; console.log(&#x27;doIt&#x27;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.log(&#x27;finish&#x27;);&#125;doIt(); async&#x2F;await主要解决了Promise传递参数太麻烦的痛点。 处理reject状态await处理的Promise对象，其状态可能是reject，因此最好把await命令放在try…catch代码块中。 1234567891011121314async function myFunction() &#123; try &#123; await returnSomePromise(); &#125; catch (err) &#123; console.log(err); &#125;&#125;// 第二种写法async function myFunction() &#123; await returnSomePromise().catch(function (err) &#123; console.log(err); &#125;);&#125;"},{"title":"31天JavaScript学习-第19天","path":"2022/03/19/f7c4a7f73205/","text":"Promise（二） Promise的实例方法实例方法指需要建立实例对象，再通过实例对象调用的方法叫做实例方法。Promise的实例方法有： then()：获取异步任务的正常结果 catch()：获取异步任务的异常结果 finally()：异步任务无论成功与否，都会执行 Promise的静态方法静态方法指直接可以通过类名调用的方法。Promise提供的静态方法有： Promise.resolve() Promise.reject() Promise.all() Promise.race() Promise.allSettled() Promise.any() Promise.resolve()和Promise.reject()在某些场景下，我们并没有异步操作，但仍想调用promise.then()，可以通过Promise.resolve()将其包装成成功的状态。 1234567891011121314function foo (flag) &#123; if (flag) &#123; return Promise.resolve(&#x27;success&#x27;); // 直接返回字符串 &#125; else &#123; return Promise.reject(&#x27;fail&#x27;); //直接返回字符串 &#125;&#125;foo(true).then((res) =&gt; &#123; console.log(res);&#125;);foo(false).then((err) =&gt; &#123; console.log(err);&#125;); Promise.all()并发处理多个异步任务，所有任务都执行成功，才算成功，这时才会调用then()；如果有一个任务失败，就会调用catch()，整体任务视为失败。 Promise.all()参数传入的时多个Promise实例对象的数组。 案例：多张图片上传 如现在有一个上传九张图的需求，每次请求接口时只能上传一张图片。 123456789101112131415161718192021222324const imgArr = [&#x27;1.jpg&#x27;, &#x27;2.jpg&#x27;, &#x27;3.jpg&#x27;, &#x27;4.jpg&#x27;, &#x27;5.jpg&#x27;, &#x27;6.jpg&#x27;, &#x27;7.jpg&#x27;, &#x27;8.jpg&#x27;, &#x27;9.jpg&#x27;];const promiseArr = [];imgArr.forEach((item) =&gt; &#123; const p = new Promise((resolve, reject) =&gt; &#123; // 上传图片伪代码 // imgUrl = Upload item; if (imgUrl) &#123; // 单张图片上传成功 resolve(imgUrl); &#125; else &#123; reject(item + &#x27;上传失败&#x27;); &#125; &#125;); promiseArr.push(p);&#125;);Promise.all(promiseArr) .then((res) =&gt; &#123; console.log(&#x27;全部上传成功&#x27; + res); &#125;) .catch((err) =&gt; &#123; console.log(&#x27;上传失败&#x27;); &#125;); 如果某张图上传失败，则表现为： 前端九张图都会reject，整体catch 后端除了上传失败的图片，其余的都会正常请求接口并写入数据库 Promise.race()并发处理多个异步任务，返回的是第一个执行完成的promise，且状态和第一个完成的任务状态保持一致。 多个同时执行的异步任务中，哪个异步任务最先执行完成（无论resolv还是reject），整体的状态就和这个任务的状态保持一致。 应用场景：在众多Promise实例中，最终结果只取一个Promise，谁返回得最快就用谁的Promise 举例：timeout手动实现 一个Promise用于请求接口，另一个Promise用于执行setTimeout()。把两个Promise用Promise.race()方法组装 12345678910111213141516171819function query(url, delay = 4000) &#123; let promsiseArr = [ myAjax(url), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;timeout!&#x27;) &#125;, delay); &#125;) ]; return Promise.race(promsiseArr);&#125;query(&#x27;https://localhost:8888/someurl&#x27;, 3000) .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); Promise.allSettled()该方法返回一个在所有给定的promise都fulfilled或reject后的promise，并带有一个对象数组，每个对象表示对应的promise结果。 当有多个彼此不依赖的异步任务成功完成时，或者想知道每个promise的结果时，通常使用该方法。 Promise.any()该方法处理多个promise任务，只要其中任何一个promise成功，就返回那个成功的promise。若没有一个promise成功，就返回一个失败的promise和AggregError类型的实例。"},{"title":"31天JavaScript学习-第18天","path":"2022/03/16/247b7d4e52e1/","text":"Promise（一） JS是一门单线程语言，早期我们解决异步场景时，大部分情况都是通过回调函数来进行。 回调函数把函数A传给另一个函数B调用，那么函数A就是回调函数。 例如浏览器中发送Ajax请求，就是一个常见的异步场景，发送请求后，需要等待服务端响应之后我们才能拿到结果。如果希望在异步结束之后执行某个操作，就需要通过回调函数进行操作。 123456789myAjax(&#x27;a.php&#x27;, (res1) =&gt; &#123; console.log(res1); myAjax(&#x27;b.php&#x27;, (res2) =&gt; &#123; console.log(res2); myAjax(&#x27;c.php&#x27;, (res3) =&gt; &#123; console.log(res3); &#125;); &#125;);&#125;); 回调的写法比较直观，但层层嵌套也会出现两个问题： 嵌套过深会出现回调地狱的问题 不同的函数，回调的参数，写法上不一致导致写法复杂 因此ES6引入Promise以解决以上问题。 PromisePromise是一个对象，它可以获取异步操作的消息，可以用同步的表现形式来书写异步代码。 使用Promise的基本步骤： 构建一个Promise实例，在其构造函数中传入一个参数，这个参数是一个函数，该函数用于处理异步任务。 函数中传入两个参数：resolve和reject，分别代表异步执行成功和失败后的回调函数 通过promise.then()和promise.catch()处理返回结果 Promise对象的三个状态 初始化（等待中）：pending 成功：fulfilled 失败：rejected 123456789101112let promise = new Promise((resolve, reject) =&gt; &#123; // 此时new的操作是同步的，promise的状态被初始化为pending setTimeout(function()&#123; // 模拟异步操作，成功则调用resolve()，此时promise状态会修改为fulfilled resolve(&#x27;成功&#x27;); &#125;, 200);&#125;);promise.then( (response) =&gt; &#123; console.log(response); &#125;, // 如果promise的状态为fulfilled，则执行该行语句，函数的参数为resolve()中传递的参数 (err) =&gt; &#123; console.log(err); &#125; // 如果promise的状态为rejected，则执行该行语句，函数的参数为reject()中传递的参数); 注：Promise的状态一旦改变，就不能再变了 举例一 123456789101112function delayfunc (callback) &#123; setTimeout(function () &#123; console.log(&#x27;等待一秒执行callback&#x27;); callback(); &#125;, 1000);&#125;function myCallback() &#123; console.log(&#x27;被延迟的函数&#x27;);&#125;delayfunc(myCallback); 或 1234567function delayfunc (callback) &#123; setTimeout(callback, 1000);&#125;delayfunc(function() &#123; console.log(&#x27;被延迟的函数&#x27;);&#125;) 用Promise改写 123456789function myPromise() &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, 10000); &#125;);&#125;myPromise().then(() =&gt; &#123; console.log(&#x27;被延迟的函数&#x27;);&#125;); 举例二 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function ajax(url, success, fail) &#123; let xmlhttp = new XMLHttpRequest(); xmlhttp.open(&#x27;GET&#x27;, url); xmlhttp.send(); xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200) &#123; success &amp;&amp; success(xmlhttp.responseText); &#125; else &#123; fail &amp;&amp; fail(new Error(&#x27;err&#x27;)); &#125; &#125;;&#125;function promiseA() &#123; return new Promise((resolve, reject) =&gt; &#123; ajax(&#x27;test.php&#x27;, (res) =&gt; &#123; if (res.retCode == 0) &#123; resolve(&#x27;request success&#x27; + res); &#125; else &#123; reject(&#123; retCode: -1, msg: &#x27;error&#x27; &#125;); &#125; &#125;); &#125;);&#125;promiseA() .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;);// 或promise实例定义成变量const promiseB = Promise((resolve, reject) =&gt; &#123; ajax(&#x27;test.php&#x27;, (res) =&gt; &#123; if (res.retCode == 0) &#123; resolve(&#x27;request success&#x27; + res); &#125; else &#123; reject(&#123; retCode: -1, msg: &#x27;error&#x27; &#125;); &#125; &#125;);&#125;);promiseB() .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); Promise处理失败的写法 通过catch方法捕获状态变为reject的promise then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行 Promise的链式调用使用Promise优化回调地狱的写法。也就是将多层嵌套调用按照线性的方式进行书写。 1234567891011121314151617181920212223242526function ajax(url, success, fail) &#123; let xmlhttp = new XMLHttpRequest(); xmlhttp.open(&#x27;GET&#x27;, url); xmlhttp.send(); xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200) &#123; success &amp;&amp; success(xmlhttp.responseText); &#125; else &#123; fail &amp;&amp; fail(new Error(&#x27;err&#x27;)); &#125; &#125;;&#125;new Promise((resolve, reject) =&gt; &#123; ajax(&#x27;a.php&#x27;, (res_a) =&gt; &#123; resolve(res_a); // 状态改为fulfilled,then()方法接收 &#125;);&#125;).then((res_a) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; ajax(&#x27;b.php&#x27;, (res_b) =&gt; &#123; resolve(res_b); &#125;); &#125;);&#125;).then((res_b) =&gt; &#123; console.log(res_b);&#125;); 可以对promise的链式调用进行封装 12345678910111213141516171819202122232425262728293031323334353637383940414243// 定义ajax请求function ajax(url, success, fail) &#123; let xmlhttp = new XMLHttpRequest(); xmlhttp.open(&#x27;GET&#x27;, url); xmlhttp.send(); xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200) &#123; success &amp;&amp; success(xmlhttp.responseText); &#125; else &#123; fail &amp;&amp; fail(new Error(&#x27;err&#x27;)); &#125; &#125;;&#125;// model层，接口封装function getPromise(url) &#123; return new Promise((resolve, reject) =&gt; &#123; ajax(url, (res) =&gt; &#123; //res是接口的返回结果 if (res.retCode == 0) &#123; resolve(&#x27;success&#x27; + res); &#125; else &#123; reject(&#123; retCode: -1, msg: &#x27;error&#x27;&#125;); &#125; &#125;); &#125;);&#125;// 业务层的接口调用getPromise(&#x27;a.php&#x27;) .then((res) =&gt; &#123; // a请求成功，res是从resolve获取的结果 return getPromise(&#x27;b.php&#x27;); &#125;) .then((res) =&gt; &#123; return getPromise(&#x27;c.php&#x27;); &#125;) .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); reject状态的处理不处理reject 1234567891011121314getPromise(&#x27;a.php&#x27;) .then( (res) =&gt; &#123; // a请求成功，res是从resolve获取的结果 console.log(&#x27;a:&#x27; + res) return getPromise(&#x27;b.php&#x27;); &#125; .then((res) =&gt; &#123; console.log(&#x27;b:&#x27; + res) return getPromise(&#x27;c.php&#x27;); &#125;) .then((res) =&gt; &#123; console.log(&#x27;c:&#x27; + res); &#125;); a请求失败，在a的then()方法里只打印err。打印结果 123a:errundefinedc:success 虽然a请求失败，但后续请求依然会执行 单独处理reject 123456789101112131415161718getPromise(&#x27;a.php&#x27;) .then( (res) =&gt; &#123; // a请求成功，res是从resolve获取的结果 console.log(&#x27;a:&#x27; + res) return getPromise(&#x27;b.php&#x27;); &#125;, (err) =&gt; &#123; console.log(&#x27;a:&#x27; + err); return getPromise(&#x27;b.php&#x27;); // 即使a请求失败，也继续执行b请求 &#125;) .then((res) =&gt; &#123; console.log(&#x27;b:&#x27; + res) return getPromise(&#x27;c.php&#x27;); &#125;) .then((res) =&gt; &#123; console.log(&#x27;c:&#x27; + res); &#125;); 统一处理reject 1234567891011121314getPromise(&#x27;a.php&#x27;) .then((res) =&gt; &#123; // a请求成功，res是从resolve获取的结果 return getPromise(&#x27;b.php&#x27;); &#125;) .then((res) =&gt; &#123; return getPromise(&#x27;c.php&#x27;); &#125;) .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); 上面这种写法只要有一个请求失败了，就直接执行catch，剩下的请求就不会继续执行了。 return的返回值then()方法里的返回值，有两种情况： 返回Promise实例对象。返回的该实例对象会调用下一个then 返回普通值。返回的值会直接传递给下一个then，通过then参数中函数的参数接收该值。返回普通值时，由于并没有返回promise实例对象，那它的then是谁来调用的呢？是产生的一个新的默认的promise实例以确保可以继续链式操作。"},{"title":"31天JavaScript学习-第17天.md","path":"2022/03/13/614817e8a0b7/","text":"Ajax（二） JSONJSON(JavaScrtipt Object Notation)：是ES的子集。 JS中json字符串和js对象的互相转化 1234567let jsObj = JSON.parse(ajax.responseText); // 将JSON字符串转化未js对象let Obj = &#123; name: &#x27;zrtty&#x27;, age: 20&#125;;let jsonStr = JSON.stringify(Obj); XMLHttpRequest2级规范化的XMLHttpRequest。 FormData现代Web应用中表单数据的序列化是一项频繁使用的功能。为此定义了FormData类型。 12let data = new FormData();data.append(&#x27;name&#x27;, &#x27;zrtty&#x27;); // 分别接收两个参数：键和值 创建的FormData的实例，可以将它直接传给XHR的send()方法，不必明确地在XHR对象上设置请求头部。XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。 超时设定XHR对象timeout属性，表示请求在等待响应多少毫秒后停止。 123456xhr.open(&#x27;get&#x27;, &#x27;timeout.php&#x27;, true);xhr.timeout = 1000;xhr.ontimeout = function() &#123; alert(&#x27;request timeout&#x27;);&#125;;xhr.send(null); overrideMimeType()方法用于重写XHR响应的MIME类型。 跨域源资源共享默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。同源指的是：域名、协议、端口完全相同。 CORS（Cross-Origin Resource Sharing，跨域源资源共享）定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。其背后思想就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应是否成功。 IE中的CORSIE8中映入了XDR（XDomainRequest）类型。这个对象与XHR相似，单能实现安全可靠的跨域通信。 XDR对象的使用方法和XHR对象非常相似。也是创建一个实例，调用open()方法，再调用send()方法。但XDR对象的open()方法只接收两个参数：请求的类型和URL。所有的XDR请求都是异步执行的，请求返回后，会触发load事件，响应的数据也会保存在responseText属性中。 其他浏览器的CORS其他浏览器无需编写额外代码即可触发这个行为，只要使用标准的XHR对象并在open()方法中传入绝对URL即可。 跨浏览器的CORS不同浏览器对CORS的支持程度并不都一样。所有浏览器都支持简单的请求。检测XHR是否支持CORS的最简单方式，就是检查是否存在withCredentials属性，再结合检测XDomainRequest对象是否存在，就可以兼顾所有浏览器了。 其他跨域技术图像PingJSONPJSONP市JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法。 JSONP是被包含在函数调用中的JSON，如 1callback(&#123; &#x27;name&#x27;: &#x27;zrtty&#x27;&#125; ); JSONP由两部分组成：回调函数和数据。其本质是利用了&lt;script src=&#39;&#39;&gt;&lt;/script&gt;标签具有可跨域的特性，由服务端返回一个预先定义好的JS函数的调用，并且将服务器数据以该函数参数的形式传递过来。此方法需要前后端配合完成。 html标签的src属性是支持跨域的，jsonp就是利用这个特性实现的跨域，但用到是script标签。 jsonp只能通过GET方式进行请求。 123456&lt;script&gt; function handleResponse(response) &#123; console.log(response.ip); &#125;&lt;/script&gt;&lt;script src=&quot;http://freegeoip.net/json/?callback=handleResponse&quot;&gt;&lt;/script&gt; 这个URL是在请求一个JSONP地理定位服务。这里指定的回调函数的名字叫handleResponse()。 JQuery的JSONP 123456789101112131415$(&#x27;#btn&#x27;).click(function () &#123; $.ajax(&#123; url: &#x27;http://freegeoip.net/json/?callback=handleResponse&#x27;, dataType: &#x27;jsonp&#x27;, type: &#x27;get&#x27;, // jsonp: &#x27;callback_name&#x27; // 传递给服务器的回调函数的毛宁子（默认callback) // jsonCallBack: &#x27;responseHandler&#x27; // 自定义的函数名。默认为jQuery自动生成的随机函数名 success: function (response) &#123; console.log(response.ip); &#125;, error: function (err) &#123; console.log(err); &#125; &#125;);&#125;);"},{"title":"31天JavaScript学习-第16天","path":"2022/03/10/6d64816cc903/","text":"Ajax（一） Ajax：Asynchronous JavaScript And XML（异步JavaScript和XML）。Ajax的核心是JS对象：XMLHttpRequest 即可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。 Ajax原理一个完整的http请求需要的是： 请求的网址、请求的方法get&#x2F;post 提交请求的内容数据、请求主体 接收响应回来的内容 对应的，发送Ajax请求的步骤： 创建异步对象，即XMLHttpRequest对象 使用open方法设置请求参数。open(method, url, async) 发送请求：send() 注册事件：注册onreadystatechange事件，状态改变时就会调用 服务端响应，获取返回的数据 话不多说，手写一个Ajax： 123456789101112131415161718192021// 创建XMLHttpRequest对象let xmlhttp = new XMLHttpRequest();// 设置请求的参数。请求的方法、请求的url// 调用open方法并不会真正发送请求，而只是启动一个请求以备发送// 第三个参数true（异步）false（同步），默认truexmlhttp.open(&#x27;get&#x27;, &#x27;ajax.php&#x27;, false);// 发送请求// send方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据// 则必须传入null。调用send()之后，请求就会被分派到服务器xmlhttp.send(null);// 注册事件xmlhttp.onreadystatechange = function ()&#123; // 为了保证数据完整返回，一般判断两个值 if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; // 服务端响应 console.log(&#x27;数据返回成功&#x27; + JSON.stringify(xmlhttp.responseText)); &#125;&#125;; 在收到响应后，响应的数据会自动填充XHR对象的属性： responseText：作为响应主体被返回的文本 responseXML：如果响应的内容类型是”text&#x2F;xml”或”application&#x2F;xml”，这个属性中将保存包含响应数据的XML DOM文档。 status：响应的HTTP状态 statusText：HTTP状态的说明 readyState属性 多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下： 0：未初始化，尚未调用open()方法 1：启动，已经调用open()方法，但尚未调用send()方法 2：发送，已经调用send()方法，但尚未接收到响应 3：接收，已经接收到部分响应数据 4：完成，已经接收到全部的响应数据，已经可以在客户端使用了 每次readyState属性值发生变动，都会触发一次readystatechange事件。 HTTP头部信息每个HTTP请求和响应都会带有相应的头部信息： Head Explain Accept 浏览器能够处理的内容类型 Accept-Charset 浏览器能够显示的字符集 Accept-Encoding 浏览器能处理的压缩编码 Accept-Language 浏览器当前设置的语言 Connection 浏览器与服务器之间连接的类型 Cookie 当前页面设置的任何Cookie Host 发出请求的页面所在域 Referer 发出请求的页面的URI（HTTP规范把referrer拼错了） User-Agent 浏览器的用户代理字符串 使用setRequestHeader()方法可以设置自定义的请求头部信息。接收两个参数：头部字段的名称和头部字段的值。在open()方法之后且调用send()方法之前使用。 get请求get请求将查询字符串参数追加到URL末尾，以便将信息发送给服务器。对于XHR对象，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，而且所有名-值对都必须由&amp;分割： 123456789function addURLParam(url, name, value) &#123; url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;); url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); return url;&#125;let url = &#x27;example.php&#x27;;url = addURLParam(url, &quot;name&quot;, &quot;Nick&quot;);xmlhttp.open(&quot;get&quot;, url, false); post请求post请求通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交。 封装Ajax请求1234567891011121314151617181920212223242526function myAjax(url, success, fail) &#123; // 1、创建XMLHttpRequest对象 let xmlhttp; if (window.XMLHttpRequest) &#123; xmlhttp = new XMLHttpRequest(); &#125; else &#123; xmlhttp = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;); &#125; // 2、发送请求 xmlhttp.open(&#x27;GET&#x27;, url, true); xmlhttp.send(); // 3、服务器响应 xmlhttp.onreadystatechange = function() &#123; if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status ===200) &#123; let obj = JSON.parse(xmlhttp.responseText); console.log(&#x27;数据返回成功&#x27; + obj); success &amp;&amp; success(xmlhttp.responseText); &#125; else &#123; fail &amp;&amp; fail(new Error(&#x27;接口请求失败&#x27;)); &#125; &#125;;&#125;myAjax(&#x27;a.json&#x27;, (res) =&gt; &#123; console.log(res);&#125;); 实际开发中，经常会涉及接口请求之间的依赖：即需要上一个接口请求返回的数据，来发送本次请求。这种层层嵌套的代码，会导致回调地狱的问题，不利于后续的维护。ES6使用Promise来解决该问题。 JQuery中的Ajax123456789101112$.ajax(&#123; url: &#x27;https://xxx.com/getUserInfo.php&#x27;, data: &#x27;name=fox&amp;age=18&#x27;, type: &#x27;GET&#x27;, success: function (argument) &#123; console.log(&#x27;success&#x27;); &#125;, beforeSend: function (argument) &#123; &#125;, error: function (argument) &#123; console.log(&#x27;error&#x27;); &#125;&#125;);"},{"title":"31天JavaScript学习-第15天","path":"2022/03/08/d21dc573f3b7/","text":"JS异步 JS作为浏览器的脚本语言，其执行环境是单线程。 具体来说，是JS引擎中负责解释和执行JS代码的线程只有一个，一次只能完成一项任务。所有的任务都需要排队。但JS引擎执行异步代码而不用等待，是因有为有消息队列和事件循环。 同步与异步 同步任务：在主线程上排队执行的任务。只有前一个任务执行完成，才能执行下一个任务。 异步任务：不进入主线程，而是进入任务队列的任务，该任务不会阻塞后面的任务执行。 异步的使用场景： 事件监听（例如按钮绑定点击事件） 回调函数： 定时器：setTimeout、setInterval ajax请求 Node.js中的一些方法回调 ES6中的Promise、Generator、async&#x2F;await JS的事件循环机制JS主线程把执行栈的代码取出来依次执行。如果代码是同步的会放入执行栈主线程去执行；如果是异步则会放入Event Table中，当异步任务完成后会放入事件队列Event Queue中，这里面存储的是异步任务完成后做的事。等主线程把执行栈里的任务全部完成后，主线程空闲出来，这时才会读取异步队列Event Queue里面的函数，如果队列里有就取出来放到主线程去执行，执行完成后再查看事件队列Event Queue中是否还有异步任务，如果有继续执行。 注：异步调用的结果如果存在依赖，则需要通过回调函数进行嵌套 1234567console.log(1);setTimeout(() =&gt; &#123; console.log(2);&#125;, 0); // 即使等待事件为0，也要等到主线程任务完成才能执行异步任务console.log(3);console.log(4); 12341342 宏任务微任务JS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。 宏任务（macrotask）：常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I&#x2F;O、postMessage、messageChannel、setImmediate（node.js环境） 微任务（microtask）：如Promise、MutaionObserver、process.nextTick(node.js环境) JS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。"},{"title":"31天JavaScript学习-第14天","path":"2022/03/07/f23a5dcde0bc/","text":"ES6语法 简介ES 的全称是 ECMAScript，它是由 ECMA 国际标准化组织 制定的一套脚本语言的标准化规范。 ES6 是新的 JS 语法标准。ES6 实际上是一个泛指，泛指 ES 2015 及后续的版本。 掌握 ES6 之后，如果你的业务需要考虑 ES5 的兼容性，则可以这样做：写 ES6 语法的 js 代码，然后通过 Babel将 ES6 转换为 ES5。 PS：我们在写代码时，能用单引号尽量用单引号，而不是双引号，前者在压缩之后，程序执行会更快。 let、const和块级作用域ES6中，新增了let和const来定义变量： let：定义变量，替代var。用let声明的变量，具有块级作用域，只在局部起作用。 const：定义常量，定义后不可修改。用const声明的常量，只在块级作用域内起作用，且必须在声明时赋值。 暂时性死区（TDZ） ES6规定，使用let&#x2F;const声明的变量，会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。 let 和 const 的特点【重要】 不属于顶层对象 Window 不允许重复声明 不存在变量提升 暂时性死区 支持块级作用域 相反， 用var声明的变量：存在变量提升、可以重复声明、没有块级作用域。 变量的解构赋值ES6允许我们，按照一一对应的方式，从数组或对象中提取值，再将提取出来的值赋值给变量。 数组的解构赋值将数组中的值按照位置提取出来，然后赋值给变量 1let [a, b, c] = [1, 2, 3]; 两边数量不相等的情况： 变量数量&gt;值的数量：多余的变量被赋值为undefined 变量数量&lt;值的数量：正常赋值 解构时，左边变量可以有默认值 1234let [a, b, c=10] = [1, 2]console.log(a); // 1console.log(b); // 2console.log(c); // 10 赋值中含有undefined和null的情况 1234let [a, b, c=10] = [1, undefined, undefined]console.log(a); // 1console.log(b); // undefinedconsole.log(c); // 10 1234let [a, b, c=10] = [1, null, null]console.log(a); // 1console.log(b); // nullconsole.log(c); // null 对象的解构赋值将对象中的值按照属性匹配的方式提取出来，然后赋值给变量。 ES6前，我们从接口拿到json数据后，一般这么赋值 12345var name = json.name;var age = json.age;var sex = json.sex; ES6后，可以简化成 123456const person = &#123; name: &#x27;zrtty&#x27;, age: 28, sex: &#x27;男&#x27; &#125;;let &#123; age, name, sex &#125; = person; // 对象的结构赋值console.log(name); // 打印结果：zrttyconsole.log(age); // 打印结果：28console.log(sex); // 打印结果：男 上方代码可以看出，对象的解构与数组的结构，有一个重要的区别：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，是根据键来取值的。 两边数量不相等的情况： 变量数量&gt;值的数量：多余的变量被赋值为undefined 变量数量&lt;值的数量：正常赋值 变量自定义命名解构赋值 12345678const person = &#123; name: &#x27;zrtty&#x27;, age: 28 &#125;;let &#123; name: myName, age: myAge &#125; = person; // 对象的结构赋值console.log(myName); // 打印结果：zrttyconsole.log(myAge); // 打印结果：28console.log(name); // 打印报错：Uncaught ReferenceError: name is not definedconsole.log(age); // 打印报错：Uncaught ReferenceError: age is not defined 圆括号的使用 如果变量 foo 在解构之前就已经定义了，此时你再去解构，就会出现问题。下面是错误的代码，编译会报错： 123let foo = &#x27;haha&#x27;;&#123; foo &#125; = &#123; foo: &#x27;smyhvae&#x27; &#125;;console.log(foo); 要解决报错，只要在解构的语句外边，加一个圆括号即可： 123let foo = &#x27;haha&#x27;;(&#123; foo &#125; = &#123; foo: &#x27;smyhvae&#x27; &#125;);console.log(foo); //输出结果：smyhvae 字符串结构字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。举例如下： 123456const [a, b, c, d] = &#x27;hello&#x27;;console.log(a); // hconsole.log(b); // econsole.log(c); // lconsole.log(typeof a); // string 箭头函数ES6的箭头函数语法： (arg1, agr2, ...) =&gt; &#123; 函数体 &#125; 注： 如果有且仅有1个形参，则()可以省略 如果函数体内有且仅有1条语句，则&#123;&#125;可以省略，前提是这条语句必须时return语句，且返回语句无需return关键字 如 123456789101112131415function fn1 (a, b) &#123; console.log(&#x27;haa&#x27;); return a + b;&#125;const fn2 = (a, b) =&gt; &#123; console.log(&#x27;haha&#x27;); return a + b;&#125;const fn3 = a =&gt; &#123; console.log(&#x27;haha&#x27; + a);&#125;const fn4 = (a, b) =&gt; a - b; this指向箭头函数的作用只是为了写法更简洁吗？不仅仅是这个原因，还有一个很大的作用是this的指向有关。 this指向的区别 ES5：this指向函数被调用的对象 ES6：箭头函数本身不绑定this，this指向的是箭头函数定义位置的this（箭头函数在哪个位置定义的，this就跟这个位置的this指向相同）。 例如 1234567891011const obj = &#123; name: &#x27;zrtty&#x27; &#125;;function fn1() &#123; console.log(this); // &#123; name: &#x27;zrtty&#x27; &#125; return () =&gt; &#123; console.log(this); &#125;;&#125;const fn2 = fn1.call(obj);fn2(); // &#123; name: &#x27;zrtty&#x27; &#125; fn1.call(obj)执行之后，第一个this就指向了被调用的对象obj；而箭头函数是在fn1()函数里定义的，所以第二个this和第一个this指向的是同一个位置。 面试题 123456789var name = &#x27;许嵩&#x27;;var obj = &#123; name: &#x27;zrtty&#x27;, sayHello: () =&gt; &#123; console.log(this.name); &#125;,&#125;;obj.sayHello(); 打印结果是许嵩。因为obj对象并不产生作用域，定义在obj内部的sayHello箭头函数实际仍定义在全局作用域中，也就是this指向window。 参数默认值传统写法： 1234function fn(param) &#123; let p = param || &#x27;hello&#x27;; console.log(p);&#125; ES6写法： 123function fn(param = &#x27;hello&#x27;) &#123; console.log(param);&#125; 注：默认值的后面，不能再有没有默认值的变量 剩余参数剩余参数允许我们将不确定数量的剩余的元素放到一个数组中。 比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。 传统写法（会报错） 12345678function fn(a, b, c) &#123; console.log(a); console.log(b); console.log(c); console.log(d);&#125;fn(1, 2, 3); ES6 写法： 12345678910const fn = (...args) =&gt; &#123; //当不确定方法的参数时，可以使用剩余参数 console.log(args[0]); console.log(args[1]); console.log(args[2]); console.log(args[3]);&#125;;fn(1, 2); // 1 2 undefined undefinedfn(1, 2, 3); // 1 2 3 undefined 方法的定义中了四个参数，但调用函数时只使用了三个参数，ES6 中并不会报错。 注：args 参数之后，不能再加别的参数，否则编译报错。 扩展语法（展开语法）扩展运算符和剩余参数是相反的。 剩余参数是将剩余的元素放到一个数组中；而扩展运算符是将数组或者对象拆分成逗号分隔的参数序列。 如 12345const arr = [10, 20, 30];console.log(arr); // [ 10, 20, 30 ]console.log(...arr); // 10 20 30console.log(10, 20, 30); // 10 20 30 举例1：数组赋值 12345678let arr1 = [&#x27;www&#x27;, &#x27;smyhvae&#x27;, &#x27;com&#x27;];let arr2 = arr1; // 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址console.log(&#x27;arr1:&#x27; + arr1); // arr1:www,smyhvae,comconsole.log(&#x27;arr2:&#x27; + arr2); // arr2:www,smyhvae,comarr2.push(&#x27;你懂得&#x27;); //往 arr2 里添加一部分内容console.log(&#x27;arr1:&#x27; + arr1); // arr1:www,smyhvae,com,你懂得console.log(&#x27;arr2:&#x27; + arr2); // arr2:www,smyhvae,com,你懂得 12345678let arr1 = [&#x27;www&#x27;, &#x27;smyhvae&#x27;, &#x27;com&#x27;];let arr2 = [...arr1]; //【重要代码】arr2 会重新开辟内存地址console.log(&#x27;arr1:&#x27; + arr1);console.log(&#x27;arr2:&#x27; + arr2);arr2.push(&#x27;你懂得&#x27;); //往arr2 里添加一部分内容console.log(&#x27;arr1:&#x27; + arr1); // arr1:www,smyhvae,comconsole.log(&#x27;arr2:&#x27; + arr2); // arr2:www,smyhvae,com,你懂得 举例2：合并数组 123456789101112let arr1 = [&#x27;王一&#x27;, &#x27;王二&#x27;, &#x27;王三&#x27;];let arr2 = [&#x27;王四&#x27;, &#x27;王五&#x27;, &#x27;王六&#x27;];// ...arr1 // &#x27;王一&#x27;,&#x27;王二&#x27;,&#x27;王三&#x27;// ...arr2 // &#x27;王四&#x27;,&#x27;王五&#x27;,&#x27;王六&#x27;// 方法1let arr3 = [...arr1, ...arr2];console.log(arr3); // [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;, &quot;王四&quot;, &quot;王五&quot;, &quot;王六&quot;]// 方法2arr1.push(...arr2);console.log(arr1); // [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;, &quot;王四&quot;, &quot;王五&quot;, &quot;王六&quot;] 举例3：将伪数组或者可遍历对象转换为真正的数组 12const myDivs = document.getElementsByClassName(&#x27;div&#x27;);const divArr = [...myDivs]; // 利用扩展运算符，将伪数组转为真正的数组 Set数据结构ES6提供了新的数据结构Set。Set类似于数组，但成员的值都是唯一的，没有重复的值。 Set的创建 12const set1 = new Set();console.log(set1.size); Set的用法之一：数组去重 123456789101112const set2 = new Set([&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;张三&#x27;]); // 注意，这个数组里有重复的值// 注意，这里的 set2 并不是数组，而是一个单纯的 Set 数据结构console.log(set2); // &#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;&#125;console.log(typeof set2); // objectconsole.log(set2 instanceof Array); // 通过扩展运算符，拿到 set 中的元素（用逗号分隔的序列）// ...set2 // &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;// 注意，到这一步，才获取到了真正的数组console.log([...set2]); // [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]"},{"title":"31天JavaScript学习-第13天","path":"2022/03/06/70af1cdbe9cd/","text":"事件 JS与HTML之间的交互是通过事件实现的。 事件的三要素：事件源、事件、事件驱动程序。 事件流事件流是描述从页面中接收事件的顺序。IE的事件流是事件流冒泡，Netscape的事件流是事件捕获流。 事件流冒泡事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。 12345678&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myDiv&quot;&gt;Click Me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果你点击了页面中的&lt;div&gt;元素。那么这个click事件会按照如下的顺序传播： &lt;div&gt; &lt;body&gt; &lt;html&gt; document 所有的现代浏览器都支持事件冒泡，Firfox、Chrome等会将事件一直冒泡到window对象。 事件捕获流事件捕获流的顺序与事件冒泡流相反，不太具体的节点应该更早接收到事件。其用意时在事件达到预定目标之前捕获它。 DOM事件流DOM2级事件规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 以前面的点击div元素为例。 在事件捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。 下一个阶段时”处于目标阶段”，事件在&lt;div&gt;上发生，并在事件处理中被看成冒泡阶段的一部分。 冒泡阶段发生，事件又传播回文档。 事件处理程序事件是用户或浏览器自身执行的某种动作。而响应某个事件的函数就叫做事件处理程序。 HTML事件处理程序1&lt;input type=&#x27;button&#x27; value=&#x27;Click Me&#x27; onclick=&#x27;alert(&#x27;Clicked&#x27;)&#x27; /&gt; 123456&lt;input type=&#x27;button&#x27; value=&#x27;Click Me&#x27; onclick=&#x27;showMessage()&#x27; /&gt;&lt;script&gt; function showMessage()&#123; alert(&quot;hello world&quot;) &#125; &lt;/script&gt; DOM0级事件处理程序1234var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function() &#123; alert(&quot;Clicked&quot;);&#125;; 使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素内部的作用域中运行的。 缺点：不能同时对一个DOM绑定多个相同事件。 DOM2级事件处理程序 addEventListener() removeEventListener() 所有的DOM节点都包含这两个方法，并都接收三个参数： 要处理的事件名 作为事件处理程序的函数 一个布尔值：true，在捕获阶段调用事件处理程序；false，在冒泡阶段调用事件处理程序。 1234567var btn = document.getElementById(&quot;myBtn&quot;);btn.addEventListener(&quot;click&quot;, function()&#123; alert(&quot;this.id&quot;);&#125;, false);btn.addEventListener(&quot;click&quot;, function()&#123; alert(&quot;Hello world&quot;);&#125;, false); DOM2级事件处理程序可以添加多个事件处理程序。 通过addEventListener()添加的事件处理程序只能通过removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着由于上面例子中传入的是匿名函数，因此无法在移除时添加相同的参数。正确例子如下： 123456var btn = document.getElementById(&quot;myBtn&quot;);var handler = function()&#123; alert(&quot;this.id&quot;);&#125;;btn.addEventListener(&quot;click&quot;, handler, false);btn.removeEventListener(&quot;click&quot;, handler, false); 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段。 事件对象当触发DOM上的某个事件时，会产生一个事件对象event。浏览器每次都会将这个事件event作为实参传进之前的响应函数。 1234567var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event) &#123; alert(event.type);&#125;;btn.addEventListener(&quot;click&quot;, function(event)&#123; alert(&quot;event.type&quot;);&#125;, false); 事件类型UI事件load事件 当页面完全加载完后（包括所有图像、JS文件、CSS文件等外部资源），就会触发window的load事件。 有两种定义onload事件处理程序的方式。 123EventUtil.addHandler(window, &quot;load&quot;, function(event)&#123; alert(&quot;loaded&quot;);&#125;); 123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body onload=&quot;alert(&#x27;loaded&#x27;)&quot;&gt; &lt;/body&gt;&lt;/html&gt; 一般来说，在window上面发生的任何事件都可以在&lt;body&gt;元素中通过相应的特性来指定，因为在HTML中无法访问window元素。 在图像上也可以触发onload事件。 unload事件 当文档被完全卸载后触发，只要用户从一个页面切换到另一个页面，就会发生unload事件。 resize事件 当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。可以通过JS或&lt;body&gt;元素中的onresize特性来指定事件处理程序。 scroll事件 当浏览器窗口滚动时触发。 焦点事件焦点事件会在页面元素获得或失去焦点时触发。有以下6个焦点事件： blur：在元素失去焦点时触发。这个事件不会冒泡。 focus：在元素获得焦点时触发。这个事件不会冒泡。 DOMFocusIn：在元素获得焦点时触发。只有Opera支持该事件。DOM3已弃用。 DOMFocusOut：在元素失去焦点时触发。只有Opera支持该事件。DOM3已弃用。 focusing：在元素失去焦点时触发。这个事件会冒泡。 focusout：在元素获得焦点时触发。这个事件会冒泡。 事件委托事件委托，就是把一个元素相应事件的函数委托到另一个元素。 例如有一个无序列表ul，列表之中有大量的&lt;a&gt;标签，当鼠标移到&lt;a&gt;标签上的时候，需要触发相应的处理事件。通常的写法是为每个&lt;a&gt;标签都绑定类似onMouseOver的事件监听。 12345678910window.onload = function()&#123; var parentNode = document.getElementById(&quot;parent-list&quot;); var aNodes = parentNode.getElementByTagName(&quot;a&quot;); for(var i=0, l = aNodes.length; i &lt; l; i++)&#123; aNodes[i].onclick = function() &#123; console.log(&#x27;我是超链接 a 的单击相应函数&#x27;); &#125; &#125;&#125; 但是这种做法过于消耗性能。我们希望，只绑定一次事件，即可应用到多个元素上，即使元素是后来添加的。 因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件函数的时候再去匹配判断目标元素。如下： 1234567891011121314151617181920&lt;ul id=&quot;parent-list&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;my_link&quot;&gt;超链接一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;my_link&quot;&gt;超链接二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;my_link&quot;&gt;超链接三&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function()&#123; // 获取父节点，并为它绑定click单击事件。 false 表示事件在冒泡阶段触发（默认） document.getElementById(&#x27;parent-list&#x27;).addEventListener(&#x27;click&#x27;, function(event)&#123; event = event || window.event; // e.target 表示：触发事件的对象 //如果触发事件的对象是我们期望的元素，则执行否则不执行 if (event.target &amp;&amp; event.target.className == &#x27;my_link&#x27;) &#123; console.log(&#x27;我是ul的单击响应函数&#x27;); &#125; &#125;, false); &#125;;&lt;/script&gt; 为父节点注册click事件，当子节点被点击时，click事件会向父节点冒泡。父节点捕获到事件后，通过判断event.target拿到被点击的子节点的相应信息，并做处理。"},{"title":"31天JavaScript学习-第12天","path":"2022/03/05/4bd2394aa2c3/","text":"DOM Node类型DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。 节点（Node）是构成HTML的最基本单元。 DOM1级定义了一个Node接口，该接口实现了DOM中的所有节点类型。这个Node接口在JS中是作为Node类型实现的，所有节点类型都继承自Node类型，因此所有的节点类型都共享着相同的属性和方法。 每个节点都有一个NodeType属性，用于表明节点的类型： 节点类型 值 Node.ELEMENT_NODE 1 Node.ATTRIBUTE_NODE 2 Node.TEXT_NODE 3 Node.CDATA_SECTION_NODE 4 Node.ENTITY_REFERENCE_NODE 5 Node.ENTITY_NODE 6 Node.PROCESSING_INSTRUCTION_NODE 7 Node.COMMENT_NODE 8 Node.DOCUMENT_NODE 9 Node.DOCUMENT_TYPE_NODE 10 Node.DOCUMENT_FRAGMENT_NODE 11 Node.NOTATION_NODE 12 节点关系节点之间存在着以下几种关系，均可通过节点属性访问 childNodes：子节点 parentNode：父节点 previousSibling：上一个兄弟节点 nextSibling：下一个兄弟节点 firstChild：第一个子节点 lastChild：最后一个子节点 ownerDocument：指向整个文档的文档节点 节点操作DOM树可以看成是由一系列指针连接起来的，但任何DOM节点不能同时出现在文档的多个位置上。 节点创建和删除DOM提供了一些操作节点的方法 方法 说明 备注 appendChild() 向childNodes列表末尾添加一个节点 返回新增的节点 insertBefore() 往特定的位置之前插入节点 返回新增的节点 replaceChild() 用新节点替换旧节点 被替代的节点仍在文档中，只是没有了位置 removeChild() 移除节点 返回移除的节点，仍在文档中 createElement() 创建节点 返回新增的节点 cloneNode() 创建节点的副本 true深复制，false浅复制 Document类型文档信息document对象是HTMLDocument的一个实例，存在一些表现网页的一些信息的属性。 属性 说明 document.title &lt;title&gt;元素中的文本 document.URL 页面完整的URL document.domain 页面的域名 document.referrer 链接到当前页面的URL 方法 说明 备注 document.getElementById() 通过id获取一个元素节点 document.getElementsByTagName() 通过标签名获取元素节点数组 document.getElementsByClassName() 通过类名获取元素节点数组 Element类型节点属性 方法 说明 getAttribute() 获取节点的属性值 setAttribute() 设置节点的属性值 removeAttribute() 删除节点的属性"},{"title":"31天JavaScript学习-第11天","path":"2022/03/04/705c17f8d6dc/","text":"BOM和客户端检测 BOMBOM（Browser Object Model，浏览器对象模型），BOM可以操作浏览器部分功能的API。 常见的BOM对象 Window：代表整个浏览器的窗口，同时 window 也是网页中的全局对象。 Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。 Location：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。 History：代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。 Screen：代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。 注：这些 BOM 对象都是作为 window 对象的属性保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 window.location.href，也可以直接使用 location.href，二者是等价的。 window对象在浏览器中，window对象有两种角色，它既是JS访问浏览器窗口的一个接口，又是ES规定的Global对象。 如果页面中包含框架&lt;frame&gt;，则每个框架都有自己的window对象，并保存在frames集合中。每个window对象都有一个name属性，其中包含框架名称。 window对象常用的方法 方法 描述 window.moveTo 移动窗口到x, y window.resizeTo 调整窗口到w, h window.open 导航到一个特定的url alert() 弹出警告 confirm() 弹出带确认的警告 prompt() 弹出输入提示框 navigator对象window.navigator 的一些属性可以获取客户端的一些信息。 userAgent：系统，浏览器) platform：浏览器支持的系统，win&#x2F;mac&#x2F;linux location对象window.location可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。 location对象的属性 href：跳转 hash 返回url中#后面的内容，包含# host 主机名，包括端口 hostname 主机名 pathname url中的路径部分 protocol 协议 一般是http、https search 查询字符串 location对象的方法 location.assign()：改变浏览器地址栏的地址，并记录到历史中 设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。 location.replace()：替换浏览器地址栏的地址，不会记录到历史中 location.reload()：重新加载 客户端检测"},{"title":"31天JavaScript学习-第10天","path":"2022/03/03/1ab97e8ff9a4/","text":"函数表达式（二）——应用 模仿块级作用域JS中没有块级作用域的概念。使用匿名函数可以用来模仿块级作用域。 123(function()&#123; // 块级作用域&#125;)(); 该代码定义并立即调用了一个匿名函数，将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。 私有变量JS中没有私有成员的概念，所有对象属性都是公有的。但在任何函数中定义的变量，都可以认为是私有变量。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链可以访问这些对象。就可以创建用于访问私有变量的公有方法。 把有权访问私有变量和私有函数的公有方法成为特权方法。有两种在对象上创建特权方法的方式。 方式一：构造函数中定义特权方法 1234567891011121314function Person(name) &#123; this.getName = function() &#123; return name; &#125;; this.setName = function(value) &#123; name = value; &#125;;&#125;var person = new Person(&#x27;Jack&#x27;);console.log(person.getName()); // Jackperson.setName(&#x27;Greg&#x27;);console.log(person.getName()); // Greg 这种定义特权方法有一个缺点，就是只能使用构造函数模式。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法。 方式二：静态私有变量 通过在私有作用域中定义私有变量或函数，同样可以创建特权方法。 1234567891011121314151617181920(function () &#123; // 私有变量和私有函数 var name = &#x27;&#x27;; Person = function (value) &#123; name = value; &#125;; Person.prototype.getName = function () &#123; return name; &#125;; Person.prototype.setName = function (value) &#123; name = value; &#125;;&#125;)();var person = new Person(&#x27;Jack&#x27;);console.log(person.getName());person.setName(&#x27;Greg&#x27;);console.log(person.getName());"},{"title":"31天JavaScript学习-第9天","path":"2022/03/02/b4aa5ee2478d/","text":"函数表达式（一）——闭包 递归递归函数是在一个函数通过名字调用自身的情况下构成的，如前篇说过的阶乘函数： 1234567function factorial(num) &#123; if (num &lt; 1) &#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125; 这里在函数内调用自身函数名可以使用arguments.callee，指向正在执行函数的指针代替。 但在严格模式下，不能通过脚本访问arguments.callee，可以使用命名函数表达式来达成同样效果。 1234567var factorial = (function f(num) &#123; if (num &lt; 1) &#123; return 1; &#125; else &#123; return num * f(num - 1); &#125;&#125;); 闭包闭包是指有权访问另一个函数作用域中的变量的函数。 JS中变量的作用域无非两种，全局变量和局部变量。JS可以在函数内部直接读取全局变量。如何实现在全局作用域中访问到函数内的局部变量呢？就是使用JS作用域链的特性以达到该目的。 个人理解JS的闭包的作用类似JAVA中的封装，数据使用private修饰符修饰类属性被保护在类的内部，尽可能隐藏内部细节，只保留外部接口getter、setter访问。不完全对，较为浅显。 作用域链作用域里面嵌套作用域，就形成了作用域链。 当某个函数被调用时，会创建一个执行环境（执行上下文）以及相应的作用域链。 每个执行环境都有一个表示变量的对象——变量对象。一个新的执行环境的声明周期可以分为两个阶段。 代码编译阶段 在这个阶段中，执行环境会分别创建变量对象，建立作用域，以及确定this的指向。 代码执行阶段 创建完成之后，就会开始执行代码，这时会完成变量赋值，函数引用，以及执行其他代码。 在函数执行过程中，为读取和写入变量的值，需要在作用域链中查找变量 1234567891011function compare(value1, value2) &#123; if (value1 &gt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var result = compare(5, 10); 当调用compare函数时，会将其执行环境中的变量对象转化为活动对象，其作用域链如图 作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 变量对象变量对象的创建，依次经历以下步骤。 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。 检查当前上下文的函数声明，即用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。 从上面的规则可以看出，function声明会比var声明优先级更高一点。 下面用一个例子来理解变量对象（Variable Object, OV）的创建和活动对象（Activate Object, AO）的转化 1234567891011function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test(); 123456// 创建阶段VO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, // foo地址引用 a: undefined&#125; 未进入执行阶段前，变量对象中的属性都不能访问。但进入执行阶段后，变量对象转变成了活动对象，里面的属性都能被访问了，然后开始进入执行阶段的操作。 Q：变量对象和活动对象的区别？ A：它们都是同一个对象，只是处在执行的不同生命周期。 1234567// 执行阶段// VO -&gt; AOAO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, a: 1&#125; 此时，上面的例子，执行顺序就变成了这样 123456789function test() &#123; function foo() &#123; return 2; &#125; var a; console.log(a); console.log(foo()); a = 1;&#125; 执行上下文JS中可执行的代码类型有三种： 全局代码：外部js文件或者本地标签内的代码，全局代码不包括function体内的代码。 函数代码：function体内的代码。 eval代码：eval()函数计算某个字符串，并执行其中的代码。 当JS引擎遇到这三种代码，分为两个阶段，代码编译阶段和代码执行阶段。编译阶段由编译器完成，将代码编译成为可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 JS引擎，不是逐条解释js代码，而是按照代码块一段段解释执行。所谓代码块是使用&lt;script&gt;标签分隔的代码段。 对于常见编译型语言（Java等），编译步骤为：词法分析-&gt;语法分析-&gt;语义检查-&gt;代码优化和字节生成 对于解释型语言（JavaScript等），通过词法分析和语法分析得到语法树后，就可以开始解释执行了。 闭包的实现一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况有所不同。 1234567891011function player() &#123; var life = 3; function lose_life() &#123; life--; console.log(life); &#125; return lose_life;&#125;var mario = player();mario(); // 2 这个例子中，函数lose_life被包括在函数player内部，player内部所有局部变量对lose_life都是可见的。既然如此，把lose_life作为返回值，就可以在player外部读取它的内部变量了。 闭包的用途 可以读取到函数内部的变量 让函数内部的变量始终保持在内存中 123456789101112131415function player() &#123; var life = 3; loss_life = function () &#123; life--; &#125; function show_life() &#123; console.log(life); &#125; return show_life;&#125;var mario = player();mario(); // 3loss_life();mario(); // 2 可以看到，player函数在运行一次后，局部变量life并没有被删除。原因是player是show_life的父函数，而show_life被赋给了一个全局变量mario，这导致show_life始终在内存中，而show_life的存在依赖于player，因此player也是种在内存中，不会在调用结束后，被垃圾回收机制删除。 闭包与作用域链123456789101112131415161718function createComparisonFunc(propertyName) &#123; return function (obj1, obj2) &#123; var value1 = obj1[propertyName]; var value2 = obj2[propertyName]; if (value1 &gt; value2) &#123; return -1; &#125; else if (value1 &lt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;var compare = createComparisonFunc(&#x27;name&#x27;);var result = compare(&#123;name: &#x27;Nick&#x27;&#125;, &#123;name: &#x27;Jack&#x27;&#125;);compare = null; // 解除对匿名函数的引用（释放内存） 当createComparisonFunc()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，createComparisonFunc()的活动对象才会被销毁。 使用闭包的注意点由于闭包会使得函数中的变量始终被保存在内存中，所以不能滥用闭包，否则会出现性能问题。解决方法是，在推出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便更改父函数内部变量的值。"},{"title":"31天JavaScript学习-第8天","path":"2022/02/28/7bfb6a04e4f3/","text":"面向对象（二）——继承 在众多OO语言中支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于JS函数没有签名，无法实现接口继承，只能支持实现继承。 原型链原型链实现继承ES将原型链作为实现继承的主要方法。其基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。 每个构造函数都有一个由prototype属性指向的原型对象，原型对象包含一个指向构造函数的指针constructor，而实例都包含一个指向原型的内部指针[[prototype]]。 实现原型链有一种基本模式，代码如下： 1234567891011121314151617181920function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;SubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); 这段代码的原型链图如下所示： 由于SubType的原型等于了SuperType的实例对象，等价于SubType的原型指向SuperType的原型。SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例附给SubType的原型实现的。换句话说，原来存在SupeType的实例中的属性和方法，现在也存在于SubType的原型中了。 别忘了默认的原型 所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。 确定原型和实例的关系 instanceof：实例与原型链中出现过的构造函数，结果就会返回true isPrototypeOf：原型链中出现过的原型，都是该原型链所派生的实例的原型 原型链的问题使用原型链实现继承最大的问题就是包含引用类型值的原型。 123456789101112131415function SuperType() &#123; this.color = [&#x27;red&#x27;, &#x27;green&#x27;];&#125;function SubType() &#123;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.color.push(&#x27;black&#x27;);console.log(instance1.color); // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]var instance2 = new SubType();console.log(instance2.color); // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ] SubType的所有实例都会共享一个color属性，对instance1的修改能通过instance2反映出来。因此，实践中很少单独使用原型链。 借用构造函数在子类型构造函数的内部调用超类型构造函数。 123456789101112131415function SuperType() &#123; this.color = [&#x27;red&#x27;, &#x27;green&#x27;];&#125;function SubType() &#123; // 继承了SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.color.push(&#x27;black&#x27;);console.log(instance1.color);var instance2 = new SubType();console.log(instance2.color); SubType的每个实例都会具有自己的color属性的副本。 传递参数借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。 123456789101112function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; SuperType.call(this, &#x27;jack&#x27;); this.age = 29;&#125;var instance = new SubType();console.log(instance.name); // jackconsole.log(instance.age); // 29 但仅仅使用构造函数，也无法避免构造函数模式的问题——方法都在构造函数中定义，无法实现函数复用。 组合继承使用原型链实现对原型属性和方法的继承，使用借用构造函数实现对实例属性的继承。 1234567891011121314151617181920212223242526272829303132function SuperType(name) &#123; this.name = name; this.color = [&#x27;red&#x27;, &#x27;green&#x27;];&#125;SuperType.prototype.sayName = function() &#123; // 继承属性 console.log(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; console.log(this.age);&#125;var instance1 = new SubType(&#x27;jack&#x27;, 20);instance1.color.push(&#x27;blue&#x27;);console.log(instance1.color); // [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27; ]instance1.sayName(); // jackinstance1.sayAge(); // 20var instance2 = new SubType(&#x27;Greg&#x27;, 24);console.log(instance2.color); // [ &#x27;red&#x27;, &#x27;green&#x27; ]instance2.sayName(); // Greginstance2.sayAge(); // 24 组合式继承是JS中最常用的继承模式，而且，instancof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 原型式继承该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用new操作符创建实例，并返回这个实例，本质是一个浅拷贝。 12345function object(obj) &#123; function F() &#123;&#125;; F.prototype = obj; return new F();&#125; 例子如下： 1234567891011121314151617181920function object(obj) &#123; function F() &#123;&#125;; F.prototype = obj; return new F();&#125;var person = &#123; name: &#x27;jack&#x27;, friends: [&#x27;a1&#x27;, &#x27;a2&#x27;]&#125;;var anotherPerson = object(person);anotherPerson.name = &#x27;Greg&#x27;;anotherPerson.friends.push(&#x27;b1&#x27;);var person3 = object(person);person3.name = &#x27;Linda&#x27;;person3.friends.push(&#x27;c1&#x27;);console.log(person.friends); // [ &#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;b1&#x27;, &#x27;c1&#x27; ] 当想让一个对象与另一个对象保持类似的情况下，原型式继承可以胜任，其中包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。 ES5使用Object.create()方法规范化了原型式继承。该方法接收两个参数： 新对象原型的对象 （可选）为新对象定义额外属性的对象 1234567891011121314151617var person = &#123; name: &#x27;jack&#x27;, friends: [&#x27;a1&#x27;, &#x27;a2&#x27;]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = &#x27;Greg&#x27;;anotherPerson.friends.push(&#x27;b1&#x27;);var person3 = Object.create(person, &#123; name: &#123; value: &quot;Linda&quot; &#125;&#125;);console.log(person.friends); // [ &#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;b1&#x27; ]console.log(person3.name); // &quot;Linda&quot; 寄生式继承123456789101112131415161718192021function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function createAnother(original) &#123; var clone = object(original); clone.sayHi = function() &#123; console.log(&#x27;hi&#x27;); &#125;; return clone;&#125;var person = &#123; name: &#x27;jack&#x27;, friends: [&#x27;Linda&#x27;, &#x27;Cook&#x27;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。"},{"title":"31天JavaScript学习-第7天","path":"2022/02/26/530fde90e882/","text":"面向对象（一）——对象简介与创建 JS中的面向对象，是基于原型的面向对象，依靠构造器（constructor）和原型（prototype）。 ES6中，引入了类（Class）和继承（Extend）来实现面向对象。 对象字面量1234const obj1 = &#123; name: &#x27;zr&#x27;, age: 28&#125;; 工厂模式123456789101112function createPerson (name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () &#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson(&#x27;jack&#x27;, 20, &#x27;doctor&#x27;); 使用工厂模式创建的对象，使用的构造函数都是Object，所以创建的对象都是Object类型，无法区分多种不同类型的对象。 构造函数模式构造函数：是用来创建和初始化对象的特殊的函数，它与new一起使用才有意义。 123456789101112131415function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function () &#123; alert(this.name); &#125;;// 不需要return对象&#125;var person1 = new Person(&#x27;zr&#x27;, 20, &#x27;student&#x27;);var person2 = new Person(&#x27;jack&#x27;, 30, &#x27;doctor&#x27;);// 所有对象均继承自Objectalert(person1 instanceof Object); // truealert(person1 instanceof Person); // true 不同函数this的指向： 以函数的形式调用时，this永远指向window。 以方法的形式调用时，this指向调用方法的对象。 以构造函数形式调用时，this指向新创建的实例对象。 构造函数的问题： 每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数时不相等的。按照上面这种写法，假设创建10000个对象实例，就会创建10000个 sayName 方法。这种写法肯定是不合适的。我们为何不让所有的对象共享同一个方法呢？ 还有一种方式是，将sayName方法在全局作用域中定义：（不建议。原因看注释） 12345678910111213141516function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; //向对象中添加一个方法 this.sayName = fun;&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 */function fun() &#123; alert(&quot;Hello大家好，我是:&quot; + this.name);&#125;; 原型模式原型对象每个创建的函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象包含了通过调用该构造函数所创建的对象共享的属性和方法。运行机制如下： 创建一个自定义的构造函数后，其原型对象默认只有constructor（构造函数）属性（指向prototype属性所在函数的指针）。 调用构造函数创建一个新实例，实例内部将包含一个指针指向构造函数的原型对象。ES5中称这个指针为[[prototype]]，Firefox、Safari和Chrome在每个对象上都支持一个属性__proto__。 如上图所示，person1实例不包含属性和方法，但它仍可以调用到它的原型对象的属性和方法，这是通过查找对象属性的过程实现的。 每当代码读取某个对象的某个属性时，都会执行一次搜索，搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象。 虽然可以通过对象实例访问保存在原型中的值，但不能通过对象实例重写原型中的值。 即使将实例的同名属性设为null，也只会在实例中设置这个属性。使用delete操作符可以完全删除实例属性，从而重新访问原型中的同名属性。 一些方法： isPrototypeOf() 确定是否是实例对象的原型对象 Object.getPrototypeOf() 返回对象的原型对象 hasOwnProperty() 检测一个属性是存在于实例中，还是存在原型中。存在对象实例中返回true。 in操作符单独使用：检查对象中是否含有某个属性，无论是在实例对象还是在其原型对象。 for-in：返回所有能通过对象访问的、可枚举的（enumerated）属性。 更简单的原型语法前面的例子中每添加一个属性和方法都要用Person.prototype。为简化操作，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。 12345678910function Person() &#123;&#125;Person.prototype = &#123; name: &#x27;jack&#x27;, age: 20, job: &#x27;doctor&#x27;, sayName: function() &#123; alert(this.name); &#125;&#125;; 原型的动态性原生对象的原型原型模式不仅体现在创建自定义类型方面，也体现在原生的引用类型。但不建议修改原生对象的原型。 组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。 12345678910111213141516171819202122function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.frieds = [&#x27;jack&#x27;, &#x27;zr&#x27;];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person(&#x27;Nick&#x27;, 23, &#x27;doctor&#x27;);var person2 = new Person(&#x27;Grey&#x27;, 32, &#x27;Engineer&#x27;);person1.frieds.push(&#x27;Van&#x27;);console.log(person1.frieds); // [ &#x27;jack&#x27;, &#x27;zr&#x27;, &#x27;Van&#x27; ]console.log(person2.frieds); // [ &#x27;jack&#x27;, &#x27;zr&#x27; ]console.log(person1.frieds === person2.frieds); // falseconsole.log(person1.sayName === person2.sayName); //true 动态原型模式12345678910111213function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; if (typeof this.sayName != &#x27;function&#x27;) &#123; Person.prototype.sayName = function () &#123; console.log(this.name); &#125; &#125;&#125;var friend = new Person(&#x27;Nick&#x27;, 29, &#x27;Engineer&#x27;);friend.sayName(); 这里只会在sayName()方法不存在的情况下，才会将它添加到原型中。"},{"title":"31天JavaScript学习-第6天","path":"2022/02/25/4c1c50ebb310/","text":"day06-浅拷贝与深拷贝 由于引用类型变量名存在栈内存中，值存在堆内存中，因此深拷贝只针对较为复杂的object类型数据。 浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用 深拷贝：拷贝多层数据，每一层级的数据都会拷贝 浅拷贝的实现方法for in（繁琐）12345678910111213141516171819var obj1 = &#123; name: &#x27;jack&#x27;, age: 28, info: &#123; desc: &#x27;nice&#x27; &#125;&#125;;const obj2 = &#123;&#125;;for (let key in obj1) &#123; obj2[key] = obj1[key];&#125;console.log(&#x27;obj2:&#x27; + JSON.stringify(obj2));obj1.age = 30;console.log(&#x27;obj2:&#x27; + JSON.stringify(obj2.age)); // obj2:28 修改了obj1的第一层属性，obj2没有随之更改obj1.info.desc = &#x27;good&#x27;;console.log(&#x27;obj2:&#x27; + JSON.stringify(obj2.info.desc)); // obj2:&quot;good&quot; 修改了obj1的info.desc属性，obj2也随之更改，说明obj2对obj1的info复制是复制了其引用地址 上方代码中，用 for in 做拷贝时，只能做到浅拷贝。也就是说，在 obj2 中， name 和 age 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系。但是，obj2.info 属性，跟 obj1.info属性，它俩指向的是同一个堆内存地址。所以，当我修改 obj1.info 里的值之后，obj2.info的值也会被修改。 Object.assgin()（推荐）ES6提供了新的语法糖，通过Object.assgin()可以快速实现浅拷贝。将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被覆盖。 12345// 语法1obj2 = Object.assgin(obj2, obj1);// 语法2Object.assign(目标对象, 源对象1, 源对象2...); 如 1234567891011121314151617181920212223242526var myObj = &#123; name: &#x27;jack&#x27;, age: 28, info: &#123; desc: &#x27;nice&#x27; &#125;&#125;;// 写法1const obj1 = &#123;&#125;;Object.assign(obj1, myObj);// 写法2const obj2 = Object.assign(&#123;&#125;, myObj);// 写法3const obj31 = &#123;&#125;;const obj32 = Object.assign(obj31, myObj);// 将myObj、myObj2内容赋值给obj4let myObj2 = &#123; city: &#x27;xiamen&#x27;, age: 32&#125;const obj4 = Object.assign(&#123;&#125;, myObj, myObj2); 深拷贝的实现方式for in递归实现1234567891011121314151617181920212223242526272829303132var obj1 = &#123; name: &#x27;jack&#x27;, age: 28, info: &#123; desc: &#x27;nice&#x27; &#125;&#125;;var obj2 = &#123;&#125;;function deepCopy(newObj, oldObj) &#123; for (let key in oldObj) &#123; // 获取属性值 let item = oldObj[key] // 判断这个属性值是否是数组 if (item instanceof Array) &#123; newObj[key] = []; deepCopy(newObj[key], item); &#125; else if (item instanceof Object) &#123; // 判断这个属性值是否为对象 newObj[key] = &#123;&#125;; deepCopy(newObj[key], item); &#125; else &#123; // 简单数据类型，直接赋值 newObj[key] = item; &#125; &#125;&#125;deepCopy(obj2, obj1);console.log(obj2);obj1.info.desc = &#x27;github&#x27;;console.log(obj2);"},{"title":"31天JavaScript学习-第5天","path":"2022/02/24/31bea9e5840f/","text":"内置引用类型（三）——基本包装类型和单体内置对象 基本包装类型我们都知道，js 中的数据类型包括以下几种。 基本数据类型：String、Number、Boolean、Null、Undefined 引用数据类型：Object 为了便于操作基本类型值，ES提供了三个特殊的引用类型。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象。 String()：将基本数据类型字符串，转换为 String 对象。 Number()：将基本数据类型的数字，转换为 Number 对象。 Boolean()：将基本数据类型的布尔值，转换为 Boolean 对象。 通过上面这这三个包装类，我们可以将基本数据类型的数据转换为对象。 基本包装类型的作用 当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将基本数据类型转换为引用数据类型，这样的话，基本数据类型就有了属性和方法，然后再调用对象的属性和方法；调用完以后，再将其转换为基本数据类型。 12var s1 = &#x27;some text&#x27;;var s2 = s1.substring(2); s1包含一个字符串，字符串是基本类型值，但第二行调用了s1的substring()方法。基本类型值不是对象，理应没有方法。其实该操作包含以下三个步骤： 创建String类型的一个实例；var s1 = new String(&#39;some text&#39;); 在实例上调用指定的方法；var s2 = s1.substring(2); 销毁这个实例；s1 = null; 单体内置对象GlobalGlobal（全局）对象不属于任何其他对象的属性和方法，所有的对象都是它的属性和方法。事实上，没有全局变量和全局函数，所有在全局作用域定义的属性和函数，都是Global对象的属性；某些函数如isNan()、parseInt()以及parseFloat()，实际上都是Global对象的方法。 MathMath 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是直接使用里面的属性和方法即可。 Math属于一个工具类，里面封装了数学运算相关的属性和方法。如下： 属性 描述 备注 Math.E 自然对数的底数，即常量e的值 Math.LN10 10的自然对数 Math.LN2 2的自然对数 Math.LOG2E 以2为底e的对数 Math.LOG10E 以10为底e的对数 Math.PI π的值 Math.SQRT1_2 1&#x2F;2的平方根 Math.SQRT2 2的平方根 方法 描述 备注 Math.PI 圆周率 Math对象的属性 Math.abs() 返回绝对值 Math.random() 生成0-1之间的随机浮点数 取值范围是 [0，1) Math.floor() 向下取整（往小取值） Math.ceil() 向上取整（往大取值） Math.round() 四舍五入取整（正数四舍五入，负数五舍六入） Math.max(x, y, z) 返回多个数中的最大值 Math.min(x, y, z) 返回多个数中的最小值 Math.pow(x,y) 乘方：返回 x 的 y 次幂 Math.sqrt() 开方：对一个数进行开方运算"},{"title":"31天JavaScript学习-第4天","path":"2022/02/23/fa36082f52b1/","text":"内置引用类型（二）——Function、RegExp Function函数的特点： 函数是一个对象，每个函数都是Function类型的实例 函数名是一个指向函数对象的指针 函数的定义&#x2F;声明方式一：函数关键字 123function sum (a, b) &#123; return a + b;&#125; 在使用函数关键字进行函数声明时，会有函数声明提升的过程。 方式二：函数表达式（匿名函数） 123var sum = function(a, b) &#123; return a + b;&#125;; 方式三：构造函数 1var sum = new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a + b;&#x27;); 注意，Function里的参数都必须是字符串形式。 函数内部属性内部对象函数内部有两个特殊的对象：arguments和this。 argumentsarguments是一个类数组对象（伪数组），包含传入函数中的所有参数，可以通过索引来操作数据，也可以获取长度。arguments代表的是实参，arguments只在函数中使用。 1、arguments.length arguments.length可以用来获取实参的长度。 2、arguments.callee arguments有一个名为callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。 在使用函数递归调用时，推荐使用 arguments.callee 代替函数名本身。如阶乘函数： 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125; 该函数的执行与函数名factorial紧紧耦合在了一起，为了消除耦合可以使用下面的写法： 1234567function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125; this根据函数的调用方式的不同，this 会指向不同的对象： 以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window。比如fun();相当于window.fun(); 以方法的形式调用时，this 指向调用方法的那个对象 以构造函数的形式调用时，this 指向实例对象 以事件绑定函数的形式调用时，this 指向绑定事件的对象 使用 call 和 apply 调用时，this 指向指定的那个对象 ES6的箭头函数并不遵守上面的准则，而是会继承外层函数调用的this绑定。 JS专门提供了一些方法来改变函数内部的this指向，call()、apply()、bind()。 内部属性callercaller保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，则它的值为null。 函数的属性和方法ES中的函数时对象，因此函数也有属性和方法。 属性：length、prototype 方法：apply()、call()、bind() 属性lengthlength属性表示函数希望接收的命名参数的个数。 prototype对于ES的引用类型，prototype是保存它们所有实例方法的真正所在。诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。详细见。 方法call()方法可以调用一个函数，实际上等于设置函数体内this对象的值。 fn1.call(this指向的作用域, 函数实参1, 函数实参2……); 第一个参数中，如果不需要改变 this 指向，则传 null。 call() 方法的另一个应用：可以实现继承。之所以能实现继承，其实是利用了上面的作用。 123456789101112function Father(myName, myAge) &#123; this.name = myName; this.age = myAge;&#125;function Son(myName, myAge) &#123; // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承 Father.call(this, myName, myAge);&#125;const son1 = new Son(&#x27;jack&#x27;, 16);console.log(JSON.stringify(son1)); // &#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:16&#125; apply()方法可以调用一个函数，实际上等于设置函数体内this对象的值。 apply()接收两个参数： fn1.apply(this指向的作用域, [参数数组]); 其中第二个参数可以是Array的实例，也可以是arguments对象。 apply() 方法的巧妙应用：求数组的最大值 我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？ 虽然数组里没有获取最大值的方法，但是数值里面有 Math.max(数字1，数字2，数字3) 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。 12345678const arr1 = [3, 7, 10, 8];// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。const maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值console.log(maxValue);const minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值console.log(minValue); bind()方法bind()会创建一个函数的实例，其this值会被绑定到传给bind()函数的值， new_func = fn1.bind(this指向的作用域, 函数实参1, 函数实参2……); 如： 123456789window.color = &#x27;red&#x27;;var o = &#123; color: &#x27;blue&#x27; &#125;;function sayColor()&#123; console.log(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); // blue RegExpES通过RegExp类型来支持正则表达式。 var expression = / pattern / flags; 其中模式（pattern）可以是任意正则表达式。每个正则表达式都可以带有一个或多个标志（flags），匹配模式支持下列三种模式： g：全局（global）模式。模式应用于所有字符串，发现第一个匹配项停止。 i：不区分大小写。 m：多行模式，到达一行文本末尾还会继续查找下一行。 实例属性RegExp的每个实例都具有下列属性。 属性 数据类型 解释 global boolean 是否设置g标志 ignoreCase boolean 是否设置i标志 lastIndex 整数 开始搜索下一个匹配项的字符位置，从0开始 multiline boolean 是否设置m标志 source String 正则表达式的字符串形式"},{"title":"31天Javascript学习-第3天","path":"2022/02/22/f2c42b0b69b1/","text":"内置引用类型（一）——Object、Array、Date ES中引用类型是一种数据结构，有时也称为对象定义。ES对内置对象（引用类型的值）的定义是：由ES实现提供的、不依赖于宿主环境的对象，这些对象在ES程序执行前就已经存在了。 类似的： 引用类型 类 引用类型的值 对象 对象是某个特定引用类型的实例，ES提供很多原生引用类型以方便开发使用。 Object大多引用类型值都是Object类型的实例。创建Object实例方式有两种： new操作符后跟Object构造函数 对象字面量 访问对象属性有两种方法： 点表示法 person.name 方括号表示法 person[&quot;name&quot;] ArrayES的数组的每一项可以保存任意类型的数据。创建数据有两种方式： 使用字面量 var arr1 = [1, 2]; 使用构造函数 let arr = new Array(args); 如果参数为空，则表示创建一个空数组；如果参数为数值，则表示数组的长度；如果有多个参数，表示数组中的元素。 稀疏数组与密集数组 稀疏数组：索引不连续、数组长度大于元素个数的数组，可以简单理解为有 empty（有空隙）的数组。 密集数组：索引连续、数组长度等于元素个数的数组。 数组的项数保存在其length属性中，该属性不是只读的，因此可以人为修改该属性。 如果修改的 length 大于原长度，则多出部分会空出来，置为 undefined。 如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素。 123456let arr = new Array(5);// 等价于let arr = [];arr.length = 5;// 此时返回一个length的值等于5的数组对象，但数组并不包含任何实际的元素，不能理解成包含5个值为undefined的元素console.log(arr); // [ &lt;5 empty items&gt; ] empty和undefined从上面的例子可以看出，使用new Array(len)创建的数组，输出是一个包含len个empty元素的数组。empty并不是JS的基础数据类型之一，但它到底是什么呢？ 1console.log(arr[0]); // undefined 当访问empty元素时，输出了undefined，empty和undefined是等价的？ 1234567891011121314let arr = new Array(4);let arr_undefined = [undefined, undefined];console.log(arr); // [ &lt;4 empty items&gt; ]console.log(arr_undefined); // [ undefined, undefined ]console.log(arr[0]); // undefinedconsole.log(arr_undefined[0]); // undefinedconsole.log(arr[0] == arr_undefined[0]); // trueconsole.log(arr[0] === arr_undefined[0]); // truearr.forEach(item =&gt; &#123;console.log(item);&#125;) //undefinedarr_undefined.forEach(item =&gt; &#123;console.log(item);&#125;) // undefinedconsole.log(arr.hasOwnProperty(0)); // falseconsole.log(arr_undefined.hasOwnProperty(0)); // true 可以看到，只有在访问具体单个元素的时候，empty和undefined才表现一致，其余情况并不相同。 empty是v8引擎对一个空的对象引用的描述，但JS中不存在这种基本类型，因此使用undefined表示。 在用for循环对empty数组遍历，会将empty转换为undefined，而forEach()会自动忽略empty。 数组的常见方法检测方法 方法 描述 备注 Array.isArray() 判断是否为数组 转换方法 方法 描述 备注 toString() 将数组转换为字符串 创建字符串会调用数组中每一项的toString()方法 valueOf() 返回数组本身 toLocaleString() 将数组转换为字符串 创建字符串会调用数组中每一项的toLocaleString()方法 栈方法 方法 描述 备注 push() 向数组末尾插入一个或多个元素，返回修改后数组的长度 pop() 从数组末尾移除一个元素，返回修改后数组的长度 队列方法 方法 描述 备注 unshift() 向数组头部插入一个或多个元素，返回修改后数组的长度 shift() 从数组头部移除一个元素，返回修改后数组的长度 重排序方法 方法 描述 备注 reverse() 对数组反转 sort() 按升序排列数组项，按照Unicode编码，对每个数组项调用toString() 如果在使用sort()方法不带参，默认按照Unicode编码，对数组元素从小到大排序。 12let arr = [1, 2, 3, 5, 10, 11];console.log(arr.sort()); // [ 1, 10, 11, 2, 3, 5 ] 可以看到，数字11排在了2的前面，因为sort()方法是按照Unicode编码进行排序的。 sort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。 浏览器会根据回调函数的返回值来决定元素的排序： 如果返回一个大于 0 的值，则元素会交换位置 如果返回一个小于 0 的值，则元素位置不变 如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置 下面是一个简单的比较函数： 12345678910111213let arr = [1, 2, 3, 5, 10, 11];function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0 &#125;&#125;console.log(arr.sort(compare)); // [ 1, 2, 3, 5, 10, 11 ] 更简化的写法： 1234567let arr = [1, 2, 3, 5, 10, 11];let result = arr.sort(function (a, b)&#123; return a - b; // 升序&#125;);console.log(result); // [ 1, 2, 3, 5, 10, 11 ] 或箭头函数（推荐）： 12345let arr = [1, 2, 3, 5, 10, 11];let result = arr.sort((a, b) =&gt; a - b);console.log(result); // [ 1, 2, 3, 5, 10, 11 ] 操作方法 方法 描述 备注 concat() 合并数组，返回一个新的数组 不会改变原数组 slice() 从数组中提取指定的一个或多个元素，返回结果为新的数组 不会改变原数组 splice() 从数组中删除指定的一个或多个元素，返回结果为被删除元素组成的新数组 会改变原数组 splice()有三种使用方法： 删除：传入两参。起始位置，删除的项数 插入：传入三个或三个以上的参数。起始位置，0，插入的元素 替换：传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素 位置方法 方法 描述 备注 indexOf() 从前往后索引，检索一个数组中是否含有指定的元素 lastIndexOf() 从后往前索引，检索一个数组中是否含有指定的元素 迭代方法 方法 描述 备注 every() 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true filter() 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为新的数组 不会改变原数组 forEach() 和 for 循环类似，但需要兼容 IE8 以上 forEach() 没有返回值。也就是说，它的返回值是 undefined map() 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为新的数组 不会改变原数组 some() 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true 一真即真。只要有一项返回 true，最终的结果就返回 true 归并方法 方法 描述 备注 reduce() 接收一个函数作为累加器，返回值是回调函数累计处理的结果 reduceRight() 接收一个函数作为累加器，返回值是回调函数累计处理的结果，方向相反 reduce()函数接收4个参数：前一个值，当前值，项的索引和数组对象。常见可用于数组求和等： 1234567let arr = [1, 2, 3, 5, 10, 11];let result = arr.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);console.log(result); // 32 Date创建Date对象var now = new Date() 在调用构造函数而不传递参数的情况下，自动获得当前日期和时间。若想根据特定的日期和时间创建Date对象，则需传入该日期的毫秒数（即UTC时间1970年1月1日00:00:00）。为简化该计算过程，ES提供两个方法：Date.parse()，Date.UTC()。 实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()"},{"title":"英文文献常用语句积累","path":"2022/02/22/c684d9d58908/","text":"在阅读文献的同时积累一些常用的句式和用词 词句 译文 in practice 在实践中；实际上，事实上 architecture 结构；体系结构，架构；建筑设计，建筑风格 crucial 重要的；决定性的；定局的；决断的； a,b,c and d, respectively 分别地，依次地 arbitrary 任意的，随心所欲的； coarse-to-fine 由粗到精 generalization ability 泛化能力 tackle 应付，解决（难题或局面）；（足球等）抢断 lateral connections 横向连接 propagate 传播 gradually 逐步地 semantic information 语义信息 be endowed with 被赋予 undergo 经历"},{"title":"31天Javascript学习-第2天","path":"2022/02/21/0df716c9e206/","text":"变量作用域和内存问题 变量JS的变量有两种不同的数据类型的值：基本类型值和引用类型值。 基本数据类型： 基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。 引用数据类型： 对象是保存到堆内存中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间；而变量保存了对象的内存地址（对象的引用），保存在栈内存当中。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。 JS 中，所有的变量都是保存在栈内存中的。 其最大区别是在参数传值： 基本数据类型：传数值 引用数据类型：传地址 JS中所有函数的参数都是按值传递的。 作用域JS中，一共两种作用域（ES5），为了减少命名冲突 全局作用域：作用于整个script标签内部或JS文件中， 函数作用域（局部作用域） window对象全局作用域在页面打开时创建，在页面关闭时销毁。全局作用域中有一个全局对象window，代表浏览器的窗口。 创建的变量都会作为window对象的属性保存。如全局作用域中的var a = 100，这里a等价于window.a。 创建的函数都会作为window对象的方法保存。 作用域链代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。其为了保证对执行环境有权访问的所有变量和函数的有序访问。 其规则是：在内部作用域中可以访问到外部作用域的变量，反之无法访问。 当函数作用域操作一个变量时，遵循就近原则，先在自身作用域中寻找，找不到再向上一级作用域中查找。 变量声明提前（变量提升）使用var关键字声明的变量，会在所有代码执行之前被声明，但不会赋值。若声明变量不是使用var关键字，则不会提前声明。 例： 123console.log(a);var a = 123; // undefined 变量a被提前声明了，但没有赋值，所以为undefined。 函数声明提前使用函数声明的形式创建的函数，会被声明提前。 函数声明：function foo()&#123;&#125; 使用函数表达式创建的函数，不会被声明提前。 函数表达式：var foo = function()&#123;&#125;; 函数作用域中的声明提前在函数作用域中，也有声明提前的特性。 没有块级作用域(ES5)JS没有块级作用域，即由&#123;&#125;包裹起来的代码中的变量，只能在该块的内部使用。 内存问题JS具有自动垃圾收集机制，常用有两种垃圾收集方式： 标记清除 引用计数"},{"title":"31天Javascript学习-第1天","path":"2022/02/19/5dd5127c911b/","text":"day01-JS的基本语法和数据类型 Javascript的特点解释性语言解释型语言的意思是：程序执行之前，不需要事先被翻译为机器码；而是在运行时，边翻译边执行（翻译一行，执行一行）。 单线程Javascript作为浏览器脚本语言，主要用途是与用户互动、操作DOM等，这决定了它只能是单线程。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。但js 引擎执行异步代码而不用等待，是因有为有 消息队列和事件循环。 NodeJS是单线程异步非阻塞模式，只有js执行是单线程，I&#x2F;O交给libuv，是其他线程。nodejs真的是单线程吗？ - 小小鸟儿！ - 博客园 (cnblogs.com) Javascript的基本语法HTML对JS的三种引用方式方式1：行内式 1&lt;input type=&quot;button&quot; value=&quot;点我点我&quot; onclick=&quot;alert(&#x27;hello world&#x27;)&quot; /&gt; 方式2：内嵌式 使用&lt;script&gt;元素，只需指定type属性 12345&lt;script type=&quot;text/javascript&quot;&gt; // 在这里写 js 代码 alert(&#x27;hello world&#x27;); console.log(&#x27;hello world&#x27;);&lt;/script&gt; 方式3：外链式 使用&lt;script&gt;元素，需指定src属性 1&lt;script src=&quot;utils.js&quot;&gt;&lt;/script&gt; JS代码写在中，准确来说是在页面标签元素后，body结束标签前。 区分大小写标识符标识符指变量、函数、属性的名字，或者函数的参数。 标识符第一个字符必须是一个字母、下划线或$ 其他字符可以是字母、下划线、$或数字 按照惯例，ECMAScript标识符采用驼峰大小写格式，第一个字母小写，剩下每个单词的首字母大写。 严格模式在js代码顶部添加&quot;use strict&quot;; 变量JS的变量是松散类型的，不需要指定变量类型。如var message;使用var声明的变量作用域为该语句所在的函数内，存在变量提升现象。 ES6新增关键字let。使用let声明的变量作用域为该语句所在的代码块内，不存在变量提升。且let不允许在相同的作用域内，重复声明同一个变量。 数据类型共有5种简单数据类型：Undefined、Null、Boolean、Number、String 1种复杂数据类型Object，Object本质由一组无序的键值对组成的。 typeof操作符使用typeof操作符可返回变量的数据类型 注意：typeof是一个操作符而不是函数，因此可以使用圆括号也可以不使用 简单（基本）数据类型UndefinedUndefined类型只有一个值，即特殊的undefined。 对未初始化的变量执行typeof会返回undefined，而对未声明的变量执行typeof同样返回undefined 123var message;alert(typeof message); // &#x27;undefined&#x27;alert(typeof age); // &#x27;undefined&#x27; 因此，保持变量显式的初始化是一个良好的编码习惯。 NullNull类型只有一个值，即特殊的null。null值表示一个空对象指针，正因此使用typeof检测null值时会返回’object’类型。 如果定义的变量在将来用于保存对象，最好将该变量初始化为null。实际上，undefined值是派生自null值的，因此null == undefined返回值是true。 BooleanBoolean类型有两个值，true和false。各种数据类型与Boolean类型的转换如下 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和Nan Object 任何对象 null Undefined n&#x2F;a(N&#x2F;A) undefined NumberNumber类型用来表示整数和浮点数值。 整数除十进制外，整数还可以以八进制和十六进制的字面值来表示 1234var octalNum1 = 070; // 八进制56var octalNum2 = 079; // 无效的八进制，解析为79var hexNum1 = 0xA; // 十六进制的10var hexNum2 = 0x2f; // 十六进制的31 浮点数JS浮点数值的最高精度是17位小数。 JS会将某些浮点数值转换为整数值，如1.0，1.。 对于极大极小值，可以用e表示法，如 1var floatNum = 3.124e7; NanNan（Not a Number）是一个特殊的数值。 任何涉及Nan的操作都会返回Nan Nan和任何值都不相等 数值转换Number()、parseInt()、parseFloat() StringJS的字符串是不可变的，字符串一旦创建，值不能改变。 数值、布尔值、对象和字符串值有toString()方法，null、undefined值没有这个方法。 也可使使用转型函数String()。 ObjectJS中的对象是一组数据和功能的集合。 var o = new Object(); Object的每个实例有下列属性和方法： constructor：保存着用于创建当前对象的函数 hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。 isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。 toString()：返回对象的字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示。 操作符一组用于操作数据值的操作符，包括算术操作符、位操作符、关系操作符和相等操作符。 一元操作符一元操作符只能操作一个值。 递增递减操作符 ++ – 一元加和减操作符 + - 位操作符 按位非 ~ 按位与 &amp; 按位或 | 按位异或 ^ 左移 &lt;&lt; 有符号的右移 &gt;&gt; 无符号的右移 &gt;&gt;&gt; 布尔操作符 逻辑非 ! 逻辑与 &amp;&amp; 逻辑或 || 乘性操作符 * &#x2F; 加性操作符 + - 关系操作符 &lt; &gt; &lt;&#x3D; &gt;&#x3D; 相等操作符 相等和不相等 == != 全等和不全等 === !== 条件操作符 expression ? true : false 赋值操作符 &#x3D;"},{"title":"linux关于压缩命令","path":"2022/02/19/09d40526db65/","text":"Linux的压缩一直没有弄清楚，在这里系统整理一遍。 Linux中常用压缩格式linux常见压缩包以tar.xx格式存在，其中tar是一种打包格式，而后面的gz、bz2等才是压缩方式。 tar.gz压缩：tar -zcvf filename.tar.gz [目标文件] c: create 创建新归档 解压：tar -zxvf filename.tar.gz 其中zxvf含义分别如下 z: gzip 压缩格式 x: extract 解压 v: verbose 详细信息 f: file(file&#x3D;archieve) 文件 tar.bz2压缩：tar -jcvf filename.tar.bz2 [目标文件] 解压：tar -jxvf filename.tar.bz2 j: bzip2 压缩格式 其它选项和tar.gz解压含义相同 tar.xz压缩：tar -Jcvf filename.tar.bz2 [目标文件] 解压：tar -Jxvf filename.tar.xz 注意J大写 tar.Z压缩：tar -Zcvf filename.tar.bz2 [目标文件] 解压：tar -Zxvf filename.tar.xz 注意Z大写 附事实上, 从1.15版本开始tar就可以自动识别压缩的格式,故不需人为区分压缩格式就能正确解压 1234tar -xvf filename.tar.gztar -xvf filename.tar.bz2tar -xvf filename.tar.xztar -xvf filename.tar.Z zipzip包使用zip&#x2F;unzip命令进行处理。 压缩：zip [目标目录] [待压缩目录] 解压：unzip [待解压文件] -d [目标目录]"},{"title":"pip与conda换源","path":"2022/02/14/e12fbaadf62f/","text":"conda与pip换源汇总 condalinux修改~/.condarc 123456channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ssl_verify: true windowswindows用户需先执行conda config --set show_channel_urls yes，生成.condarc文件，再进行修改 pip阿里云 http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/豆瓣(douban) http://pypi.douban.com/simple/清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ linux临时换源： pip后加-i，指定pip源 永久换源： 修改~/.pip/pip.conf 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple windows在user目录新建pip目录，路径为C:\\User\\xx\\pip\\pip.ini 1234[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simpletrusted-host = pypi.tuna.tsinghua.edu.cn"},{"title":"mmdetection的一些小坑","path":"2022/01/23/a04a392a8742/","text":"记录一下使用mmdetection中遇到的一些坑，方便查阅。 安装pip install mmcv-full==1.3.9 -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.9.0/index.html pip install mmcv-full==1.3.9 -f https://download.openmmlab.com/mmcv/dist/cu101/torch1.7.0/index.html 修改完后，需要重新编译（python setup.py install) pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu111/{torch_version}/index.html pip install mmcv-full==1.3.3 -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.8.0/index.html pip install -r requirements/build.txtpython setup.py develop 修改数据集为coco格式目录格式： 12345678910mmdetection├── mmdet├── tools├── configs├── data│ ├── coco│ │ ├── annotations│ │ ├── train2017│ │ ├── val2017│ │ ├── test2017 修改相关文件： (4条消息) mmdetection自定义数据集进行训练_xiangxianghehe的博客-CSDN博客_mmdetection 训练数据集 常用命令测试与训练python tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py checkpoints/epoch_2.pth –show python tools/train.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py python tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py checkpoints/{model}/latest.pth –out results/{model}/results.pkl –show-dir results/ 1python tools/test.py configs/fcos/fcos_r50_caffe_fpn_gn-head_1x_coco.py checkpoints/latest.pth --out results/fcos_r50_caffe_fpn_gn-head_1x_coco/results.pkl --show-dir results/ train参数This tool accepts several optional arguments, including: --no-validate (not suggested): Disable evaluation during training. --work-dir $&#123;WORK_DIR&#125;: Override the working directory. --resume-from $&#123;CHECKPOINT_FILE&#125;: Resume from a previous checkpoint file. --options &#39;Key=value&#39;: Overrides other settings in the used config. 查看configpython tools/misc/print_config.py configs/zr/zr_fcos_r50_caffe_fpn_gn-head_1x_coco.py 学习率配置X：我的一个batchsize输入图像数量Y：mmdetction一个batchsize输入图像数量Z：默认学习率 新的学习率= （X/Y）x Z如：X：1GPU+2img/GPU=2张MMdet默认是8GPU*2img/GPU=16张MMdet默认学习率=0.02新的学习率=0.0025 为了克服数据量多的问题，我们会选择将数据分成几个部分，即batch，进行训练，从而使得每个批次的数据量是可以负载的。将这些batch的数据逐一送入计算训练，更新神经网络的权值，使得网络收敛。 一个epoch指代所有的数据送入网络中完成一次前向计算及反向传播的过程。由于一个epoch常常太大，计算机无法负荷，我们会将它分成几个较小的batches。 所谓Batch就是每次送入网络中训练的一部分数据，而Batch Size就是每个batch中训练样本的数量 所谓iterations就是完成一次epoch所需的batch个数。 简单一句话说就是，我们有2000个数据，分成4个batch，那么batch size就是500。运行所有的数据进行训练，完成1个epoch，需要进行4次iterations。 TOOLSLog Analysistools/analysis_tools/analyze_logs.py plots loss/mAP curves given a training log file. Run pip install seaborn first to install the dependency. 1python tools/analysis_tools/analyze_logs.py plot_curve [--keys $&#123;KEYS&#125;] [--title $&#123;TITLE&#125;] [--legend $&#123;LEGEND&#125;] [--backend $&#123;BACKEND&#125;] [--style $&#123;STYLE&#125;] [--out $&#123;OUT_FILE&#125;] ```python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json –keys loss_cls –legend loss_cls123- ``` python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json --keys bbox_mAP --legend bbox_mAP Result Analysistools/analysis_tools/analyze_results.py calculates single image mAP and saves or shows the topk images with the highest and lowest scores based on prediction results. Usage: 123456789python tools/analysis_tools/analyze_results.py \\ $&#123;CONFIG&#125; \\ $&#123;PREDICTION_PATH&#125; \\ $&#123;SHOW_DIR&#125; \\ [--show] \\ [--wait-time $&#123;WAIT_TIME&#125;] \\ [--topk $&#123;TOPK&#125;] \\ [--show-score-thr $&#123;SHOW_SCORE_THR&#125;] \\ [--cfg-options $&#123;CFG_OPTIONS&#125;] Description of all arguments: config : The path of a model config file. prediction_path: Output result file in pickle format from tools/test.py show_dir: Directory where painted GT and detection images will be saved --show：Determines whether to show painted images, If not specified, it will be set to False --wait-time: The interval of show (s), 0 is block --topk: The number of saved images that have the highest and lowest topk scores after sorting. If not specified, it will be set to 20. --show-score-thr: Show score threshold. If not specified, it will be set to 0. --cfg-options: If specified, the key-value pair optional cfg will be merged into config file Examples: Assume that you have got result file in pickle format from tools/test.py in the path ‘./result.pkl’. Test Faster R-CNN and visualize the results, save images to the directory results/ 1python tools/analysis_tools/analyze_results.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl results --show Test Faster R-CNN and specified topk to 50, save images to the directory results/ 12345python tools/analysis_tools/analyze_results.py \\ configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\ result.pkl \\ results \\ --topk 50 If you want to filter the low score prediction results, you can specify the show-score-thr parameter 12345python tools/analysis_tools/analyze_results.py \\ configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\ result.pkl \\ results \\ --show-score-thr 0.3 1python tools/analysis_tools/eval_metric.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl"},{"title":"博客施工记录","path":"2022/01/18/ebc99e4d4103/","text":"记录一下hexo的施工过程。主要参考K大的这篇基于 Hexo 的全自动博客构建部署系统 ，我再稍微补充一些自己遇到的坑。 施工进度 smms上传限制5M图片，如果图片大于5M需要对图片进行压缩 action缓存，构建加速 dns负载均衡（暂时没有第二个服务器） 评论模块 归档页 新建文章在hexo根目录下，终端输入hexo new [layout] [title] Layout Path post (default) source&#x2F;_posts draft source&#x2F;_drafts page source 草稿发布hexo publish [title] md图床问题Markdown使用图床很方便，我现在用的图床是SMMS，暂时没多大问题，但前期做好备份还是有备无患。因此，最好的解决方案是先将图片保存到本地目录，写完push至github后，结合Action自动读取md源文件，并将图片链接转换为图床链接，再完成hexo渲染。 python转换代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import argparseimport osimport argparseimport reimport requestsimport jsondef smms_upload(img): # 判断图片是否大于5M with open(img, &#x27;rb&#x27;) as img_file: if os.path.getsize(img) &lt; 5 * 1024 * 1024: try: smms_url = &#x27;https://sm.ms/api/v2/upload&#x27; response = requests.post( smms_url, files=&#123;&#x27;smfile&#x27;: img_file, &#x27;format&#x27;: &#x27;json&#x27;&#125;, headers=&#123;&#x27;Authorization&#x27;: smms_token&#125; ) print(&quot;upload finish&quot;) img_new_url = json.loads(response.text) cloud_path = img_new_url[&#x27;data&#x27;][&#x27;url&#x27;] return cloud_path except BaseException as err: print(f&quot;error in upload to smms:&#123;err&#125;&quot;) else: print(&#x27;err in upload, image size is more than 5M&#x27;) return Nonedef convert2url(file_path): with open(file_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: lines = f.readlines() outs = [] for line in lines: if re.search(&#x27;\\!\\[.*\\)&#x27;, line) is not None: images_offline = re.findall(&#x27;\\!\\[.*\\)&#x27;, line) # 找到每段中所有的图片本地链接 for item in images_offline: # 对每个链接进行替换 img_path = re.search(&#x27;(?&lt;=\\()(.+?)(?=\\))&#x27;, item).group() # 判断图片路径是否为网络路径 if re.search(&#x27;[a-zA-z]+://[^\\s]*&#x27;, img_path) is None: img_file = os.path.join(path_md, img_path) images_online = smms_upload(img_file) if images_online is not None: line = line.replace(img_path, images_online) outs.append(line) else: outs.append(line) with open(file_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.writelines(outs)if __name__ == &quot;__main__&quot;: ap = argparse.ArgumentParser() ap.add_argument(&quot;-p&quot;, &quot;--path&quot;, help=&quot;the path of your post file&quot;) ap.add_argument(&quot;-t&quot;, &quot;--token&quot;, help=&quot;the token of your smms count&quot;) args = ap.parse_args() path_md = args.path smms_token = args.token md_list = os.listdir(path_md) md_list = [item for item in md_list if item.endswith(&#x27;md&#x27;)] for item in md_list: file_path = os.path.join(path_md, item) convert2url(file_path) Github Action自动部署每次部署在本地hexo g -d，只是在本地构建文件再提交，github只充当了一个静态服务器的作用，没有起到git的作用，因此使用Github Action可以实现自动化部署，且可以实现图床链接的替换。 在.github目录下新建文件夹.workflows，再新建文件deployment.yml，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950name: Hexo Auto-Deployon: [push]jobs: repalce_image: name: md images replace runs-on: ubuntu-latest steps: - name: 1. git checkout uses: actions/checkout@v2.4.0 - name: 2. setup python uses: actions/setup-python@v2.3.1 with: python-version: &quot;3.8.x&quot; architecture: &quot;x64&quot; - name: 3. setup and run run: | pip install requests sudo apt install tree tree source/ python convert_img2url.py -p source/_posts -t &quot;$&#123;&#123; secrets.SMMS_TOKEN &#125;&#125;&quot; - name: 4. install hexo... run: | npm install hexo-cli -g npm install npm list --depth 0 - name: 5. hexo generate run: | hexo clean hexo g - name: 6. hexo deploy ... run: | mkdir -p ~/.ssh/ echo &quot;$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name &quot;zrtty1998&quot; git config --global user.email &quot;zrtty1998@gmail.com&quot; git config --global core.quotepath false hexo d 负载均衡HTTP重定向HTTP重定向通过一台服务器根据用户的HTTP请求计算出真实服务器地址，将该地址返回到重定向响应中返回给用户。这种负载均衡方案较简单，缺点如下： 浏览器需两次请求才能完成一次访问 重定向服务器本身可能会成为瓶颈 HTTP返回码302重定向，可能使搜索引擎判断SEO作弊 DNS负载均衡DNS负载均衡是使用DNS服务器对同一域名配置多条A记录，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回。其结构类似HTTP负载均衡，只不过将请求步骤交给了DNS服务器。 该方法有如下优点： 负载均衡任务交给DNS服务器，较为方便。 部署在服务器上的应用不需要任何配置。 服务器可以位于互联网任何位置。 DNS支持基于地理位置的域名解析，即将根据用户所在地理位置，将域名解析成距离最近的一个服务器地址，加速用户访问。 同时该方案也存在如下缺点： DNS是多级解析的，每一级都会缓存该条域名的A记录，更新记录生效需要较长时间。 不能按照服务器的处理能力来分配负载，DNS负载均衡采用的是简单的轮询算法，因此其负载均衡的效果不太好。 为保证DNS数据即时更新，使地址能随机分配，一般需要将DNS刷新时间设置较小，但会导致DNS流量大增造成其他问题。 博客美化代码块美化自带的代码块显示没有高亮，也没有一键复制的功能。因此着手添加这两项功能。 首先注意到hexo已经内部集成了highlight.js和prismjs。"}]