{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-nexmoe/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/css/color.styl","path":"css/color.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/css/dark.styl","path":"css/dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo.css","path":"lib/iconfont/demo.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo_index.html","path":"lib/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.css","path":"lib/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.eot","path":"lib/iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.js","path":"lib/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.json","path":"lib/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.svg","path":"lib/iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.ttf","path":"lib/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff","path":"lib/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff2","path":"lib/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/js/mdui.js","path":"lib/mdui_043tiny/js/mdui.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/css/mdui.css","path":"lib/mdui_043tiny/css/mdui.css","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"b3a6e41cd090c601fa63a42af6c69786bf88351a","modified":1642648288501},{"_id":"source/my_archives.md","hash":"9b2aee8956cbb6aa382a9e745ef6f527394e7b4f","modified":1642912056716},{"_id":"source/favicon.ico","hash":"1e87f018c99fb89c714d46c533fcd85b47ee322b","modified":1650703702140},{"_id":"source/_posts/健身小白的入门.md","hash":"b0d3722d26c0da95378c94832a18017ca7ddcf85","modified":1644826416834},{"_id":"source/custom.css","hash":"bf0dab7edcb0da1090ae6f29744caaad07069408","modified":1643170038856},{"_id":"source/_posts/mmdetection的一些小坑.md","hash":"589d47d3e1efa975686f1c8552ecd476fe11a90a","modified":1644826398106},{"_id":"source/_posts/博客施工记录.md","hash":"c34244360000c35fbb3115f5dea9f2d4ce579f06","modified":1650703085274},{"_id":"source/_posts/博客施工记录/image-20220122110959737.png","hash":"e44ff4643f0f2ab368d5cc7e12516e67839ab465","modified":1642820999760},{"_id":"source/_posts/博客施工记录/image-20220122110435088.png","hash":"5c0edde1d9ccf4b6bed52e976466be119f64adf1","modified":1642820675107},{"_id":"node_modules/hexo-theme-nexmoe/_config.yml","hash":"7d580602ce3cff4ebe0d4c9bb37ab34e68d6947a","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/crowdin.yml","hash":"f9f02a9cab975c7de721c5dc4179b77870019cc6","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/index.js","hash":"3b35a075a534f60e546184fb98d5e7f91daf285c","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/package.json","hash":"2023cdcc96da50c4d44c8519a24c1c74889045ca","modified":1642573510565},{"_id":"node_modules/hexo-theme-nexmoe/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/languages/default.yml","hash":"87a7e349b1b6783d843bb404701aa26f60fd6d3d","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/languages/en.yml","hash":"0a30904261c49e5fdb54c7141001eb48343692e1","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/README.md","hash":"0cb927059bd3289aac807a347da215d30eff061a","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/languages/it.yml","hash":"d50be2d5cbf5edfc0babf9c7e983e2abc0055435","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/languages/ja.yml","hash":"58ba070892fc0273576b99dd08bd0197f078a454","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/languages/ja-JP.yml","hash":"58ba070892fc0273576b99dd08bd0197f078a454","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh-CN.yml","hash":"08782500dd6492ee6e4ab4b46b45b7739951e0a7","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh-HK.yml","hash":"be00dd80d498d2bc98a27d16f7332d85e0660f6b","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh-TW.yml","hash":"be00dd80d498d2bc98a27d16f7332d85e0660f6b","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh.yml","hash":"9b1f6b8e3741d94ad8373912b9cba440c8652ea3","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/move_config.js","hash":"0c9e2c7bd3b6e17ba24be5d75a22f45c05b359a9","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/scripts/index.js","hash":"21ad4d662828fa13764720a2a0263e2f05afd22c","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/archives.ejs","hash":"2395fdfee67880c1c6b4796882c6fda67930f1f7","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/py.ejs","hash":"e52aa91d839a664c2b10c90b45550d2585012858","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/feature_request_en.md","hash":"803f6736473a122ed78867e64681defcd2edd954","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/bug_report_en.md","hash":"557484415c610222b16b58df470c2a768782c4fc","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"d6c77dbb2a3d638d748280fb37dd29375aebe98c","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"843abf5e1d7b06cb1feddd75f7025150d46a91c2","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/analytics.ejs","hash":"e53883f2bb9921cb08437f433d5d4d5cf52ab297","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/index.ejs","hash":"b61b9055799bb343bfea1cc7af243e11f0ec766e","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/comment.ejs","hash":"6e48ae4a79ad9e14d00244c15cd6e9ad04b99eb4","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/layout.ejs","hash":"301629266f49870cbedca8fc0ccc99646e65f5de","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/copyright.ejs","hash":"8ea3e7696217adb58345ec2b1fb83cfb62b4b317","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/paginator.ejs","hash":"4721e51e0ce36a91a3817f2549218f2813f8b204","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/after-footer.ejs","hash":"6da138c6408164bd7247f174fd035619049d5bb1","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/post.ejs","hash":"6cca9331c72fe382196d23e866148b19335b0406","modified":1643176710518},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/archive.ejs","hash":"2438c7647bab143de571bd41224784f097b60653","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/searchbox.ejs","hash":"424c6f805881a8e4761c4b628d9bab5f9f1417cc","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/sidebar.ejs","hash":"18da03e09bee5aa9aa24a1ae6b3e352c38d5e18c","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/site-verification.ejs","hash":"600319729da09e366c05e104fe68a821b087c027","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/link.ejs","hash":"d9104aa53f57a99d59ed1a06b3e1abca93082945","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/recent_posts.ejs","hash":"7d9eaf8228eda803aa4956e55432f78e056d6a01","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/social.ejs","hash":"d0f2a8386de1a08deb431a6fa9a3f4a299d0cd1a","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/tag.ejs","hash":"ddf844f08124454bea2a30f8349b63f3cb63ac16","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/category.ejs","hash":"99113b9f2cb4ffefdda3e3a343647ac6a5083091","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/scripts/helper/image_filter.js","hash":"b1f23e114b722854e0e4493a2b07ad9d1f399259","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/search.ejs","hash":"564b8b6acf2d242ae137416a3c33f2252b000000","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/scripts/helper/css_auto_version.js","hash":"63c90dac6ad0a102ef302bf9fd9e030d521a8232","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/scripts/helper/js_auto_version.js","hash":"98cf6f7edcca3d54ede63556751b1e4f896c7016","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/header.ejs","hash":"34fc02c788c237c13ad2619a7ae3b8b572384860","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/scripts/tag/gallery.js","hash":"a359add30a0106f06cc4bd6b997abc107d751f00","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/tagcloud.ejs","hash":"6636a70e3ed871f2e90550d37b773c951817f143","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/js/search.js","hash":"4d93153b6bd29f363db709f1226fcad6eae680ae","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/js/app.js","hash":"cdbd658532f0880564c61e983be0c5bc06e91b97","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_analytics/cnzz.ejs","hash":"345ed559b76930bed05e1b393c12f09d42c2312e","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_analytics/baidu.ejs","hash":"cc782e1363c8bbb6277c3825bb9eac83762bc26d","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/color.styl","hash":"144a506ebe863499e7fa769c946fdbec821bce3f","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/dark.styl","hash":"a5630003e6b5cf5b083c309a7a7e9ab8eb221a73","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_analytics/google.ejs","hash":"97f3a717495c8cc71d5d3c7ab69ddd589a69a038","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_analytics/gtags.ejs","hash":"2c429eef83e712531a08de370b06f1f00ac7398b","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_analytics/gtm-head.ejs","hash":"5638bed9cfe2e86aeee77adc883b2a3e1ecd76ff","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_analytics/gtm-body.ejs","hash":"1471e3a49ad6c93fd33b18545b43805c48695e23","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_analytics/tencent.ejs","hash":"6f7d514f157fbdb505e52dda2dc4f35dcdb2685e","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_comment/DiscussBot.ejs","hash":"92fb25b5204b325eb18eea0c15ddb4f4116e35e2","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_analytics/la.ejs","hash":"e08b1f111068c62e625b6790e66d8a5f625246ba","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/style.styl","hash":"1914bf3e3b7dc7ad8ce194eb225c3f34edcb165d","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_comment/gitalk.ejs","hash":"a3a33112234fee49646a9c11fcbdf2ed1a7777a8","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_comment/gitment.ejs","hash":"d4a99db9f2daf7bcdbcf637f478d925d5d840fe4","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_comment/disqusjs.ejs","hash":"7518e88f2504b9844f71190e079df07f51847472","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/meta.ejs","hash":"b1e91c394003cffb7f73ecf09162f41543cbf970","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_comment/livere.ejs","hash":"e96e1510ba2a8ccb1edebc378c566fadaed09e50","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_comment/valine.ejs","hash":"97a699da23500cd6b16c857a60d123064d1653f9","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/tag.ejs","hash":"c265ae74f31bb046922a052bb7d5eef4416d1357","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_comment/changyan.ejs","hash":"8a520fd9a9704208c23abcb689bae33acd1167db","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_comment/disqus.ejs","hash":"e1e70a619cf3499ef8b054c8fb4b23865a554b6b","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/archives.styl","hash":"db98414c8c017681bf2e8c85b978a15b5c0eea86","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/py.styl","hash":"830cadb47885d63a407311be3e8c8116a47d904e","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/article.styl","hash":"36065f96a091694ba3502138ac58c5b8b4e50c30","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/searchbox.styl","hash":"48362ece95f68eacab3f61945bf070c03dcc0754","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo_index.html","hash":"a82acbfeabc50a6668ebf6115b5c5c3d308079b6","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo.css","hash":"53456972a11d52af67187fc17999e6665f9f06fe","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.eot","hash":"1d1851c2197382a9b7cd3b3fcdef79a61ad331f6","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.json","hash":"0dd0193f6f400e5da6d3aef89f76c22c79e0f396","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.js","hash":"bac40fc7b766297cbf645849e583e8cd6496b2d2","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.ttf","hash":"b0f4b5501cbcaeaf15dc608359574a29bc4c4265","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.svg","hash":"2af6d26577c3ae2ca126351f0be764cbae9da6ff","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_dark/_partial/article.styl","hash":"bae11ad4e3ef0af145754c0c271d7c59f2551314","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff2","hash":"9209e4f7e45d37e58356e5ede7ea9d6d9e922d77","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.css","hash":"3566d949bdc045cd816be382d180b796e0a78748","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_dark/_comment/gitment.styl","hash":"296e23c580d394d4d65c5b47ec91dde3a2e61fdb","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_dark/_partial/searchbox.styl","hash":"980b69e46739f5bade3f2ee8fc92b671e232ab9f","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_dark/_comment/gitalk.styl","hash":"b8c4671d6fab48ca204b160a00d9aae8ab4ab23d","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff","hash":"e292802913e6c248a17797dc24ecfc0a3473c3cf","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_dark/_comment/valine.styl","hash":"eeaf065d845e56330277b2d1a5b3a4d5c458400e","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/css/mdui.css","hash":"1500b5d27b8ce2e7c543bb6d7205de43059378db","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/js/mdui.js","hash":"1b3f4e4b7d1b944dd2a8ca09cc60614435195c67","modified":499162500000},{"_id":"node_modules/hexo-theme-nexmoe/cover.png","hash":"23d58c5a7f388514246d49f27f1529be3fdbe09d","modified":499162500000},{"_id":"source/_posts/博客施工记录/illust_95296062_20220118_234600.jpg","hash":"dd6a2994f03b42fe2ce78bcf70c22de52f167f0e","modified":1642924696594},{"_id":"source/_posts/pip与conda换源.md","hash":"96def1e029c6a28e2190e02769b17613d5c89368","modified":1647687908505},{"_id":"public/custom.css","hash":"bf0dab7edcb0da1090ae6f29744caaad07069408","modified":1644809125774},{"_id":"public/content.json","hash":"d8c9cff53343dac0c8131f87865044e9362a0a6d","modified":1651058471219},{"_id":"public/archive.html","hash":"3c51884f98dc93cd62759c2af91eac6b0f45c997","modified":1651058471219},{"_id":"public/2022/02/14/e12fbaadf62f/index.html","hash":"2689e0833b6d47c4ecb177a865a98f2aa7aadc8f","modified":1651058471219},{"_id":"public/2022/02/08/cb9e10900f12/index.html","hash":"c5835d62919aee37bbc8cdfac4adc6294b153631","modified":1644826425086},{"_id":"public/archives/index.html","hash":"4621f21d30ab99bb24a60557c0196b1adf3bd068","modified":1651058471219},{"_id":"public/archives/2022/index.html","hash":"fa50b9b527a41fb89af67ab7a7a96d51049f77a7","modified":1651058471219},{"_id":"public/archives/2022/01/index.html","hash":"468720c26d70ac4e933ec30a1388d99dc429c260","modified":1651058471219},{"_id":"public/archives/2022/02/index.html","hash":"e43b91cc64af1c208253895c7192f2c184be0a69","modified":1651058471219},{"_id":"public/tags/健身/index.html","hash":"f1ef388437c7cecddf2eb82ea23c603554546e1c","modified":1644826425086},{"_id":"public/tags/mmdetection/index.html","hash":"0292881f8b4a8cbb26b2e825ee789142c49ef253","modified":1651058471219},{"_id":"public/tags/目标检测/index.html","hash":"2c2760fa5d829934ddd0e3b91354180a65676042","modified":1651058471219},{"_id":"public/tags/hexo/index.html","hash":"264662297fb6a959d0ccfdc304dc77863f4acee8","modified":1651058471219},{"_id":"public/tags/Github-Actions/index.html","hash":"9688d81ca9f85fbbf0d80a9ea3bbd3f56e8a4290","modified":1651058471219},{"_id":"public/tags/blog/index.html","hash":"5b41217d031e16ff6417488890fdd228b94c57b5","modified":1651058471219},{"_id":"public/tags/pip/index.html","hash":"a49ed509c7f8e0b33138c0d03734249ecc158d2a","modified":1651058471219},{"_id":"public/tags/conda/index.html","hash":"2b9fe80a67864f48a37826c8da44d82c8e24d2db","modified":1651058471219},{"_id":"public/categories/健身/index.html","hash":"1c94830bd992497f28d3fd837aee5604ac7c52c4","modified":1644826425086},{"_id":"public/categories/环境搭建/index.html","hash":"5e185ed72876b1935b7eaacf323b5edb072ec57d","modified":1651058471219},{"_id":"public/index.html","hash":"32f60830d3acdd69e100ab7f0e2e5782784e34d2","modified":1651058471219},{"_id":"public/2022/01/23/a04a392a8742/index.html","hash":"22efd880ddb52a0ef08a6078468abc7737ff4cad","modified":1651058471219},{"_id":"public/2022/01/18/ebc99e4d4103/index.html","hash":"07c9781c19d6fb77fd69353f82e7abb193ae4589","modified":1651058471219},{"_id":"public/lib/iconfont/iconfont.eot","hash":"1d1851c2197382a9b7cd3b3fcdef79a61ad331f6","modified":1644809125774},{"_id":"public/lib/iconfont/iconfont.svg","hash":"2af6d26577c3ae2ca126351f0be764cbae9da6ff","modified":1644809125774},{"_id":"public/lib/iconfont/iconfont.ttf","hash":"b0f4b5501cbcaeaf15dc608359574a29bc4c4265","modified":1644809125774},{"_id":"public/lib/iconfont/iconfont.woff","hash":"e292802913e6c248a17797dc24ecfc0a3473c3cf","modified":1644809125774},{"_id":"public/CNAME","hash":"b3a6e41cd090c601fa63a42af6c69786bf88351a","modified":1644809125774},{"_id":"public/lib/iconfont/iconfont.woff2","hash":"9209e4f7e45d37e58356e5ede7ea9d6d9e922d77","modified":1644809125774},{"_id":"public/favicon.ico","hash":"1e87f018c99fb89c714d46c533fcd85b47ee322b","modified":1651058471219},{"_id":"public/js/app.js","hash":"1b4b63d72d796143d93b65e9e230110a314d5de9","modified":1644809125774},{"_id":"public/js/search.js","hash":"718593d468a4c3607dd30878e7fb6ab4b20e62f4","modified":1644809125774},{"_id":"public/css/color.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1644809125774},{"_id":"public/css/dark.css","hash":"83d343b9e2660741eaef704ff048672e79c96b9b","modified":1644809125774},{"_id":"public/lib/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1644809125774},{"_id":"public/lib/iconfont/iconfont.css","hash":"01952f8f10c716cbb463b589a345e46f1b8cc101","modified":1644809125774},{"_id":"public/lib/iconfont/iconfont.json","hash":"8fbdca1d1886c8c6d9bfe1fb105595c65050a175","modified":1644809125774},{"_id":"public/css/style.css","hash":"2cfac51715e7bc07703230480767313311b2dbb0","modified":1644809125774},{"_id":"public/lib/iconfont/demo_index.html","hash":"df3f126af2695d3dd839edcfda49b951b02f701e","modified":1644809125774},{"_id":"public/lib/iconfont/iconfont.js","hash":"bac40fc7b766297cbf645849e583e8cd6496b2d2","modified":1644809125774},{"_id":"public/lib/mdui_043tiny/js/mdui.js","hash":"9feeebf8c11d8ce8549ec94896c630ba2334613c","modified":1644809125774},{"_id":"public/lib/mdui_043tiny/css/mdui.css","hash":"b79ef94d2b11f8ce05ba048f5d74a3bd09f12e4d","modified":1644809125774},{"_id":"source/_posts/31天JavaScript学习-第10天.md","hash":"b8c626fe8c4bdb096114256ea227a1516cfa4d8d","modified":1647687570672},{"_id":"source/_posts/31天JavaScript学习-第11天.md","hash":"936f56b73f1bd15ab07fc794839c69d5cd1809dd","modified":1647687558743},{"_id":"source/_posts/31天JavaScript学习-第12天.md","hash":"1f9a76c3e3bfff7d20751ef53d1ba3a444410a30","modified":1647687537448},{"_id":"source/_posts/31天JavaScript学习-第13天.md","hash":"f5d91af2559d14f02ac8200f6ee238a41c7f261b","modified":1647687503332},{"_id":"source/_posts/31天JavaScript学习-第14天.md","hash":"71ee2315df96075783160ceb94bc015b1c8dc45d","modified":1650725338435},{"_id":"source/_posts/31天JavaScript学习-第15天.md","hash":"668afdfb321a9ec9d6d0c6433e857a0e72a84d12","modified":1646746117171},{"_id":"source/_posts/31天JavaScript学习-第16天.md","hash":"861683f04b5bd8bdcbc8b3b61d4e609ce7d41c31","modified":1647175364027},{"_id":"source/_posts/31天JavaScript学习-第17天.md","hash":"4dcdd2714c4f6b82aa7ee22beca585a78b899395","modified":1647431983460},{"_id":"source/_posts/31天JavaScript学习-第18天.md","hash":"3069de31b3386d27b4afd6b4186a86fca25a9b5f","modified":1650699764870},{"_id":"source/_posts/31天JavaScript学习-第19天.md","hash":"ca098f9b4c3a6c79f8015ed7765ec7dd08908c23","modified":1650984149309},{"_id":"source/_posts/31天JavaScript学习-第20天.md","hash":"410925243907b02b51ee37b752e9d1d8b54aef80","modified":1648208867972},{"_id":"source/_posts/31天JavaScript学习-第21天.md","hash":"9a6d6fb7a53aa202bd43c89ed2e75b7207c74aba","modified":1648281347815},{"_id":"source/_posts/31天JavaScript学习-第22天.md","hash":"aa44911871b4324ea4ff0b34516f306f757b56fc","modified":1648476214718},{"_id":"source/_posts/31天JavaScript学习-第4天.md","hash":"cb5134d320da9e53cadb8e08b89b999267a70264","modified":1647687814626},{"_id":"source/_posts/31天JavaScript学习-第5天.md","hash":"f67482de8445c202609ecfea5d9f0c51a79b408c","modified":1650269677702},{"_id":"source/_posts/31天JavaScript学习-第6天.md","hash":"161837f5fba26bbf4001593cfe905a93a1cffa59","modified":1650985496826},{"_id":"source/_posts/31天JavaScript学习-第7天.md","hash":"f7224b2fb445c0489e8898f6fe4de2f615a0ffb1","modified":1647687670549},{"_id":"source/_posts/31天JavaScript学习-第8天.md","hash":"388625da85b84d7d523d573492af594ac68469d0","modified":1650985045540},{"_id":"source/_posts/31天JavaScript学习-第9天.md","hash":"31dd59b47ac4982b29070d3a238a2726035228d0","modified":1647687603424},{"_id":"source/_posts/31天Javascript学习-第1天.md","hash":"38211c93814887cacee7bc7dacec44beb2ea2d4e","modified":1650267922562},{"_id":"source/_posts/31天Javascript学习-第2天.md","hash":"52bb34c05901fcdec1a2cefe97bcf3bc7890cc30","modified":1647687871503},{"_id":"source/_posts/31天Javascript学习-第3天.md","hash":"e0a2236aeffcf34c55310452b4046d5cfb942f26","modified":1647687852906},{"_id":"source/_posts/linux关于解压命令.md","hash":"cd03676466f04acff62b0cb4618a213de8d11ab5","modified":1645269415626},{"_id":"source/_posts/前端面试汇总.md","hash":"146b9af6e1f3fad197fc26deb6f7cf4485ca4168","modified":1650987092618},{"_id":"source/_posts/英文文献常用语句积累.md","hash":"a93dfefb478dec0d3d7396d2eb8fa24fedf4e88b","modified":1646307805485},{"_id":"source/_posts/31天JavaScript学习-第15天/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png","hash":"e423f731be4d828a239430d1824aed5e02353268","modified":1646745677152},{"_id":"source/_posts/31天JavaScript学习-第7天/image-20220228150429925.png","hash":"807c4ead2d619abc89dcfdc66b0c069125e9151b","modified":1646031869955},{"_id":"source/_posts/前端面试汇总/1460000020610340.png","hash":"db4692a474d69ed9a276f8fc4aa046d96bb0810b","modified":1650634450803},{"_id":"source/_posts/前端面试汇总/1460000020610341.png","hash":"691160645f9684f47d4a60e62ec68fc0c35e73a0","modified":1650634433252},{"_id":"source/_posts/前端面试汇总/70.png","hash":"4d98978e69aedc3210cb1d4b7b2caf6e1b5b7afa","modified":1650635030681},{"_id":"source/_posts/前端面试汇总/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png","hash":"e423f731be4d828a239430d1824aed5e02353268","modified":1650636166017},{"_id":"source/_posts/前端面试汇总/image-20220422203142481.png","hash":"e84263a0f8cc7baed1fb0c365e32531f354089aa","modified":1650633871076},{"_id":"source/_posts/31天JavaScript学习-第7天/SouthEast.png","hash":"0487b398513466a424a21d9eb6f8e1174f7172b2","modified":1646018806275},{"_id":"source/_posts/31天JavaScript学习-第7天/image-20220228150415930.png","hash":"807c4ead2d619abc89dcfdc66b0c069125e9151b","modified":1646031856008},{"_id":"source/_posts/前端面试汇总/image-20220422203626056.png","hash":"9377b843d889fcd3f8dc0abf7a587093a6f0f58c","modified":1650633871076},{"_id":"source/_posts/前端面试汇总/lifecycle.svg","hash":"ec189e5a8e248d027e67177c2f6e7e70c9cc7bec","modified":1650702044918},{"_id":"source/_posts/前端面试汇总/v2-e4815bc5d515f8d6bc4c5c8217c397ee_1440w.jpg","hash":"5d2990698afde18cad97b35b78db3f3b3b662a2d","modified":1650635145405},{"_id":"source/_posts/31天JavaScript学习-第21天/rendering.svg","hash":"a425e60c840b8cfa9d2892d69294a865e765ce79","modified":1648212310526},{"_id":"source/_posts/31天JavaScript学习-第9天/image-20220303154500631.png","hash":"7f7d546095d665531ff53ed437f1954017896e8d","modified":1646293500762},{"_id":"source/_posts/31天JavaScript学习-第8天/image-20220228210259817.png","hash":"f99cedcb03949ae89c51739d41d1a306591a45bd","modified":1646053380143},{"_id":"source/_posts/31天JavaScript学习-第8天/image-20220228211923561.png","hash":"4f260ec998886efb67067bae8db94947f51016fa","modified":1646054363777},{"_id":"source/_posts/前端面试汇总/9e3c68d1b0884d9ca0f8ffc5ee64a28etplv-k3u1fbpfcp-watermark.image","hash":"82efd6196018e4c8a3aca7889de12d43662ad905","modified":1650897738724},{"_id":"public/2022/03/04/705c17f8d6dc/index.html","hash":"f4642aab6ecddf6e8ac221a0a68e3c8053312f32","modified":1651058471219},{"_id":"public/2022/02/22/c684d9d58908/index.html","hash":"1c48fd5fa9c2ef3111a4879a28c4034067ab825e","modified":1651058471219},{"_id":"public/2022/02/19/09d40526db65/index.html","hash":"f6a381fa3eb89b497245a93e2dacd06d4b53e149","modified":1651058471219},{"_id":"public/archives/2022/page/3/index.html","hash":"f90169d0cfba509c44646b42c6581530af4cbb22","modified":1651058471219},{"_id":"public/archives/page/3/index.html","hash":"f95a9a5deadf1169e72c8c56ce6a30b0fe9b1320","modified":1651058471219},{"_id":"public/archives/2022/03/page/2/index.html","hash":"c1ad5a0128e7483575dbb09fb496124b914155a5","modified":1651058471219},{"_id":"public/archives/2022/04/index.html","hash":"89f7e1e5910acf95b95ecaed2b5589e8276ed9bb","modified":1651058471219},{"_id":"public/archives/2022/02/page/2/index.html","hash":"49bdf7fc67abd5517428072a6dfa7d6f8b5779e0","modified":1651058471219},{"_id":"public/tags/nodejs/index.html","hash":"2319bf032b87d89d05fbf35234fde8a25b292607","modified":1651058471219},{"_id":"public/tags/CSS/index.html","hash":"91a092bb86471b0030cde64da84a26b4bca4a9f4","modified":1651058471219},{"_id":"public/tags/linux/index.html","hash":"591ea32d4853864be4c6c707a987976391f6a6fe","modified":1651058471219},{"_id":"public/tags/文献积累/index.html","hash":"76905300cec9ec9b03a5a13f3026a5bf27888647","modified":1651058471219},{"_id":"public/tags/写作/index.html","hash":"d05937e6a51d1db0f897a5de2510ec3d1b8f2b33","modified":1651058471219},{"_id":"public/tags/面试/index.html","hash":"c54f8d3f80af6fb78ed7180c786724c0214a9bb9","modified":1651058471219},{"_id":"public/categories/linux/index.html","hash":"4e7540b1136f374fd247afd92c7f952b182c2a71","modified":1651058471219},{"_id":"public/categories/前端/page/3/index.html","hash":"177ac6afd7d34cd57bceb6ea0cfc370d7f8ed3e5","modified":1651058471219},{"_id":"public/page/3/index.html","hash":"c7c5672e524c0c99290e6fd3ea7e9e3265769feb","modified":1651058471219},{"_id":"public/categories/文章写作/index.html","hash":"3bd7ace5553351e1fb90bf7ad7880b8be29845ff","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/index.html","hash":"1ef31e5ebf4ae50168e38431311e72002a2cd5a9","modified":1651058471219},{"_id":"public/2022/03/26/5e459e0f0ffb/index.html","hash":"8d812f497ebfe19df07b4fc89abd8d385b390662","modified":1651058471219},{"_id":"public/2022/03/25/a475fcf4753b/index.html","hash":"013e4af93239bbdecab7363104bf54719a444152","modified":1651058471219},{"_id":"public/2022/03/19/f7c4a7f73205/index.html","hash":"d13cbe5ce7de07675e59d1fb62ad759737bae079","modified":1651058471219},{"_id":"public/2022/03/20/c85657f1c7ec/index.html","hash":"8f656179be78852884b804eda6c5e018cefa8cdc","modified":1651058471219},{"_id":"public/2022/03/10/6d64816cc903/index.html","hash":"cc8808cda666f706b52f7fc27cc0347cc576ca90","modified":1651058471219},{"_id":"public/2022/03/13/614817e8a0b7/index.html","hash":"94d419cc815bed7b8a84e57bf665aca8762ddb85","modified":1651058471219},{"_id":"public/2022/03/16/247b7d4e52e1/index.html","hash":"dbe89614b25645ae346426091c9ba79734d28ff9","modified":1651058471219},{"_id":"public/2022/03/08/d21dc573f3b7/index.html","hash":"a3efdc4d1551af63b71cb13ebb9f2d1215c42cfc","modified":1651058471219},{"_id":"public/2022/03/07/f23a5dcde0bc/index.html","hash":"c33a58b23b8d24f64fecaa3c9629ab962dc2d140","modified":1651058471219},{"_id":"public/2022/03/06/70af1cdbe9cd/index.html","hash":"344e1164a538a277bba401bd60d5ed6373b0f264","modified":1651058471219},{"_id":"public/2022/03/05/4bd2394aa2c3/index.html","hash":"792334b7fe48dee742b2608db25deee4976b1fb6","modified":1651058471219},{"_id":"public/2022/02/28/7bfb6a04e4f3/index.html","hash":"a8f77a0d076413b85c8b206ded7edb3c2df1ebb2","modified":1651058471219},{"_id":"public/2022/03/03/1ab97e8ff9a4/index.html","hash":"8ecf00096c61a3a9920b27ccb1e54112674ecaac","modified":1651058471219},{"_id":"public/2022/02/26/530fde90e882/index.html","hash":"d4e1a32efdf0ff848bc0e6724c476ea99a87b3c4","modified":1651058471219},{"_id":"public/2022/02/23/fa36082f52b1/index.html","hash":"ca37abd2a6ca4374bc143800e6202418bd6fa387","modified":1651058471219},{"_id":"public/2022/03/02/b4aa5ee2478d/index.html","hash":"a3c7d3ed9a2cb70f94f0c625f95c606504516da8","modified":1651058471219},{"_id":"public/2022/02/25/4c1c50ebb310/index.html","hash":"979956699406a0276e1181f98c86639dbb7c3005","modified":1651058471219},{"_id":"public/2022/02/22/f2c42b0b69b1/index.html","hash":"f7cb04985cc15611dcb0d27e7406f77fc5156d04","modified":1651058471219},{"_id":"public/2022/02/24/31bea9e5840f/index.html","hash":"930a9820fdfa18d1c723eea1a429408f2f31008c","modified":1651058471219},{"_id":"public/2022/02/21/0df716c9e206/index.html","hash":"5e26b11584b05865fdc4e1a8cc37c7f0256a5028","modified":1651058471219},{"_id":"public/2022/02/19/5dd5127c911b/index.html","hash":"59edae53eed69f366ba389fc449490311b255502","modified":1651058471219},{"_id":"public/archives/page/2/index.html","hash":"3c9cfe297d3ffb1ba301c49f54ad1b1520092f99","modified":1651058471219},{"_id":"public/archives/2022/page/2/index.html","hash":"0cddab5c6c9d2edf1fa722e03804aae9f0026340","modified":1651058471219},{"_id":"public/archives/2022/03/index.html","hash":"682ec10e4f09bdd35ba1c7e4f6a57344e769fbbe","modified":1651058471219},{"_id":"public/tags/JavaScript/index.html","hash":"daa4b19eec40e53ed342be57be1a48dc513e22d4","modified":1651058471219},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"7063e316e68162073112c299af222d5534f62706","modified":1651058471219},{"_id":"public/categories/前端/page/2/index.html","hash":"4d933be5282232d2410efe24b734c21c36d3a0b5","modified":1651058471219},{"_id":"public/categories/前端/index.html","hash":"16f5e63b9fbf7d8e65782341b23b1fbd5c3c8f30","modified":1651058471219},{"_id":"public/page/2/index.html","hash":"959f61535a800d3d19df05724b3d976a43ddc343","modified":1651058471219},{"_id":"public/2022/01/18/ebc99e4d4103/image-20220122110959737.png","hash":"e44ff4643f0f2ab368d5cc7e12516e67839ab465","modified":1651058471219},{"_id":"public/2022/01/18/ebc99e4d4103/image-20220122110435088.png","hash":"5c0edde1d9ccf4b6bed52e976466be119f64adf1","modified":1651058471219},{"_id":"public/2022/02/26/530fde90e882/image-20220228150415930.png","hash":"807c4ead2d619abc89dcfdc66b0c069125e9151b","modified":1651058471219},{"_id":"public/2022/02/26/530fde90e882/image-20220228150429925.png","hash":"807c4ead2d619abc89dcfdc66b0c069125e9151b","modified":1651058471219},{"_id":"public/2022/03/08/d21dc573f3b7/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png","hash":"e423f731be4d828a239430d1824aed5e02353268","modified":1651058471219},{"_id":"public/2022/02/26/530fde90e882/SouthEast.png","hash":"0487b398513466a424a21d9eb6f8e1174f7172b2","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/1460000020610340.png","hash":"db4692a474d69ed9a276f8fc4aa046d96bb0810b","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png","hash":"e423f731be4d828a239430d1824aed5e02353268","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/1460000020610341.png","hash":"691160645f9684f47d4a60e62ec68fc0c35e73a0","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/70.png","hash":"4d98978e69aedc3210cb1d4b7b2caf6e1b5b7afa","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/image-20220422203142481.png","hash":"e84263a0f8cc7baed1fb0c365e32531f354089aa","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/image-20220422203626056.png","hash":"9377b843d889fcd3f8dc0abf7a587093a6f0f58c","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/lifecycle.svg","hash":"ec189e5a8e248d027e67177c2f6e7e70c9cc7bec","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/v2-e4815bc5d515f8d6bc4c5c8217c397ee_1440w.jpg","hash":"5d2990698afde18cad97b35b78db3f3b3b662a2d","modified":1651058471219},{"_id":"public/2022/03/25/a475fcf4753b/rendering.svg","hash":"a425e60c840b8cfa9d2892d69294a865e765ce79","modified":1651058471219},{"_id":"public/2022/03/02/b4aa5ee2478d/image-20220303154500631.png","hash":"7f7d546095d665531ff53ed437f1954017896e8d","modified":1651058471219},{"_id":"public/2022/02/28/7bfb6a04e4f3/image-20220228211923561.png","hash":"4f260ec998886efb67067bae8db94947f51016fa","modified":1651058471219},{"_id":"public/2022/02/28/7bfb6a04e4f3/image-20220228210259817.png","hash":"f99cedcb03949ae89c51739d41d1a306591a45bd","modified":1651058471219},{"_id":"public/2022/04/22/7f255ae33214/9e3c68d1b0884d9ca0f8ffc5ee64a28etplv-k3u1fbpfcp-watermark.image","hash":"82efd6196018e4c8a3aca7889de12d43662ad905","modified":1651058471219},{"_id":"public/2022/01/18/ebc99e4d4103/illust_95296062_20220118_234600.jpg","hash":"dd6a2994f03b42fe2ce78bcf70c22de52f167f0e","modified":1651058471219}],"Category":[{"name":"健身","_id":"ckzi2bho80004aswz0o4rc3um"},{"name":"环境搭建","_id":"ckzi2bho90006aswzfa4c21il"},{"name":"前端","_id":"cl2hhl29u00027owzekd1ey0k"},{"name":"linux","_id":"cl2hhl2ag001w7owz2cz5cetm"},{"name":"文章写作","_id":"cl2hhl2aj00257owzb52r6o9o"}],"Data":[],"Page":[{"_content":".nexmoe-post {\n  border-radius: 16px;\n  box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.1);\n}\n\n.nexmoe-post article {\n  padding: 15px;\n}\n\n/* clipboard代码块 */\n\n\n/*\ncode {\n  padding: 1px 5px;\n  font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace;\n  color: #e96900;\n  background-color: #f8f8f8;\n  border-radius: 2px;\n}\n\npre code {\n  padding: 0;\n  color: #e8eaf6;\n  background-color: #272822;\n}\n\npre[class*=\"language-\"] {\n  padding: 1.2em;\n  margin: .5em 0;\n}\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: #e8eaf6;\n  white-space: pre-wrap !important;\n}\n\n.line-numbers-rows {\n  border-right-width: 0px !important;\n}\n\n.line-numbers {\n  padding: 1.5rem 1.5rem 1.5rem 3.2rem !important;\n  margin: 1rem 0 !important;\n  background: #272822;\n  overflow: auto;\n  border-radius: 0.35rem;\n  tab-size: 4;\n}\n\n\npre {\n  padding: 1.5rem !important;\n  margin: 1rem 0 !important;\n  background: #272822;\n  overflow: auto;\n  border-radius: 0.35rem;\n  tab-size: 4;\n}\n\npre::before {\n  content: \"\";\n  height: 16px;\n  margin-bottom: 0;\n  display: block;\n}\n\npre::after {\n  content: \" \";\n  position: absolute;\n  border-radius: 50%;\n  background: #ff5f56;\n  width: 12px;\n  height: 12px;\n  top: 0;\n  left: 12px;\n  margin-top: 12px;\n  -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;\n  box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;\n}\n\ncode {\n  padding: 1px 5px;\n  font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace;\n  font-size: 0.91rem;\n  color: #e96900;\n  background-color: #f8f8f8;\n  border-radius: 2px;\n}\n\n.code_copy {\n  position: absolute;\n  top: 0.7rem;\n  right: 35px;\n  z-index: 1;\n  filter: invert(50%);\n  cursor: pointer;\n}\n\n.code_lang {\n  position: absolute;\n  top: 1.2rem;\n  right: 60px;\n  line-height: 0;\n  font-weight: bold;\n  font-family: normal;\n  z-index: 1;\n  filter: invert(50%);\n  cursor: pointer;\n}\n\n.code-expand {\n  position: absolute;\n  top: 4px;\n  right: 0px;\n  filter: invert(50%);\n  padding: 7px 10px;\n  z-index: 1;\n  cursor: pointer;\n  transition: all .3s;\n  transform: rotate(0deg);\n}\n\n.code-closed .code-expand {\n  transform: rotate(-180deg) !important;\n  transition: all .3s;\n}\n\n.code-closed pre::before {\n  height: 0px;\n}\n\npre code {\n  padding: 0;\n  color: #e8eaf6;\n  background-color: #272822;\n}\n\npre[class*=\"language-\"] {\n  padding: 1.2em;\n  margin: .5em 0;\n}\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: #e8eaf6;\n  white-space: pre-wrap !important;\n}\n*/","source":"custom.css","raw":".nexmoe-post {\n  border-radius: 16px;\n  box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.1);\n}\n\n.nexmoe-post article {\n  padding: 15px;\n}\n\n/* clipboard代码块 */\n\n\n/*\ncode {\n  padding: 1px 5px;\n  font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace;\n  color: #e96900;\n  background-color: #f8f8f8;\n  border-radius: 2px;\n}\n\npre code {\n  padding: 0;\n  color: #e8eaf6;\n  background-color: #272822;\n}\n\npre[class*=\"language-\"] {\n  padding: 1.2em;\n  margin: .5em 0;\n}\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: #e8eaf6;\n  white-space: pre-wrap !important;\n}\n\n.line-numbers-rows {\n  border-right-width: 0px !important;\n}\n\n.line-numbers {\n  padding: 1.5rem 1.5rem 1.5rem 3.2rem !important;\n  margin: 1rem 0 !important;\n  background: #272822;\n  overflow: auto;\n  border-radius: 0.35rem;\n  tab-size: 4;\n}\n\n\npre {\n  padding: 1.5rem !important;\n  margin: 1rem 0 !important;\n  background: #272822;\n  overflow: auto;\n  border-radius: 0.35rem;\n  tab-size: 4;\n}\n\npre::before {\n  content: \"\";\n  height: 16px;\n  margin-bottom: 0;\n  display: block;\n}\n\npre::after {\n  content: \" \";\n  position: absolute;\n  border-radius: 50%;\n  background: #ff5f56;\n  width: 12px;\n  height: 12px;\n  top: 0;\n  left: 12px;\n  margin-top: 12px;\n  -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;\n  box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;\n}\n\ncode {\n  padding: 1px 5px;\n  font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace;\n  font-size: 0.91rem;\n  color: #e96900;\n  background-color: #f8f8f8;\n  border-radius: 2px;\n}\n\n.code_copy {\n  position: absolute;\n  top: 0.7rem;\n  right: 35px;\n  z-index: 1;\n  filter: invert(50%);\n  cursor: pointer;\n}\n\n.code_lang {\n  position: absolute;\n  top: 1.2rem;\n  right: 60px;\n  line-height: 0;\n  font-weight: bold;\n  font-family: normal;\n  z-index: 1;\n  filter: invert(50%);\n  cursor: pointer;\n}\n\n.code-expand {\n  position: absolute;\n  top: 4px;\n  right: 0px;\n  filter: invert(50%);\n  padding: 7px 10px;\n  z-index: 1;\n  cursor: pointer;\n  transition: all .3s;\n  transform: rotate(0deg);\n}\n\n.code-closed .code-expand {\n  transform: rotate(-180deg) !important;\n  transition: all .3s;\n}\n\n.code-closed pre::before {\n  height: 0px;\n}\n\npre code {\n  padding: 0;\n  color: #e8eaf6;\n  background-color: #272822;\n}\n\npre[class*=\"language-\"] {\n  padding: 1.2em;\n  margin: .5em 0;\n}\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: #e8eaf6;\n  white-space: pre-wrap !important;\n}\n*/","date":"2022-01-26T04:07:18.856Z","updated":"2022-01-26T04:07:18.856Z","path":"custom.css","layout":"false","title":"","comments":1,"_id":"ckzi2bho00000aswzeau0emh4","content":".nexmoe-post {\n  border-radius: 16px;\n  box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.1);\n}\n\n.nexmoe-post article {\n  padding: 15px;\n}\n\n/* clipboard代码块 */\n\n\n/*\ncode {\n  padding: 1px 5px;\n  font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace;\n  color: #e96900;\n  background-color: #f8f8f8;\n  border-radius: 2px;\n}\n\npre code {\n  padding: 0;\n  color: #e8eaf6;\n  background-color: #272822;\n}\n\npre[class*=\"language-\"] {\n  padding: 1.2em;\n  margin: .5em 0;\n}\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: #e8eaf6;\n  white-space: pre-wrap !important;\n}\n\n.line-numbers-rows {\n  border-right-width: 0px !important;\n}\n\n.line-numbers {\n  padding: 1.5rem 1.5rem 1.5rem 3.2rem !important;\n  margin: 1rem 0 !important;\n  background: #272822;\n  overflow: auto;\n  border-radius: 0.35rem;\n  tab-size: 4;\n}\n\n\npre {\n  padding: 1.5rem !important;\n  margin: 1rem 0 !important;\n  background: #272822;\n  overflow: auto;\n  border-radius: 0.35rem;\n  tab-size: 4;\n}\n\npre::before {\n  content: \"\";\n  height: 16px;\n  margin-bottom: 0;\n  display: block;\n}\n\npre::after {\n  content: \" \";\n  position: absolute;\n  border-radius: 50%;\n  background: #ff5f56;\n  width: 12px;\n  height: 12px;\n  top: 0;\n  left: 12px;\n  margin-top: 12px;\n  -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;\n  box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;\n}\n\ncode {\n  padding: 1px 5px;\n  font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace;\n  font-size: 0.91rem;\n  color: #e96900;\n  background-color: #f8f8f8;\n  border-radius: 2px;\n}\n\n.code_copy {\n  position: absolute;\n  top: 0.7rem;\n  right: 35px;\n  z-index: 1;\n  filter: invert(50%);\n  cursor: pointer;\n}\n\n.code_lang {\n  position: absolute;\n  top: 1.2rem;\n  right: 60px;\n  line-height: 0;\n  font-weight: bold;\n  font-family: normal;\n  z-index: 1;\n  filter: invert(50%);\n  cursor: pointer;\n}\n\n.code-expand {\n  position: absolute;\n  top: 4px;\n  right: 0px;\n  filter: invert(50%);\n  padding: 7px 10px;\n  z-index: 1;\n  cursor: pointer;\n  transition: all .3s;\n  transform: rotate(0deg);\n}\n\n.code-closed .code-expand {\n  transform: rotate(-180deg) !important;\n  transition: all .3s;\n}\n\n.code-closed pre::before {\n  height: 0px;\n}\n\npre code {\n  padding: 0;\n  color: #e8eaf6;\n  background-color: #272822;\n}\n\npre[class*=\"language-\"] {\n  padding: 1.2em;\n  margin: .5em 0;\n}\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: #e8eaf6;\n  white-space: pre-wrap !important;\n}\n*/","site":{"data":{}},"excerpt":"","more":".nexmoe-post {\n  border-radius: 16px;\n  box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.1);\n}\n\n.nexmoe-post article {\n  padding: 15px;\n}\n\n/* clipboard代码块 */\n\n\n/*\ncode {\n  padding: 1px 5px;\n  font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace;\n  color: #e96900;\n  background-color: #f8f8f8;\n  border-radius: 2px;\n}\n\npre code {\n  padding: 0;\n  color: #e8eaf6;\n  background-color: #272822;\n}\n\npre[class*=\"language-\"] {\n  padding: 1.2em;\n  margin: .5em 0;\n}\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: #e8eaf6;\n  white-space: pre-wrap !important;\n}\n\n.line-numbers-rows {\n  border-right-width: 0px !important;\n}\n\n.line-numbers {\n  padding: 1.5rem 1.5rem 1.5rem 3.2rem !important;\n  margin: 1rem 0 !important;\n  background: #272822;\n  overflow: auto;\n  border-radius: 0.35rem;\n  tab-size: 4;\n}\n\n\npre {\n  padding: 1.5rem !important;\n  margin: 1rem 0 !important;\n  background: #272822;\n  overflow: auto;\n  border-radius: 0.35rem;\n  tab-size: 4;\n}\n\npre::before {\n  content: \"\";\n  height: 16px;\n  margin-bottom: 0;\n  display: block;\n}\n\npre::after {\n  content: \" \";\n  position: absolute;\n  border-radius: 50%;\n  background: #ff5f56;\n  width: 12px;\n  height: 12px;\n  top: 0;\n  left: 12px;\n  margin-top: 12px;\n  -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;\n  box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;\n}\n\ncode {\n  padding: 1px 5px;\n  font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace;\n  font-size: 0.91rem;\n  color: #e96900;\n  background-color: #f8f8f8;\n  border-radius: 2px;\n}\n\n.code_copy {\n  position: absolute;\n  top: 0.7rem;\n  right: 35px;\n  z-index: 1;\n  filter: invert(50%);\n  cursor: pointer;\n}\n\n.code_lang {\n  position: absolute;\n  top: 1.2rem;\n  right: 60px;\n  line-height: 0;\n  font-weight: bold;\n  font-family: normal;\n  z-index: 1;\n  filter: invert(50%);\n  cursor: pointer;\n}\n\n.code-expand {\n  position: absolute;\n  top: 4px;\n  right: 0px;\n  filter: invert(50%);\n  padding: 7px 10px;\n  z-index: 1;\n  cursor: pointer;\n  transition: all .3s;\n  transform: rotate(0deg);\n}\n\n.code-closed .code-expand {\n  transform: rotate(-180deg) !important;\n  transition: all .3s;\n}\n\n.code-closed pre::before {\n  height: 0px;\n}\n\npre code {\n  padding: 0;\n  color: #e8eaf6;\n  background-color: #272822;\n}\n\npre[class*=\"language-\"] {\n  padding: 1.2em;\n  margin: .5em 0;\n}\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n  color: #e8eaf6;\n  white-space: pre-wrap !important;\n}\n*/"},{"title":"文章归档","layout":"archives","_content":"\n","source":"my_archives.md","raw":"---\ntitle: 文章归档\nlayout: archives\npermalink: archive.html\n---\n\n","date":"2022-01-23T04:27:36.716Z","updated":"2022-01-23T04:27:36.716Z","path":"archive.html","comments":1,"_id":"ckzi2bho60002aswz8ay59j92","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"mmdetection的一些小坑","reprint":false,"cover":null,"date":"2022-01-23T04:46:21.000Z","updated":"2022-01-23T04:46:21.000Z","_content":"\n记录一下使用mmdetection中遇到的一些坑，方便查阅。\n\n<!--more-->\n\n# 安装\n\npip install mmcv-full==1.3.9 -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.9.0/index.html\n\npip install mmcv-full==1.3.9 -f https://download.openmmlab.com/mmcv/dist/cu101/torch1.7.0/index.html\n\n修改完后，需要重新编译（python setup.py install)\n\npip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu111/{torch_version}/index.html\n\npip install mmcv-full==1.3.3 -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.8.0/index.html \n\npip install -r requirements/build.txt\npython setup.py develop\n\n\n\n# 修改数据集为coco格式\n\n目录格式：\n\n```\nmmdetection\n├── mmdet\n├── tools\n├── configs\n├── data\n│   ├── coco\n│   │   ├── annotations\n│   │   ├── train2017\n│   │   ├── val2017\n│   │   ├── test2017\n```\n\n修改相关文件：\n\n[(4条消息) mmdetection自定义数据集进行训练_xiangxianghehe的博客-CSDN博客_mmdetection 训练数据集](https://blog.csdn.net/xiangxianghehe/article/details/89812058#commentsedit)\n\n\n\n\n\n# 常用命令\n\n## 测试与训练\n\npython tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn\n_1x_coco.py checkpoints/epoch_2.pth --show\n\npython tools/train.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py\n\npython tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py checkpoints/{model}/latest.pth --out results/{model}/results.pkl --show-dir results/\n\n```\npython tools/test.py configs/fcos/fcos_r50_caffe_fpn_gn-head_1x_coco.py checkpoints/latest.pth --out results/fcos_r50_caffe_fpn_gn-head_1x_coco/results.pkl --show-dir results/\n```\n\n## train参数\n\nThis tool accepts several optional arguments, including:\n\n- `--no-validate` (**not suggested**): Disable evaluation during training.\n- `--work-dir ${WORK_DIR}`: Override the working directory.\n- `--resume-from ${CHECKPOINT_FILE}`: Resume from a previous checkpoint file.\n- `--options 'Key=value'`: Overrides other settings in the used config.\n\n## 查看config\n\npython tools/misc/print_config.py configs/zr/zr_fcos_r50_caffe_fpn_gn-head_1x_coco.py\n\n## 学习率配置\n\nX：我的一个batchsize输入图像数量\nY：mmdetction一个batchsize输入图像数量\nZ：默认学习率\n\n新的学习率= （X/Y）x Z\n如：\nX：1GPU+2img/GPU=2张\nMMdet默认是8GPU*2img/GPU=16张\nMMdet默认学习率=0.02\n新的学习率=0.0025\n\n\n\n为了克服数据量多的问题，我们会选择将数据分成几个部分，即batch，进行训练，从而使得每个批次的数据量是可以负载的。将这些batch的数据逐一送入计算训练，更新神经网络的权值，使得网络收敛。\n\n一个epoch指代所有的数据送入网络中完成一次前向计算及反向传播的过程。由于一个epoch常常太大，计算机无法负荷，我们会将它分成几个较小的batches。\n\n所谓Batch就是每次送入网络中训练的一部分数据，而Batch Size就是每个batch中训练样本的数量\n\n所谓iterations就是完成一次epoch所需的batch个数。\n\n简单一句话说就是，我们有2000个数据，分成4个batch，那么batch size就是500。运行所有的数据进行训练，完成1个epoch，需要进行4次iterations。\n\n# TOOLS\n\n## Log Analysis\n\n`tools/analysis_tools/analyze_logs.py` plots loss/mAP curves given a training log file. Run `pip install seaborn` first to install the dependency.\n\n```\npython tools/analysis_tools/analyze_logs.py plot_curve [--keys ${KEYS}] [--title ${TITLE}] [--legend ${LEGEND}] [--backend ${BACKEND}] [--style ${STYLE}] [--out ${OUT_FILE}]\n```\n\n- ```\n  python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json --keys loss_cls --legend loss_cls\n  ```\n\n- ```\n  python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json --keys bbox_mAP --legend bbox_mAP\n  ```\n\n## Result Analysis\n\n`tools/analysis_tools/analyze_results.py` calculates single image mAP and saves or shows the topk images with the highest and lowest scores based on prediction results.\n\nUsage:\n\n```\npython tools/analysis_tools/analyze_results.py \\\n      ${CONFIG} \\\n      ${PREDICTION_PATH} \\\n      ${SHOW_DIR} \\\n      [--show] \\\n      [--wait-time ${WAIT_TIME}] \\\n      [--topk ${TOPK}] \\\n      [--show-score-thr ${SHOW_SCORE_THR}] \\\n      [--cfg-options ${CFG_OPTIONS}]\n```\n\nDescription of all arguments:\n\n- `config` : The path of a model config file.\n- `prediction_path`: Output result file in pickle format from `tools/test.py`\n- `show_dir`: Directory where painted GT and detection images will be saved\n- `--show`：Determines whether to show painted images, If not specified, it will be set to `False`\n- `--wait-time`: The interval of show (s), 0 is block\n- `--topk`: The number of saved images that have the highest and lowest `topk` scores after sorting. If not specified, it will be set to `20`.\n- `--show-score-thr`: Show score threshold. If not specified, it will be set to `0`.\n- `--cfg-options`: If specified, the key-value pair optional cfg will be merged into config file\n\nExamples:\n\nAssume that you have got result file in pickle format from `tools/test.py` in the path ‘./result.pkl’.\n\nTest Faster R-CNN and visualize the results, save images to the directory `results/`\n\n```\npython tools/analysis_tools/analyze_results.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl results --show\n```\n\nTest Faster R-CNN and specified topk to 50, save images to the directory `results/`\n\n```\npython tools/analysis_tools/analyze_results.py \\\n       configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\\n       result.pkl \\\n       results \\\n       --topk 50\n```\n\nIf you want to filter the low score prediction results, you can specify the `show-score-thr` parameter\n\n```\npython tools/analysis_tools/analyze_results.py \\\n       configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\\n       result.pkl \\\n       results \\\n       --show-score-thr 0.3\n```\n\n```\npython tools/analysis_tools/eval_metric.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl \n```\n\n","source":"_posts/mmdetection的一些小坑.md","raw":"---\ntitle: mmdetection的一些小坑\nreprint: false\ncover:\ndate: 2022-01-23 12:46:21\nupdated: 2022-01-23 12:46:21\ncategories: 环境搭建\ntags:\n  - mmdetection\n  - 目标检测\n---\n\n记录一下使用mmdetection中遇到的一些坑，方便查阅。\n\n<!--more-->\n\n# 安装\n\npip install mmcv-full==1.3.9 -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.9.0/index.html\n\npip install mmcv-full==1.3.9 -f https://download.openmmlab.com/mmcv/dist/cu101/torch1.7.0/index.html\n\n修改完后，需要重新编译（python setup.py install)\n\npip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu111/{torch_version}/index.html\n\npip install mmcv-full==1.3.3 -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.8.0/index.html \n\npip install -r requirements/build.txt\npython setup.py develop\n\n\n\n# 修改数据集为coco格式\n\n目录格式：\n\n```\nmmdetection\n├── mmdet\n├── tools\n├── configs\n├── data\n│   ├── coco\n│   │   ├── annotations\n│   │   ├── train2017\n│   │   ├── val2017\n│   │   ├── test2017\n```\n\n修改相关文件：\n\n[(4条消息) mmdetection自定义数据集进行训练_xiangxianghehe的博客-CSDN博客_mmdetection 训练数据集](https://blog.csdn.net/xiangxianghehe/article/details/89812058#commentsedit)\n\n\n\n\n\n# 常用命令\n\n## 测试与训练\n\npython tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn\n_1x_coco.py checkpoints/epoch_2.pth --show\n\npython tools/train.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py\n\npython tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py checkpoints/{model}/latest.pth --out results/{model}/results.pkl --show-dir results/\n\n```\npython tools/test.py configs/fcos/fcos_r50_caffe_fpn_gn-head_1x_coco.py checkpoints/latest.pth --out results/fcos_r50_caffe_fpn_gn-head_1x_coco/results.pkl --show-dir results/\n```\n\n## train参数\n\nThis tool accepts several optional arguments, including:\n\n- `--no-validate` (**not suggested**): Disable evaluation during training.\n- `--work-dir ${WORK_DIR}`: Override the working directory.\n- `--resume-from ${CHECKPOINT_FILE}`: Resume from a previous checkpoint file.\n- `--options 'Key=value'`: Overrides other settings in the used config.\n\n## 查看config\n\npython tools/misc/print_config.py configs/zr/zr_fcos_r50_caffe_fpn_gn-head_1x_coco.py\n\n## 学习率配置\n\nX：我的一个batchsize输入图像数量\nY：mmdetction一个batchsize输入图像数量\nZ：默认学习率\n\n新的学习率= （X/Y）x Z\n如：\nX：1GPU+2img/GPU=2张\nMMdet默认是8GPU*2img/GPU=16张\nMMdet默认学习率=0.02\n新的学习率=0.0025\n\n\n\n为了克服数据量多的问题，我们会选择将数据分成几个部分，即batch，进行训练，从而使得每个批次的数据量是可以负载的。将这些batch的数据逐一送入计算训练，更新神经网络的权值，使得网络收敛。\n\n一个epoch指代所有的数据送入网络中完成一次前向计算及反向传播的过程。由于一个epoch常常太大，计算机无法负荷，我们会将它分成几个较小的batches。\n\n所谓Batch就是每次送入网络中训练的一部分数据，而Batch Size就是每个batch中训练样本的数量\n\n所谓iterations就是完成一次epoch所需的batch个数。\n\n简单一句话说就是，我们有2000个数据，分成4个batch，那么batch size就是500。运行所有的数据进行训练，完成1个epoch，需要进行4次iterations。\n\n# TOOLS\n\n## Log Analysis\n\n`tools/analysis_tools/analyze_logs.py` plots loss/mAP curves given a training log file. Run `pip install seaborn` first to install the dependency.\n\n```\npython tools/analysis_tools/analyze_logs.py plot_curve [--keys ${KEYS}] [--title ${TITLE}] [--legend ${LEGEND}] [--backend ${BACKEND}] [--style ${STYLE}] [--out ${OUT_FILE}]\n```\n\n- ```\n  python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json --keys loss_cls --legend loss_cls\n  ```\n\n- ```\n  python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json --keys bbox_mAP --legend bbox_mAP\n  ```\n\n## Result Analysis\n\n`tools/analysis_tools/analyze_results.py` calculates single image mAP and saves or shows the topk images with the highest and lowest scores based on prediction results.\n\nUsage:\n\n```\npython tools/analysis_tools/analyze_results.py \\\n      ${CONFIG} \\\n      ${PREDICTION_PATH} \\\n      ${SHOW_DIR} \\\n      [--show] \\\n      [--wait-time ${WAIT_TIME}] \\\n      [--topk ${TOPK}] \\\n      [--show-score-thr ${SHOW_SCORE_THR}] \\\n      [--cfg-options ${CFG_OPTIONS}]\n```\n\nDescription of all arguments:\n\n- `config` : The path of a model config file.\n- `prediction_path`: Output result file in pickle format from `tools/test.py`\n- `show_dir`: Directory where painted GT and detection images will be saved\n- `--show`：Determines whether to show painted images, If not specified, it will be set to `False`\n- `--wait-time`: The interval of show (s), 0 is block\n- `--topk`: The number of saved images that have the highest and lowest `topk` scores after sorting. If not specified, it will be set to `20`.\n- `--show-score-thr`: Show score threshold. If not specified, it will be set to `0`.\n- `--cfg-options`: If specified, the key-value pair optional cfg will be merged into config file\n\nExamples:\n\nAssume that you have got result file in pickle format from `tools/test.py` in the path ‘./result.pkl’.\n\nTest Faster R-CNN and visualize the results, save images to the directory `results/`\n\n```\npython tools/analysis_tools/analyze_results.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl results --show\n```\n\nTest Faster R-CNN and specified topk to 50, save images to the directory `results/`\n\n```\npython tools/analysis_tools/analyze_results.py \\\n       configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\\n       result.pkl \\\n       results \\\n       --topk 50\n```\n\nIf you want to filter the low score prediction results, you can specify the `show-score-thr` parameter\n\n```\npython tools/analysis_tools/analyze_results.py \\\n       configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\\n       result.pkl \\\n       results \\\n       --show-score-thr 0.3\n```\n\n```\npython tools/analysis_tools/eval_metric.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl \n```\n\n","slug":"mmdetection的一些小坑","published":1,"_id":"ckzi2bho60003aswzf95ebcdu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记录一下使用mmdetection中遇到的一些坑，方便查阅。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>pip install mmcv-full==1.3.9 -f <a href=\"https://download.openmmlab.com/mmcv/dist/cu111/torch1.9.0/index.html\">https://download.openmmlab.com/mmcv/dist/cu111/torch1.9.0/index.html</a></p>\n<p>pip install mmcv-full==1.3.9 -f <a href=\"https://download.openmmlab.com/mmcv/dist/cu101/torch1.7.0/index.html\">https://download.openmmlab.com/mmcv/dist/cu101/torch1.7.0/index.html</a></p>\n<p>修改完后，需要重新编译（python setup.py install)</p>\n<p>pip install mmcv-full -f <a href=\"https://download.openmmlab.com/mmcv/dist/cu111/%7Btorch_version%7D/index.html\">https://download.openmmlab.com/mmcv/dist/cu111/{torch_version}/index.html</a></p>\n<p>pip install mmcv-full==1.3.3 -f <a href=\"https://download.openmmlab.com/mmcv/dist/cu111/torch1.8.0/index.html\">https://download.openmmlab.com/mmcv/dist/cu111/torch1.8.0/index.html</a> </p>\n<p>pip install -r requirements/build.txt<br>python setup.py develop</p>\n<h1 id=\"修改数据集为coco格式\"><a href=\"#修改数据集为coco格式\" class=\"headerlink\" title=\"修改数据集为coco格式\"></a>修改数据集为coco格式</h1><p>目录格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mmdetection</span><br><span class=\"line\">├── mmdet</span><br><span class=\"line\">├── tools</span><br><span class=\"line\">├── configs</span><br><span class=\"line\">├── data</span><br><span class=\"line\">│   ├── coco</span><br><span class=\"line\">│   │   ├── annotations</span><br><span class=\"line\">│   │   ├── train2017</span><br><span class=\"line\">│   │   ├── val2017</span><br><span class=\"line\">│   │   ├── test2017</span><br></pre></td></tr></table></figure>\n\n<p>修改相关文件：</p>\n<p><a href=\"https://blog.csdn.net/xiangxianghehe/article/details/89812058#commentsedit\">(4条消息) mmdetection自定义数据集进行训练_xiangxianghehe的博客-CSDN博客_mmdetection 训练数据集</a></p>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><h2 id=\"测试与训练\"><a href=\"#测试与训练\" class=\"headerlink\" title=\"测试与训练\"></a>测试与训练</h2><p>python tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn<br>_1x_coco.py checkpoints/epoch_2.pth –show</p>\n<p>python tools/train.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py</p>\n<p>python tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py checkpoints/{model}/latest.pth –out results/{model}/results.pkl –show-dir results/</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/test.py configs/fcos/fcos_r50_caffe_fpn_gn-head_1x_coco.py checkpoints/latest.pth --out results/fcos_r50_caffe_fpn_gn-head_1x_coco/results.pkl --show-dir results/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"train参数\"><a href=\"#train参数\" class=\"headerlink\" title=\"train参数\"></a>train参数</h2><p>This tool accepts several optional arguments, including:</p>\n<ul>\n<li><code>--no-validate</code> (<strong>not suggested</strong>): Disable evaluation during training.</li>\n<li><code>--work-dir $&#123;WORK_DIR&#125;</code>: Override the working directory.</li>\n<li><code>--resume-from $&#123;CHECKPOINT_FILE&#125;</code>: Resume from a previous checkpoint file.</li>\n<li><code>--options &#39;Key=value&#39;</code>: Overrides other settings in the used config.</li>\n</ul>\n<h2 id=\"查看config\"><a href=\"#查看config\" class=\"headerlink\" title=\"查看config\"></a>查看config</h2><p>python tools/misc/print_config.py configs/zr/zr_fcos_r50_caffe_fpn_gn-head_1x_coco.py</p>\n<h2 id=\"学习率配置\"><a href=\"#学习率配置\" class=\"headerlink\" title=\"学习率配置\"></a>学习率配置</h2><p>X：我的一个batchsize输入图像数量<br>Y：mmdetction一个batchsize输入图像数量<br>Z：默认学习率</p>\n<p>新的学习率= （X/Y）x Z<br>如：<br>X：1GPU+2img/GPU=2张<br>MMdet默认是8GPU*2img/GPU=16张<br>MMdet默认学习率=0.02<br>新的学习率=0.0025</p>\n<p>为了克服数据量多的问题，我们会选择将数据分成几个部分，即batch，进行训练，从而使得每个批次的数据量是可以负载的。将这些batch的数据逐一送入计算训练，更新神经网络的权值，使得网络收敛。</p>\n<p>一个epoch指代所有的数据送入网络中完成一次前向计算及反向传播的过程。由于一个epoch常常太大，计算机无法负荷，我们会将它分成几个较小的batches。</p>\n<p>所谓Batch就是每次送入网络中训练的一部分数据，而Batch Size就是每个batch中训练样本的数量</p>\n<p>所谓iterations就是完成一次epoch所需的batch个数。</p>\n<p>简单一句话说就是，我们有2000个数据，分成4个batch，那么batch size就是500。运行所有的数据进行训练，完成1个epoch，需要进行4次iterations。</p>\n<h1 id=\"TOOLS\"><a href=\"#TOOLS\" class=\"headerlink\" title=\"TOOLS\"></a>TOOLS</h1><h2 id=\"Log-Analysis\"><a href=\"#Log-Analysis\" class=\"headerlink\" title=\"Log Analysis\"></a>Log Analysis</h2><p><code>tools/analysis_tools/analyze_logs.py</code> plots loss/mAP curves given a training log file. Run <code>pip install seaborn</code> first to install the dependency.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_logs.py plot_curve [--keys $&#123;KEYS&#125;] [--title $&#123;TITLE&#125;] [--legend $&#123;LEGEND&#125;] [--backend $&#123;BACKEND&#125;] [--style $&#123;STYLE&#125;] [--out $&#123;OUT_FILE&#125;]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>```<br>python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json –keys loss_cls –legend loss_cls<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- ```</span><br><span class=\"line\">  python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json --keys bbox_mAP --legend bbox_mAP</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Result-Analysis\"><a href=\"#Result-Analysis\" class=\"headerlink\" title=\"Result Analysis\"></a>Result Analysis</h2><p><code>tools/analysis_tools/analyze_results.py</code> calculates single image mAP and saves or shows the topk images with the highest and lowest scores based on prediction results.</p>\n<p>Usage:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_results.py \\</span><br><span class=\"line\">      $&#123;CONFIG&#125; \\</span><br><span class=\"line\">      $&#123;PREDICTION_PATH&#125; \\</span><br><span class=\"line\">      $&#123;SHOW_DIR&#125; \\</span><br><span class=\"line\">      [--show] \\</span><br><span class=\"line\">      [--wait-time $&#123;WAIT_TIME&#125;] \\</span><br><span class=\"line\">      [--topk $&#123;TOPK&#125;] \\</span><br><span class=\"line\">      [--show-score-thr $&#123;SHOW_SCORE_THR&#125;] \\</span><br><span class=\"line\">      [--cfg-options $&#123;CFG_OPTIONS&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>Description of all arguments:</p>\n<ul>\n<li><code>config</code> : The path of a model config file.</li>\n<li><code>prediction_path</code>: Output result file in pickle format from <code>tools/test.py</code></li>\n<li><code>show_dir</code>: Directory where painted GT and detection images will be saved</li>\n<li><code>--show</code>：Determines whether to show painted images, If not specified, it will be set to <code>False</code></li>\n<li><code>--wait-time</code>: The interval of show (s), 0 is block</li>\n<li><code>--topk</code>: The number of saved images that have the highest and lowest <code>topk</code> scores after sorting. If not specified, it will be set to <code>20</code>.</li>\n<li><code>--show-score-thr</code>: Show score threshold. If not specified, it will be set to <code>0</code>.</li>\n<li><code>--cfg-options</code>: If specified, the key-value pair optional cfg will be merged into config file</li>\n</ul>\n<p>Examples:</p>\n<p>Assume that you have got result file in pickle format from <code>tools/test.py</code> in the path ‘./result.pkl’.</p>\n<p>Test Faster R-CNN and visualize the results, save images to the directory <code>results/</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_results.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl results --show</span><br></pre></td></tr></table></figure>\n\n<p>Test Faster R-CNN and specified topk to 50, save images to the directory <code>results/</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_results.py \\</span><br><span class=\"line\">       configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\</span><br><span class=\"line\">       result.pkl \\</span><br><span class=\"line\">       results \\</span><br><span class=\"line\">       --topk 50</span><br></pre></td></tr></table></figure>\n\n<p>If you want to filter the low score prediction results, you can specify the <code>show-score-thr</code> parameter</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_results.py \\</span><br><span class=\"line\">       configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\</span><br><span class=\"line\">       result.pkl \\</span><br><span class=\"line\">       results \\</span><br><span class=\"line\">       --show-score-thr 0.3</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/eval_metric.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl </span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>记录一下使用mmdetection中遇到的一些坑，方便查阅。</p>","more":"<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>pip install mmcv-full==1.3.9 -f <a href=\"https://download.openmmlab.com/mmcv/dist/cu111/torch1.9.0/index.html\">https://download.openmmlab.com/mmcv/dist/cu111/torch1.9.0/index.html</a></p>\n<p>pip install mmcv-full==1.3.9 -f <a href=\"https://download.openmmlab.com/mmcv/dist/cu101/torch1.7.0/index.html\">https://download.openmmlab.com/mmcv/dist/cu101/torch1.7.0/index.html</a></p>\n<p>修改完后，需要重新编译（python setup.py install)</p>\n<p>pip install mmcv-full -f <a href=\"https://download.openmmlab.com/mmcv/dist/cu111/%7Btorch_version%7D/index.html\">https://download.openmmlab.com/mmcv/dist/cu111/{torch_version}/index.html</a></p>\n<p>pip install mmcv-full==1.3.3 -f <a href=\"https://download.openmmlab.com/mmcv/dist/cu111/torch1.8.0/index.html\">https://download.openmmlab.com/mmcv/dist/cu111/torch1.8.0/index.html</a> </p>\n<p>pip install -r requirements/build.txt<br>python setup.py develop</p>\n<h1 id=\"修改数据集为coco格式\"><a href=\"#修改数据集为coco格式\" class=\"headerlink\" title=\"修改数据集为coco格式\"></a>修改数据集为coco格式</h1><p>目录格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mmdetection</span><br><span class=\"line\">├── mmdet</span><br><span class=\"line\">├── tools</span><br><span class=\"line\">├── configs</span><br><span class=\"line\">├── data</span><br><span class=\"line\">│   ├── coco</span><br><span class=\"line\">│   │   ├── annotations</span><br><span class=\"line\">│   │   ├── train2017</span><br><span class=\"line\">│   │   ├── val2017</span><br><span class=\"line\">│   │   ├── test2017</span><br></pre></td></tr></table></figure>\n\n<p>修改相关文件：</p>\n<p><a href=\"https://blog.csdn.net/xiangxianghehe/article/details/89812058#commentsedit\">(4条消息) mmdetection自定义数据集进行训练_xiangxianghehe的博客-CSDN博客_mmdetection 训练数据集</a></p>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><h2 id=\"测试与训练\"><a href=\"#测试与训练\" class=\"headerlink\" title=\"测试与训练\"></a>测试与训练</h2><p>python tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn<br>_1x_coco.py checkpoints/epoch_2.pth –show</p>\n<p>python tools/train.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py</p>\n<p>python tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py checkpoints/{model}/latest.pth –out results/{model}/results.pkl –show-dir results/</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/test.py configs/fcos/fcos_r50_caffe_fpn_gn-head_1x_coco.py checkpoints/latest.pth --out results/fcos_r50_caffe_fpn_gn-head_1x_coco/results.pkl --show-dir results/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"train参数\"><a href=\"#train参数\" class=\"headerlink\" title=\"train参数\"></a>train参数</h2><p>This tool accepts several optional arguments, including:</p>\n<ul>\n<li><code>--no-validate</code> (<strong>not suggested</strong>): Disable evaluation during training.</li>\n<li><code>--work-dir $&#123;WORK_DIR&#125;</code>: Override the working directory.</li>\n<li><code>--resume-from $&#123;CHECKPOINT_FILE&#125;</code>: Resume from a previous checkpoint file.</li>\n<li><code>--options &#39;Key=value&#39;</code>: Overrides other settings in the used config.</li>\n</ul>\n<h2 id=\"查看config\"><a href=\"#查看config\" class=\"headerlink\" title=\"查看config\"></a>查看config</h2><p>python tools/misc/print_config.py configs/zr/zr_fcos_r50_caffe_fpn_gn-head_1x_coco.py</p>\n<h2 id=\"学习率配置\"><a href=\"#学习率配置\" class=\"headerlink\" title=\"学习率配置\"></a>学习率配置</h2><p>X：我的一个batchsize输入图像数量<br>Y：mmdetction一个batchsize输入图像数量<br>Z：默认学习率</p>\n<p>新的学习率= （X/Y）x Z<br>如：<br>X：1GPU+2img/GPU=2张<br>MMdet默认是8GPU*2img/GPU=16张<br>MMdet默认学习率=0.02<br>新的学习率=0.0025</p>\n<p>为了克服数据量多的问题，我们会选择将数据分成几个部分，即batch，进行训练，从而使得每个批次的数据量是可以负载的。将这些batch的数据逐一送入计算训练，更新神经网络的权值，使得网络收敛。</p>\n<p>一个epoch指代所有的数据送入网络中完成一次前向计算及反向传播的过程。由于一个epoch常常太大，计算机无法负荷，我们会将它分成几个较小的batches。</p>\n<p>所谓Batch就是每次送入网络中训练的一部分数据，而Batch Size就是每个batch中训练样本的数量</p>\n<p>所谓iterations就是完成一次epoch所需的batch个数。</p>\n<p>简单一句话说就是，我们有2000个数据，分成4个batch，那么batch size就是500。运行所有的数据进行训练，完成1个epoch，需要进行4次iterations。</p>\n<h1 id=\"TOOLS\"><a href=\"#TOOLS\" class=\"headerlink\" title=\"TOOLS\"></a>TOOLS</h1><h2 id=\"Log-Analysis\"><a href=\"#Log-Analysis\" class=\"headerlink\" title=\"Log Analysis\"></a>Log Analysis</h2><p><code>tools/analysis_tools/analyze_logs.py</code> plots loss/mAP curves given a training log file. Run <code>pip install seaborn</code> first to install the dependency.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_logs.py plot_curve [--keys $&#123;KEYS&#125;] [--title $&#123;TITLE&#125;] [--legend $&#123;LEGEND&#125;] [--backend $&#123;BACKEND&#125;] [--style $&#123;STYLE&#125;] [--out $&#123;OUT_FILE&#125;]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>```<br>python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json –keys loss_cls –legend loss_cls<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- ```</span><br><span class=\"line\">  python tools/analysis_tools/analyze_logs.py plot_curve work_dirs/faster_rcnn_r50_fpn_1x_coco/20210809_105106.log.json --keys bbox_mAP --legend bbox_mAP</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Result-Analysis\"><a href=\"#Result-Analysis\" class=\"headerlink\" title=\"Result Analysis\"></a>Result Analysis</h2><p><code>tools/analysis_tools/analyze_results.py</code> calculates single image mAP and saves or shows the topk images with the highest and lowest scores based on prediction results.</p>\n<p>Usage:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_results.py \\</span><br><span class=\"line\">      $&#123;CONFIG&#125; \\</span><br><span class=\"line\">      $&#123;PREDICTION_PATH&#125; \\</span><br><span class=\"line\">      $&#123;SHOW_DIR&#125; \\</span><br><span class=\"line\">      [--show] \\</span><br><span class=\"line\">      [--wait-time $&#123;WAIT_TIME&#125;] \\</span><br><span class=\"line\">      [--topk $&#123;TOPK&#125;] \\</span><br><span class=\"line\">      [--show-score-thr $&#123;SHOW_SCORE_THR&#125;] \\</span><br><span class=\"line\">      [--cfg-options $&#123;CFG_OPTIONS&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>Description of all arguments:</p>\n<ul>\n<li><code>config</code> : The path of a model config file.</li>\n<li><code>prediction_path</code>: Output result file in pickle format from <code>tools/test.py</code></li>\n<li><code>show_dir</code>: Directory where painted GT and detection images will be saved</li>\n<li><code>--show</code>：Determines whether to show painted images, If not specified, it will be set to <code>False</code></li>\n<li><code>--wait-time</code>: The interval of show (s), 0 is block</li>\n<li><code>--topk</code>: The number of saved images that have the highest and lowest <code>topk</code> scores after sorting. If not specified, it will be set to <code>20</code>.</li>\n<li><code>--show-score-thr</code>: Show score threshold. If not specified, it will be set to <code>0</code>.</li>\n<li><code>--cfg-options</code>: If specified, the key-value pair optional cfg will be merged into config file</li>\n</ul>\n<p>Examples:</p>\n<p>Assume that you have got result file in pickle format from <code>tools/test.py</code> in the path ‘./result.pkl’.</p>\n<p>Test Faster R-CNN and visualize the results, save images to the directory <code>results/</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_results.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl results --show</span><br></pre></td></tr></table></figure>\n\n<p>Test Faster R-CNN and specified topk to 50, save images to the directory <code>results/</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_results.py \\</span><br><span class=\"line\">       configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\</span><br><span class=\"line\">       result.pkl \\</span><br><span class=\"line\">       results \\</span><br><span class=\"line\">       --topk 50</span><br></pre></td></tr></table></figure>\n\n<p>If you want to filter the low score prediction results, you can specify the <code>show-score-thr</code> parameter</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/analyze_results.py \\</span><br><span class=\"line\">       configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \\</span><br><span class=\"line\">       result.pkl \\</span><br><span class=\"line\">       results \\</span><br><span class=\"line\">       --show-score-thr 0.3</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python tools/analysis_tools/eval_metric.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py result.pkl </span><br></pre></td></tr></table></figure>"},{"title":"博客施工记录","reprint":false,"cover":null,"data":"2022-01-18T12:04:35.000Z","_content":"\n记录一下hexo的施工过程。主要参考K大的这篇[基于 Hexo 的全自动博客构建部署系统 ](https://kchen.cc/2016/11/12/hexo-instructions/#什么是-Hexo)，我再稍微补充一些自己遇到的坑。\n\n<!--more-->\n\n# 施工进度\n\n- [x] smms上传限制5M图片，如果图片大于5M需要对图片进行压缩\n- [ ] action缓存，构建加速\n- [ ] ~~dns负载均衡~~（暂时没有第二个服务器）\n- [x] 评论模块\n- [x] 归档页\n\n# 新建文章\n\n在hexo根目录下，终端输入`hexo new [layout] [title]`\n\n| Layout         | Path           |\n| -------------- | -------------- |\n| post (default) | source/_posts  |\n| draft          | source/_drafts |\n| page           | source         |\n\n草稿发布`hexo publish [title]`\n\n# md图床问题\n\nMarkdown使用图床很方便，我现在用的图床是SMMS，暂时没多大问题，但前期做好备份还是有备无患。因此，最好的解决方案是先将图片保存到本地目录，写完push至github后，结合Action自动读取md源文件，并将图片链接转换为图床链接，再完成hexo渲染。\n\npython转换代码如下\n\n```python\nimport argparse\nimport os\nimport argparse\nimport re\nimport requests\nimport json\n\n\ndef smms_upload(img):\n    # 判断图片是否大于5M\n    with open(img, 'rb') as img_file:\n        if os.path.getsize(img) < 5 * 1024 * 1024:\n            try:\n                smms_url = 'https://sm.ms/api/v2/upload'\n                response = requests.post(\n                    smms_url,\n                    files={'smfile': img_file, 'format': 'json'},\n                    headers={'Authorization': smms_token}\n                )\n                print(\"upload finish\")\n                img_new_url = json.loads(response.text)\n                cloud_path = img_new_url['data']['url']\n\n                return cloud_path\n            except BaseException as err:\n                print(f\"error in upload to smms:{err}\")\n        else:\n            print('err in upload, image size is more than 5M')\n            return None\n\n\ndef convert2url(file_path):\n    with open(file_path, 'r', encoding='utf-8') as f:\n        lines = f.readlines()\n\n    outs = []\n    for line in lines:\n        if re.search('\\!\\[.*\\)', line) is not None:\n            images_offline = re.findall('\\!\\[.*\\)', line)  # 找到每段中所有的图片本地链接\n            for item in images_offline:\n                # 对每个链接进行替换\n                img_path = re.search('(?<=\\()(.+?)(?=\\))', item).group()\n                # 判断图片路径是否为网络路径\n                if re.search('[a-zA-z]+://[^\\s]*', img_path) is None:\n                    img_file = os.path.join(path_md, img_path)\n                    images_online = smms_upload(img_file)\n                    if images_online is not None:\n                        line = line.replace(img_path, images_online)\n                        outs.append(line)\n        else:\n            outs.append(line)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.writelines(outs)\n\nif __name__ == \"__main__\":\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"-p\", \"--path\", help=\"the path of your post file\")\n    ap.add_argument(\"-t\", \"--token\", help=\"the token of your smms count\")\n\n    args = ap.parse_args()\n    path_md = args.path\n    smms_token = args.token\n\n    md_list = os.listdir(path_md)\n    md_list = [item for item in md_list if item.endswith('md')]\n    for item in md_list:\n        file_path = os.path.join(path_md, item)\n        convert2url(file_path)\n\n```\n\n\n\n# Github Action自动部署\n\n每次部署在本地hexo g -d，只是在本地构建文件再提交，github只充当了一个静态服务器的作用，没有起到git的作用，因此使用Github Action可以实现自动化部署，且可以实现图床链接的替换。\n\n在`.github`目录下新建文件夹`.workflows`，再新建文件`deployment.yml`，代码如下：\n\n```yaml\nname: Hexo Auto-Deploy\non: [push]\n\njobs:\n  repalce_image:\n    name: md images replace\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: 1. git checkout\n        uses: actions/checkout@v2.4.0\n\n      - name: 2. setup python\n        uses: actions/setup-python@v2.3.1\n        with:\n          python-version: \"3.8.x\"\n          architecture: \"x64\"\n\n      - name: 3. setup and run\n        run: |\n          pip install requests\n          sudo apt install tree\n          tree source/\n          python convert_img2url.py -p source/_posts -t \"${{ secrets.SMMS_TOKEN }}\"\n\n      - name: 4. install hexo...\n        run: |\n          npm install hexo-cli -g\n          npm install\n          npm list --depth 0\n\n      - name: 5. hexo generate\n        run: |\n          hexo clean\n          hexo g\n\n      - name: 6. hexo deploy ...\n        run: |\n          mkdir -p ~/.ssh/\n          echo \"${{ secrets.ACCESS_TOKEN }}\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n\n          git config --global user.name \"zrtty1998\"\n          git config --global user.email \"zrtty1998@gmail.com\"\n          git config --global core.quotepath false\n\n          hexo d\n\n\n```\n\n# 负载均衡\n\n## HTTP重定向\n\nHTTP重定向通过一台服务器根据用户的HTTP请求计算出真实服务器地址，将该地址返回到重定向响应中返回给用户。这种负载均衡方案较简单，缺点如下：\n\n- 浏览器需两次请求才能完成一次访问\n- 重定向服务器本身可能会成为瓶颈\n- HTTP返回码302重定向，可能使搜索引擎判断SEO作弊\n\n![image-20220122110959737](博客施工记录/image-20220122110959737.png)\n\n## DNS负载均衡\n\nDNS负载均衡是使用DNS服务器对同一域名配置多条A记录，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回。其结构类似HTTP负载均衡，只不过将请求步骤交给了DNS服务器。\n\n该方法有如下优点：\n\n- 负载均衡任务交给DNS服务器，较为方便。\n- 部署在服务器上的应用不需要任何配置。\n- 服务器可以位于互联网任何位置。\n- DNS支持基于地理位置的域名解析，即将根据用户所在地理位置，将域名解析成距离最近的一个服务器地址，加速用户访问。\n\n同时该方案也存在如下缺点：\n\n- DNS是多级解析的，每一级都会缓存该条域名的A记录，更新记录生效需要较长时间。\n- 不能按照服务器的处理能力来分配负载，DNS负载均衡采用的是简单的轮询算法，因此其负载均衡的效果不太好。\n- 为保证DNS数据即时更新，使地址能随机分配，一般需要将DNS刷新时间设置较小，但会导致DNS流量大增造成其他问题。\n\n# 博客美化\n\n## 代码块美化\n\n自带的代码块显示没有高亮，也没有一键复制的功能。因此着手添加这两项功能。\n\n首先注意到hexo已经内部集成了highlight.js和prismjs。\n\n","source":"_posts/博客施工记录.md","raw":"---\ntitle: 博客施工记录\nreprint: false\ncover:\ndata: 2022-01-18 20:04:35\ncategories: 环境搭建\ntags:\n  - hexo\n  - Github Actions\n  - blog\n---\n\n记录一下hexo的施工过程。主要参考K大的这篇[基于 Hexo 的全自动博客构建部署系统 ](https://kchen.cc/2016/11/12/hexo-instructions/#什么是-Hexo)，我再稍微补充一些自己遇到的坑。\n\n<!--more-->\n\n# 施工进度\n\n- [x] smms上传限制5M图片，如果图片大于5M需要对图片进行压缩\n- [ ] action缓存，构建加速\n- [ ] ~~dns负载均衡~~（暂时没有第二个服务器）\n- [x] 评论模块\n- [x] 归档页\n\n# 新建文章\n\n在hexo根目录下，终端输入`hexo new [layout] [title]`\n\n| Layout         | Path           |\n| -------------- | -------------- |\n| post (default) | source/_posts  |\n| draft          | source/_drafts |\n| page           | source         |\n\n草稿发布`hexo publish [title]`\n\n# md图床问题\n\nMarkdown使用图床很方便，我现在用的图床是SMMS，暂时没多大问题，但前期做好备份还是有备无患。因此，最好的解决方案是先将图片保存到本地目录，写完push至github后，结合Action自动读取md源文件，并将图片链接转换为图床链接，再完成hexo渲染。\n\npython转换代码如下\n\n```python\nimport argparse\nimport os\nimport argparse\nimport re\nimport requests\nimport json\n\n\ndef smms_upload(img):\n    # 判断图片是否大于5M\n    with open(img, 'rb') as img_file:\n        if os.path.getsize(img) < 5 * 1024 * 1024:\n            try:\n                smms_url = 'https://sm.ms/api/v2/upload'\n                response = requests.post(\n                    smms_url,\n                    files={'smfile': img_file, 'format': 'json'},\n                    headers={'Authorization': smms_token}\n                )\n                print(\"upload finish\")\n                img_new_url = json.loads(response.text)\n                cloud_path = img_new_url['data']['url']\n\n                return cloud_path\n            except BaseException as err:\n                print(f\"error in upload to smms:{err}\")\n        else:\n            print('err in upload, image size is more than 5M')\n            return None\n\n\ndef convert2url(file_path):\n    with open(file_path, 'r', encoding='utf-8') as f:\n        lines = f.readlines()\n\n    outs = []\n    for line in lines:\n        if re.search('\\!\\[.*\\)', line) is not None:\n            images_offline = re.findall('\\!\\[.*\\)', line)  # 找到每段中所有的图片本地链接\n            for item in images_offline:\n                # 对每个链接进行替换\n                img_path = re.search('(?<=\\()(.+?)(?=\\))', item).group()\n                # 判断图片路径是否为网络路径\n                if re.search('[a-zA-z]+://[^\\s]*', img_path) is None:\n                    img_file = os.path.join(path_md, img_path)\n                    images_online = smms_upload(img_file)\n                    if images_online is not None:\n                        line = line.replace(img_path, images_online)\n                        outs.append(line)\n        else:\n            outs.append(line)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.writelines(outs)\n\nif __name__ == \"__main__\":\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"-p\", \"--path\", help=\"the path of your post file\")\n    ap.add_argument(\"-t\", \"--token\", help=\"the token of your smms count\")\n\n    args = ap.parse_args()\n    path_md = args.path\n    smms_token = args.token\n\n    md_list = os.listdir(path_md)\n    md_list = [item for item in md_list if item.endswith('md')]\n    for item in md_list:\n        file_path = os.path.join(path_md, item)\n        convert2url(file_path)\n\n```\n\n\n\n# Github Action自动部署\n\n每次部署在本地hexo g -d，只是在本地构建文件再提交，github只充当了一个静态服务器的作用，没有起到git的作用，因此使用Github Action可以实现自动化部署，且可以实现图床链接的替换。\n\n在`.github`目录下新建文件夹`.workflows`，再新建文件`deployment.yml`，代码如下：\n\n```yaml\nname: Hexo Auto-Deploy\non: [push]\n\njobs:\n  repalce_image:\n    name: md images replace\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: 1. git checkout\n        uses: actions/checkout@v2.4.0\n\n      - name: 2. setup python\n        uses: actions/setup-python@v2.3.1\n        with:\n          python-version: \"3.8.x\"\n          architecture: \"x64\"\n\n      - name: 3. setup and run\n        run: |\n          pip install requests\n          sudo apt install tree\n          tree source/\n          python convert_img2url.py -p source/_posts -t \"${{ secrets.SMMS_TOKEN }}\"\n\n      - name: 4. install hexo...\n        run: |\n          npm install hexo-cli -g\n          npm install\n          npm list --depth 0\n\n      - name: 5. hexo generate\n        run: |\n          hexo clean\n          hexo g\n\n      - name: 6. hexo deploy ...\n        run: |\n          mkdir -p ~/.ssh/\n          echo \"${{ secrets.ACCESS_TOKEN }}\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n\n          git config --global user.name \"zrtty1998\"\n          git config --global user.email \"zrtty1998@gmail.com\"\n          git config --global core.quotepath false\n\n          hexo d\n\n\n```\n\n# 负载均衡\n\n## HTTP重定向\n\nHTTP重定向通过一台服务器根据用户的HTTP请求计算出真实服务器地址，将该地址返回到重定向响应中返回给用户。这种负载均衡方案较简单，缺点如下：\n\n- 浏览器需两次请求才能完成一次访问\n- 重定向服务器本身可能会成为瓶颈\n- HTTP返回码302重定向，可能使搜索引擎判断SEO作弊\n\n![image-20220122110959737](博客施工记录/image-20220122110959737.png)\n\n## DNS负载均衡\n\nDNS负载均衡是使用DNS服务器对同一域名配置多条A记录，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回。其结构类似HTTP负载均衡，只不过将请求步骤交给了DNS服务器。\n\n该方法有如下优点：\n\n- 负载均衡任务交给DNS服务器，较为方便。\n- 部署在服务器上的应用不需要任何配置。\n- 服务器可以位于互联网任何位置。\n- DNS支持基于地理位置的域名解析，即将根据用户所在地理位置，将域名解析成距离最近的一个服务器地址，加速用户访问。\n\n同时该方案也存在如下缺点：\n\n- DNS是多级解析的，每一级都会缓存该条域名的A记录，更新记录生效需要较长时间。\n- 不能按照服务器的处理能力来分配负载，DNS负载均衡采用的是简单的轮询算法，因此其负载均衡的效果不太好。\n- 为保证DNS数据即时更新，使地址能随机分配，一般需要将DNS刷新时间设置较小，但会导致DNS流量大增造成其他问题。\n\n# 博客美化\n\n## 代码块美化\n\n自带的代码块显示没有高亮，也没有一键复制的功能。因此着手添加这两项功能。\n\n首先注意到hexo已经内部集成了highlight.js和prismjs。\n\n","slug":"博客施工记录","published":1,"date":"2022-01-18T13:53:13.215Z","updated":"2022-04-23T08:38:05.274Z","_id":"ckzi2bhob000easwzgrok6lrf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记录一下hexo的施工过程。主要参考K大的这篇<a href=\"https://kchen.cc/2016/11/12/hexo-instructions/#%E4%BB%80%E4%B9%88%E6%98%AF-Hexo\">基于 Hexo 的全自动博客构建部署系统 </a>，我再稍微补充一些自己遇到的坑。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"施工进度\"><a href=\"#施工进度\" class=\"headerlink\" title=\"施工进度\"></a>施工进度</h1><ul>\n<li><input checked disabled type=\"checkbox\"> smms上传限制5M图片，如果图片大于5M需要对图片进行压缩</li>\n<li><input disabled type=\"checkbox\"> action缓存，构建加速</li>\n<li><input disabled type=\"checkbox\"> <del>dns负载均衡</del>（暂时没有第二个服务器）</li>\n<li><input checked disabled type=\"checkbox\"> 评论模块</li>\n<li><input checked disabled type=\"checkbox\"> 归档页</li>\n</ul>\n<h1 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h1><p>在hexo根目录下，终端输入<code>hexo new [layout] [title]</code></p>\n<table>\n<thead>\n<tr>\n<th>Layout</th>\n<th>Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>post (default)</td>\n<td>source/_posts</td>\n</tr>\n<tr>\n<td>draft</td>\n<td>source/_drafts</td>\n</tr>\n<tr>\n<td>page</td>\n<td>source</td>\n</tr>\n</tbody></table>\n<p>草稿发布<code>hexo publish [title]</code></p>\n<h1 id=\"md图床问题\"><a href=\"#md图床问题\" class=\"headerlink\" title=\"md图床问题\"></a>md图床问题</h1><p>Markdown使用图床很方便，我现在用的图床是SMMS，暂时没多大问题，但前期做好备份还是有备无患。因此，最好的解决方案是先将图片保存到本地目录，写完push至github后，结合Action自动读取md源文件，并将图片链接转换为图床链接，再完成hexo渲染。</p>\n<p>python转换代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smms_upload</span>(<span class=\"params\">img</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 判断图片是否大于5M</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(img, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> img_file:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> os.path.getsize(img) &lt; <span class=\"number\">5</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                smms_url = <span class=\"string\">&#x27;https://sm.ms/api/v2/upload&#x27;</span></span><br><span class=\"line\">                response = requests.post(</span><br><span class=\"line\">                    smms_url,</span><br><span class=\"line\">                    files=&#123;<span class=\"string\">&#x27;smfile&#x27;</span>: img_file, <span class=\"string\">&#x27;format&#x27;</span>: <span class=\"string\">&#x27;json&#x27;</span>&#125;,</span><br><span class=\"line\">                    headers=&#123;<span class=\"string\">&#x27;Authorization&#x27;</span>: smms_token&#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;upload finish&quot;</span>)</span><br><span class=\"line\">                img_new_url = json.loads(response.text)</span><br><span class=\"line\">                cloud_path = img_new_url[<span class=\"string\">&#x27;data&#x27;</span>][<span class=\"string\">&#x27;url&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> cloud_path</span><br><span class=\"line\">            <span class=\"keyword\">except</span> BaseException <span class=\"keyword\">as</span> err:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;error in upload to smms:<span class=\"subst\">&#123;err&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;err in upload, image size is more than 5M&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert2url</span>(<span class=\"params\">file_path</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(file_path, <span class=\"string\">&#x27;r&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        lines = f.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\">    outs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> lines:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> re.search(<span class=\"string\">&#x27;\\!\\[.*\\)&#x27;</span>, line) <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            images_offline = re.findall(<span class=\"string\">&#x27;\\!\\[.*\\)&#x27;</span>, line)  <span class=\"comment\"># 找到每段中所有的图片本地链接</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> images_offline:</span><br><span class=\"line\">                <span class=\"comment\"># 对每个链接进行替换</span></span><br><span class=\"line\">                img_path = re.search(<span class=\"string\">&#x27;(?&lt;=\\()(.+?)(?=\\))&#x27;</span>, item).group()</span><br><span class=\"line\">                <span class=\"comment\"># 判断图片路径是否为网络路径</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> re.search(<span class=\"string\">&#x27;[a-zA-z]+://[^\\s]*&#x27;</span>, img_path) <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                    img_file = os.path.join(path_md, img_path)</span><br><span class=\"line\">                    images_online = smms_upload(img_file)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> images_online <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                        line = line.replace(img_path, images_online)</span><br><span class=\"line\">                        outs.append(line)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            outs.append(line)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(file_path, <span class=\"string\">&#x27;w&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.writelines(outs)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    ap = argparse.ArgumentParser()</span><br><span class=\"line\">    ap.add_argument(<span class=\"string\">&quot;-p&quot;</span>, <span class=\"string\">&quot;--path&quot;</span>, <span class=\"built_in\">help</span>=<span class=\"string\">&quot;the path of your post file&quot;</span>)</span><br><span class=\"line\">    ap.add_argument(<span class=\"string\">&quot;-t&quot;</span>, <span class=\"string\">&quot;--token&quot;</span>, <span class=\"built_in\">help</span>=<span class=\"string\">&quot;the token of your smms count&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    args = ap.parse_args()</span><br><span class=\"line\">    path_md = args.path</span><br><span class=\"line\">    smms_token = args.token</span><br><span class=\"line\"></span><br><span class=\"line\">    md_list = os.listdir(path_md)</span><br><span class=\"line\">    md_list = [item <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> md_list <span class=\"keyword\">if</span> item.endswith(<span class=\"string\">&#x27;md&#x27;</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> md_list:</span><br><span class=\"line\">        file_path = os.path.join(path_md, item)</span><br><span class=\"line\">        convert2url(file_path)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Github-Action自动部署\"><a href=\"#Github-Action自动部署\" class=\"headerlink\" title=\"Github Action自动部署\"></a>Github Action自动部署</h1><p>每次部署在本地hexo g -d，只是在本地构建文件再提交，github只充当了一个静态服务器的作用，没有起到git的作用，因此使用Github Action可以实现自动化部署，且可以实现图床链接的替换。</p>\n<p>在<code>.github</code>目录下新建文件夹<code>.workflows</code>，再新建文件<code>deployment.yml</code>，代码如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Hexo</span> <span class=\"string\">Auto-Deploy</span></span><br><span class=\"line\"><span class=\"attr\">on:</span> [<span class=\"string\">push</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">repalce_image:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">md</span> <span class=\"string\">images</span> <span class=\"string\">replace</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">1</span><span class=\"string\">.</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v2.4.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">2</span><span class=\"string\">.</span> <span class=\"string\">setup</span> <span class=\"string\">python</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-python@v2.3.1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">python-version:</span> <span class=\"string\">&quot;3.8.x&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">architecture:</span> <span class=\"string\">&quot;x64&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">3</span><span class=\"string\">.</span> <span class=\"string\">setup</span> <span class=\"string\">and</span> <span class=\"string\">run</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          pip install requests</span></span><br><span class=\"line\"><span class=\"string\">          sudo apt install tree</span></span><br><span class=\"line\"><span class=\"string\">          tree source/</span></span><br><span class=\"line\"><span class=\"string\">          python convert_img2url.py -p source/_posts -t &quot;$&#123;&#123; secrets.SMMS_TOKEN &#125;&#125;&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">4</span><span class=\"string\">.</span> <span class=\"string\">install</span> <span class=\"string\">hexo...</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          npm install hexo-cli -g</span></span><br><span class=\"line\"><span class=\"string\">          npm install</span></span><br><span class=\"line\"><span class=\"string\">          npm list --depth 0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">5</span><span class=\"string\">.</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          hexo clean</span></span><br><span class=\"line\"><span class=\"string\">          hexo g</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">6</span><span class=\"string\">.</span> <span class=\"string\">hexo</span> <span class=\"string\">deploy</span> <span class=\"string\">...</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          mkdir -p ~/.ssh/</span></span><br><span class=\"line\"><span class=\"string\">          echo &quot;$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class=\"line\"><span class=\"string\">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class=\"line\"><span class=\"string\">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.name</span> <span class=\"string\">&quot;zrtty1998&quot;</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.email</span> <span class=\"string\">&quot;zrtty1998@gmail.com&quot;</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">core.quotepath</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"string\">hexo</span> <span class=\"string\">d</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h1><h2 id=\"HTTP重定向\"><a href=\"#HTTP重定向\" class=\"headerlink\" title=\"HTTP重定向\"></a>HTTP重定向</h2><p>HTTP重定向通过一台服务器根据用户的HTTP请求计算出真实服务器地址，将该地址返回到重定向响应中返回给用户。这种负载均衡方案较简单，缺点如下：</p>\n<ul>\n<li>浏览器需两次请求才能完成一次访问</li>\n<li>重定向服务器本身可能会成为瓶颈</li>\n<li>HTTP返回码302重定向，可能使搜索引擎判断SEO作弊</li>\n</ul>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/01/18/ebc99e4d4103/image-20220122110959737.png\" alt=\"image-20220122110959737\" class=\"lazyload\"></p>\n<h2 id=\"DNS负载均衡\"><a href=\"#DNS负载均衡\" class=\"headerlink\" title=\"DNS负载均衡\"></a>DNS负载均衡</h2><p>DNS负载均衡是使用DNS服务器对同一域名配置多条A记录，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回。其结构类似HTTP负载均衡，只不过将请求步骤交给了DNS服务器。</p>\n<p>该方法有如下优点：</p>\n<ul>\n<li>负载均衡任务交给DNS服务器，较为方便。</li>\n<li>部署在服务器上的应用不需要任何配置。</li>\n<li>服务器可以位于互联网任何位置。</li>\n<li>DNS支持基于地理位置的域名解析，即将根据用户所在地理位置，将域名解析成距离最近的一个服务器地址，加速用户访问。</li>\n</ul>\n<p>同时该方案也存在如下缺点：</p>\n<ul>\n<li>DNS是多级解析的，每一级都会缓存该条域名的A记录，更新记录生效需要较长时间。</li>\n<li>不能按照服务器的处理能力来分配负载，DNS负载均衡采用的是简单的轮询算法，因此其负载均衡的效果不太好。</li>\n<li>为保证DNS数据即时更新，使地址能随机分配，一般需要将DNS刷新时间设置较小，但会导致DNS流量大增造成其他问题。</li>\n</ul>\n<h1 id=\"博客美化\"><a href=\"#博客美化\" class=\"headerlink\" title=\"博客美化\"></a>博客美化</h1><h2 id=\"代码块美化\"><a href=\"#代码块美化\" class=\"headerlink\" title=\"代码块美化\"></a>代码块美化</h2><p>自带的代码块显示没有高亮，也没有一键复制的功能。因此着手添加这两项功能。</p>\n<p>首先注意到hexo已经内部集成了highlight.js和prismjs。</p>\n","site":{"data":{}},"excerpt":"<p>记录一下hexo的施工过程。主要参考K大的这篇<a href=\"https://kchen.cc/2016/11/12/hexo-instructions/#%E4%BB%80%E4%B9%88%E6%98%AF-Hexo\">基于 Hexo 的全自动博客构建部署系统 </a>，我再稍微补充一些自己遇到的坑。</p>","more":"<h1 id=\"施工进度\"><a href=\"#施工进度\" class=\"headerlink\" title=\"施工进度\"></a>施工进度</h1><ul>\n<li><input checked disabled type=\"checkbox\"> smms上传限制5M图片，如果图片大于5M需要对图片进行压缩</li>\n<li><input disabled type=\"checkbox\"> action缓存，构建加速</li>\n<li><input disabled type=\"checkbox\"> <del>dns负载均衡</del>（暂时没有第二个服务器）</li>\n<li><input checked disabled type=\"checkbox\"> 评论模块</li>\n<li><input checked disabled type=\"checkbox\"> 归档页</li>\n</ul>\n<h1 id=\"新建文章\"><a href=\"#新建文章\" class=\"headerlink\" title=\"新建文章\"></a>新建文章</h1><p>在hexo根目录下，终端输入<code>hexo new [layout] [title]</code></p>\n<table>\n<thead>\n<tr>\n<th>Layout</th>\n<th>Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>post (default)</td>\n<td>source/_posts</td>\n</tr>\n<tr>\n<td>draft</td>\n<td>source/_drafts</td>\n</tr>\n<tr>\n<td>page</td>\n<td>source</td>\n</tr>\n</tbody></table>\n<p>草稿发布<code>hexo publish [title]</code></p>\n<h1 id=\"md图床问题\"><a href=\"#md图床问题\" class=\"headerlink\" title=\"md图床问题\"></a>md图床问题</h1><p>Markdown使用图床很方便，我现在用的图床是SMMS，暂时没多大问题，但前期做好备份还是有备无患。因此，最好的解决方案是先将图片保存到本地目录，写完push至github后，结合Action自动读取md源文件，并将图片链接转换为图床链接，再完成hexo渲染。</p>\n<p>python转换代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">smms_upload</span>(<span class=\"params\">img</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 判断图片是否大于5M</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(img, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> img_file:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> os.path.getsize(img) &lt; <span class=\"number\">5</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                smms_url = <span class=\"string\">&#x27;https://sm.ms/api/v2/upload&#x27;</span></span><br><span class=\"line\">                response = requests.post(</span><br><span class=\"line\">                    smms_url,</span><br><span class=\"line\">                    files=&#123;<span class=\"string\">&#x27;smfile&#x27;</span>: img_file, <span class=\"string\">&#x27;format&#x27;</span>: <span class=\"string\">&#x27;json&#x27;</span>&#125;,</span><br><span class=\"line\">                    headers=&#123;<span class=\"string\">&#x27;Authorization&#x27;</span>: smms_token&#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;upload finish&quot;</span>)</span><br><span class=\"line\">                img_new_url = json.loads(response.text)</span><br><span class=\"line\">                cloud_path = img_new_url[<span class=\"string\">&#x27;data&#x27;</span>][<span class=\"string\">&#x27;url&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> cloud_path</span><br><span class=\"line\">            <span class=\"keyword\">except</span> BaseException <span class=\"keyword\">as</span> err:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;error in upload to smms:<span class=\"subst\">&#123;err&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;err in upload, image size is more than 5M&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">convert2url</span>(<span class=\"params\">file_path</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(file_path, <span class=\"string\">&#x27;r&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        lines = f.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\">    outs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> lines:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> re.search(<span class=\"string\">&#x27;\\!\\[.*\\)&#x27;</span>, line) <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            images_offline = re.findall(<span class=\"string\">&#x27;\\!\\[.*\\)&#x27;</span>, line)  <span class=\"comment\"># 找到每段中所有的图片本地链接</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> images_offline:</span><br><span class=\"line\">                <span class=\"comment\"># 对每个链接进行替换</span></span><br><span class=\"line\">                img_path = re.search(<span class=\"string\">&#x27;(?&lt;=\\()(.+?)(?=\\))&#x27;</span>, item).group()</span><br><span class=\"line\">                <span class=\"comment\"># 判断图片路径是否为网络路径</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> re.search(<span class=\"string\">&#x27;[a-zA-z]+://[^\\s]*&#x27;</span>, img_path) <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                    img_file = os.path.join(path_md, img_path)</span><br><span class=\"line\">                    images_online = smms_upload(img_file)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> images_online <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                        line = line.replace(img_path, images_online)</span><br><span class=\"line\">                        outs.append(line)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            outs.append(line)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(file_path, <span class=\"string\">&#x27;w&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.writelines(outs)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    ap = argparse.ArgumentParser()</span><br><span class=\"line\">    ap.add_argument(<span class=\"string\">&quot;-p&quot;</span>, <span class=\"string\">&quot;--path&quot;</span>, <span class=\"built_in\">help</span>=<span class=\"string\">&quot;the path of your post file&quot;</span>)</span><br><span class=\"line\">    ap.add_argument(<span class=\"string\">&quot;-t&quot;</span>, <span class=\"string\">&quot;--token&quot;</span>, <span class=\"built_in\">help</span>=<span class=\"string\">&quot;the token of your smms count&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    args = ap.parse_args()</span><br><span class=\"line\">    path_md = args.path</span><br><span class=\"line\">    smms_token = args.token</span><br><span class=\"line\"></span><br><span class=\"line\">    md_list = os.listdir(path_md)</span><br><span class=\"line\">    md_list = [item <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> md_list <span class=\"keyword\">if</span> item.endswith(<span class=\"string\">&#x27;md&#x27;</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> md_list:</span><br><span class=\"line\">        file_path = os.path.join(path_md, item)</span><br><span class=\"line\">        convert2url(file_path)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Github-Action自动部署\"><a href=\"#Github-Action自动部署\" class=\"headerlink\" title=\"Github Action自动部署\"></a>Github Action自动部署</h1><p>每次部署在本地hexo g -d，只是在本地构建文件再提交，github只充当了一个静态服务器的作用，没有起到git的作用，因此使用Github Action可以实现自动化部署，且可以实现图床链接的替换。</p>\n<p>在<code>.github</code>目录下新建文件夹<code>.workflows</code>，再新建文件<code>deployment.yml</code>，代码如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Hexo</span> <span class=\"string\">Auto-Deploy</span></span><br><span class=\"line\"><span class=\"attr\">on:</span> [<span class=\"string\">push</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">repalce_image:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">md</span> <span class=\"string\">images</span> <span class=\"string\">replace</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">1</span><span class=\"string\">.</span> <span class=\"string\">git</span> <span class=\"string\">checkout</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v2.4.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">2</span><span class=\"string\">.</span> <span class=\"string\">setup</span> <span class=\"string\">python</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-python@v2.3.1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">python-version:</span> <span class=\"string\">&quot;3.8.x&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">architecture:</span> <span class=\"string\">&quot;x64&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">3</span><span class=\"string\">.</span> <span class=\"string\">setup</span> <span class=\"string\">and</span> <span class=\"string\">run</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          pip install requests</span></span><br><span class=\"line\"><span class=\"string\">          sudo apt install tree</span></span><br><span class=\"line\"><span class=\"string\">          tree source/</span></span><br><span class=\"line\"><span class=\"string\">          python convert_img2url.py -p source/_posts -t &quot;$&#123;&#123; secrets.SMMS_TOKEN &#125;&#125;&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">4</span><span class=\"string\">.</span> <span class=\"string\">install</span> <span class=\"string\">hexo...</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          npm install hexo-cli -g</span></span><br><span class=\"line\"><span class=\"string\">          npm install</span></span><br><span class=\"line\"><span class=\"string\">          npm list --depth 0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">5</span><span class=\"string\">.</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          hexo clean</span></span><br><span class=\"line\"><span class=\"string\">          hexo g</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"number\">6</span><span class=\"string\">.</span> <span class=\"string\">hexo</span> <span class=\"string\">deploy</span> <span class=\"string\">...</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          mkdir -p ~/.ssh/</span></span><br><span class=\"line\"><span class=\"string\">          echo &quot;$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class=\"line\"><span class=\"string\">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class=\"line\"><span class=\"string\">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.name</span> <span class=\"string\">&quot;zrtty1998&quot;</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.email</span> <span class=\"string\">&quot;zrtty1998@gmail.com&quot;</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">core.quotepath</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"string\">hexo</span> <span class=\"string\">d</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h1><h2 id=\"HTTP重定向\"><a href=\"#HTTP重定向\" class=\"headerlink\" title=\"HTTP重定向\"></a>HTTP重定向</h2><p>HTTP重定向通过一台服务器根据用户的HTTP请求计算出真实服务器地址，将该地址返回到重定向响应中返回给用户。这种负载均衡方案较简单，缺点如下：</p>\n<ul>\n<li>浏览器需两次请求才能完成一次访问</li>\n<li>重定向服务器本身可能会成为瓶颈</li>\n<li>HTTP返回码302重定向，可能使搜索引擎判断SEO作弊</li>\n</ul>\n<p><img src=\"/2022/01/18/ebc99e4d4103/image-20220122110959737.png\" alt=\"image-20220122110959737\"></p>\n<h2 id=\"DNS负载均衡\"><a href=\"#DNS负载均衡\" class=\"headerlink\" title=\"DNS负载均衡\"></a>DNS负载均衡</h2><p>DNS负载均衡是使用DNS服务器对同一域名配置多条A记录，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回。其结构类似HTTP负载均衡，只不过将请求步骤交给了DNS服务器。</p>\n<p>该方法有如下优点：</p>\n<ul>\n<li>负载均衡任务交给DNS服务器，较为方便。</li>\n<li>部署在服务器上的应用不需要任何配置。</li>\n<li>服务器可以位于互联网任何位置。</li>\n<li>DNS支持基于地理位置的域名解析，即将根据用户所在地理位置，将域名解析成距离最近的一个服务器地址，加速用户访问。</li>\n</ul>\n<p>同时该方案也存在如下缺点：</p>\n<ul>\n<li>DNS是多级解析的，每一级都会缓存该条域名的A记录，更新记录生效需要较长时间。</li>\n<li>不能按照服务器的处理能力来分配负载，DNS负载均衡采用的是简单的轮询算法，因此其负载均衡的效果不太好。</li>\n<li>为保证DNS数据即时更新，使地址能随机分配，一般需要将DNS刷新时间设置较小，但会导致DNS流量大增造成其他问题。</li>\n</ul>\n<h1 id=\"博客美化\"><a href=\"#博客美化\" class=\"headerlink\" title=\"博客美化\"></a>博客美化</h1><h2 id=\"代码块美化\"><a href=\"#代码块美化\" class=\"headerlink\" title=\"代码块美化\"></a>代码块美化</h2><p>自带的代码块显示没有高亮，也没有一键复制的功能。因此着手添加这两项功能。</p>\n<p>首先注意到hexo已经内部集成了highlight.js和prismjs。</p>"},{"title":"pip与conda换源","reprint":false,"date":"2022-02-14T03:10:52.000Z","updated":"2022-02-14T03:10:52.000Z","conver":null,"_content":"\n# conda与pip换源汇总\n\n<!--more-->\n\n## conda\n\n### linux\n\n修改`~/.condarc`\n\n```\nchannels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\nssl_verify: true\n```\n\n\n\n### windows\n\nwindows用户需先执行`conda config --set show_channel_urls yes`，生成`.condarc`文件，再进行修改\n\n## pip\n\n阿里云 http://mirrors.aliyun.com/pypi/simple/\n中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/\n豆瓣(douban) http://pypi.douban.com/simple/\n清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/\n中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/\n\n### linux\n\n**临时换源：**\n\npip后加-i，指定pip源\n\n**永久换源：**\n\n修改`~/.pip/pip.conf`\n\n```\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n```\n\n### windows\n\n在user目录新建pip目录，路径为`C:\\User\\xx\\pip\\pip.ini`\n\n```\n[global]\ntimeout = 6000\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\ntrusted-host = pypi.tuna.tsinghua.edu.cn\n```\n\n","source":"_posts/pip与conda换源.md","raw":"---\ntitle: pip与conda换源\nreprint: false\ndate: 2022-02-14 11:10:52\nupdated: 2022-02-14 11:10:52\nconver:\ncategories: 环境搭建\ntags:\n  - pip\n  - conda\n---\n\n# conda与pip换源汇总\n\n<!--more-->\n\n## conda\n\n### linux\n\n修改`~/.condarc`\n\n```\nchannels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\nssl_verify: true\n```\n\n\n\n### windows\n\nwindows用户需先执行`conda config --set show_channel_urls yes`，生成`.condarc`文件，再进行修改\n\n## pip\n\n阿里云 http://mirrors.aliyun.com/pypi/simple/\n中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/\n豆瓣(douban) http://pypi.douban.com/simple/\n清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/\n中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/\n\n### linux\n\n**临时换源：**\n\npip后加-i，指定pip源\n\n**永久换源：**\n\n修改`~/.pip/pip.conf`\n\n```\n[global]\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\n```\n\n### windows\n\n在user目录新建pip目录，路径为`C:\\User\\xx\\pip\\pip.ini`\n\n```\n[global]\ntimeout = 6000\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\ntrusted-host = pypi.tuna.tsinghua.edu.cn\n```\n\n","slug":"pip与conda换源","published":1,"_id":"ckzm4vwez000044wzgzri9all","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"conda与pip换源汇总\"><a href=\"#conda与pip换源汇总\" class=\"headerlink\" title=\"conda与pip换源汇总\"></a>conda与pip换源汇总</h1><span id=\"more\"></span>\n\n<h2 id=\"conda\"><a href=\"#conda\" class=\"headerlink\" title=\"conda\"></a>conda</h2><h3 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h3><p>修改<code>~/.condarc</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channels:</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class=\"line\">ssl_verify: true</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h3><p>windows用户需先执行<code>conda config --set show_channel_urls yes</code>，生成<code>.condarc</code>文件，再进行修改</p>\n<h2 id=\"pip\"><a href=\"#pip\" class=\"headerlink\" title=\"pip\"></a>pip</h2><p>阿里云 <a href=\"http://mirrors.aliyun.com/pypi/simple/\">http://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学 <a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>豆瓣(douban) <a href=\"http://pypi.douban.com/simple/\">http://pypi.douban.com/simple/</a><br>清华大学 <a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科学技术大学 <a href=\"http://pypi.mirrors.ustc.edu.cn/simple/\">http://pypi.mirrors.ustc.edu.cn/simple/</a></p>\n<h3 id=\"linux-1\"><a href=\"#linux-1\" class=\"headerlink\" title=\"linux\"></a>linux</h3><p><strong>临时换源：</strong></p>\n<p>pip后加-i，指定pip源</p>\n<p><strong>永久换源：</strong></p>\n<p>修改<code>~/.pip/pip.conf</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"windows-1\"><a href=\"#windows-1\" class=\"headerlink\" title=\"windows\"></a>windows</h3><p>在user目录新建pip目录，路径为<code>C:\\User\\xx\\pip\\pip.ini</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">timeout = 6000</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class=\"line\">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"conda与pip换源汇总\"><a href=\"#conda与pip换源汇总\" class=\"headerlink\" title=\"conda与pip换源汇总\"></a>conda与pip换源汇总</h1>","more":"<h2 id=\"conda\"><a href=\"#conda\" class=\"headerlink\" title=\"conda\"></a>conda</h2><h3 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h3><p>修改<code>~/.condarc</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channels:</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class=\"line\">ssl_verify: true</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h3><p>windows用户需先执行<code>conda config --set show_channel_urls yes</code>，生成<code>.condarc</code>文件，再进行修改</p>\n<h2 id=\"pip\"><a href=\"#pip\" class=\"headerlink\" title=\"pip\"></a>pip</h2><p>阿里云 <a href=\"http://mirrors.aliyun.com/pypi/simple/\">http://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学 <a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>豆瓣(douban) <a href=\"http://pypi.douban.com/simple/\">http://pypi.douban.com/simple/</a><br>清华大学 <a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科学技术大学 <a href=\"http://pypi.mirrors.ustc.edu.cn/simple/\">http://pypi.mirrors.ustc.edu.cn/simple/</a></p>\n<h3 id=\"linux-1\"><a href=\"#linux-1\" class=\"headerlink\" title=\"linux\"></a>linux</h3><p><strong>临时换源：</strong></p>\n<p>pip后加-i，指定pip源</p>\n<p><strong>永久换源：</strong></p>\n<p>修改<code>~/.pip/pip.conf</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"windows-1\"><a href=\"#windows-1\" class=\"headerlink\" title=\"windows\"></a>windows</h3><p>在user目录新建pip目录，路径为<code>C:\\User\\xx\\pip\\pip.ini</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">timeout = 6000</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class=\"line\">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>"},{"title":"31天JavaScript学习-第10天","reprint":false,"date":"2022-03-03T08:13:09.000Z","updated":"2022-03-03T08:13:09.000Z","conver":null,"_content":"\n# 函数表达式（二）——应用\n\n<!--more-->\n\n## 模仿块级作用域\n\nJS中没有块级作用域的概念。使用匿名函数可以用来模仿块级作用域。\n\n```js\n(function(){\n  // 块级作用域\n})();\n```\n\n该代码定义并立即调用了一个匿名函数，将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。\n\n## 私有变量\n\nJS中没有私有成员的概念，所有对象属性都是公有的。但在任何函数中定义的变量，都可以认为是私有变量。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链可以访问这些对象。就可以创建用于访问私有变量的公有方法。\n\n把有权访问私有变量和私有函数的公有方法成为特权方法。有两种在对象上创建特权方法的方式。\n\n**方式一：构造函数中定义特权方法**\n\n```js\nfunction Person(name) {\n  this.getName = function() {\n    return name;\n  };\n\n  this.setName = function(value) {\n    name = value;\n  };\n}\n\nvar person = new Person('Jack');\nconsole.log(person.getName()); // Jack\nperson.setName('Greg');\nconsole.log(person.getName()); // Greg\n```\n\n这种定义特权方法有一个缺点，就是只能使用构造函数模式。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法。\n\n**方式二：静态私有变量**\n\n通过在私有作用域中定义私有变量或函数，同样可以创建特权方法。\n\n```js\n(function () {\n  // 私有变量和私有函数\n  var name = '';\n\n  Person = function (value) {\n    name = value;\n  };\n\n  Person.prototype.getName = function () {\n    return name;\n  };\n  Person.prototype.setName = function (value) {\n    name = value;\n  };\n})();\n\nvar person = new Person('Jack');\nconsole.log(person.getName());\nperson.setName('Greg');\nconsole.log(person.getName());\n```\n\n","source":"_posts/31天JavaScript学习-第10天.md","raw":"---\ntitle: 31天JavaScript学习-第10天\nreprint: false\ndate: 2022-03-03 16:13:09\nupdated: 2022-03-03 16:13:09\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# 函数表达式（二）——应用\n\n<!--more-->\n\n## 模仿块级作用域\n\nJS中没有块级作用域的概念。使用匿名函数可以用来模仿块级作用域。\n\n```js\n(function(){\n  // 块级作用域\n})();\n```\n\n该代码定义并立即调用了一个匿名函数，将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。\n\n## 私有变量\n\nJS中没有私有成员的概念，所有对象属性都是公有的。但在任何函数中定义的变量，都可以认为是私有变量。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链可以访问这些对象。就可以创建用于访问私有变量的公有方法。\n\n把有权访问私有变量和私有函数的公有方法成为特权方法。有两种在对象上创建特权方法的方式。\n\n**方式一：构造函数中定义特权方法**\n\n```js\nfunction Person(name) {\n  this.getName = function() {\n    return name;\n  };\n\n  this.setName = function(value) {\n    name = value;\n  };\n}\n\nvar person = new Person('Jack');\nconsole.log(person.getName()); // Jack\nperson.setName('Greg');\nconsole.log(person.getName()); // Greg\n```\n\n这种定义特权方法有一个缺点，就是只能使用构造函数模式。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法。\n\n**方式二：静态私有变量**\n\n通过在私有作用域中定义私有变量或函数，同样可以创建特权方法。\n\n```js\n(function () {\n  // 私有变量和私有函数\n  var name = '';\n\n  Person = function (value) {\n    name = value;\n  };\n\n  Person.prototype.getName = function () {\n    return name;\n  };\n  Person.prototype.setName = function (value) {\n    name = value;\n  };\n})();\n\nvar person = new Person('Jack');\nconsole.log(person.getName());\nperson.setName('Greg');\nconsole.log(person.getName());\n```\n\n","slug":"31天JavaScript学习-第10天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl29q00007owz2es2au4l","content":"<h1 id=\"函数表达式（二）——应用\"><a href=\"#函数表达式（二）——应用\" class=\"headerlink\" title=\"函数表达式（二）——应用\"></a>函数表达式（二）——应用</h1><span id=\"more\"></span>\n\n<h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><p>JS中没有块级作用域的概念。使用匿名函数可以用来模仿块级作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 块级作用域</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>该代码定义并立即调用了一个匿名函数，将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。</p>\n<h2 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h2><p>JS中没有私有成员的概念，所有对象属性都是公有的。但在任何函数中定义的变量，都可以认为是私有变量。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链可以访问这些对象。就可以创建用于访问私有变量的公有方法。</p>\n<p>把有权访问私有变量和私有函数的公有方法成为特权方法。有两种在对象上创建特权方法的方式。</p>\n<p><strong>方式一：构造函数中定义特权方法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    name = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Jack&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">// Jack</span></span><br><span class=\"line\">person.setName(<span class=\"string\">&#x27;Greg&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">// Greg</span></span><br></pre></td></tr></table></figure>\n\n<p>这种定义特权方法有一个缺点，就是只能使用构造函数模式。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法。</p>\n<p><strong>方式二：静态私有变量</strong></p>\n<p>通过在私有作用域中定义私有变量或函数，同样可以创建特权方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量和私有函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    name = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Person.prototype.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    name = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Jack&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.getName());</span><br><span class=\"line\">person.setName(<span class=\"string\">&#x27;Greg&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.getName());</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"函数表达式（二）——应用\"><a href=\"#函数表达式（二）——应用\" class=\"headerlink\" title=\"函数表达式（二）——应用\"></a>函数表达式（二）——应用</h1>","more":"<h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><p>JS中没有块级作用域的概念。使用匿名函数可以用来模仿块级作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 块级作用域</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>该代码定义并立即调用了一个匿名函数，将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。</p>\n<h2 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h2><p>JS中没有私有成员的概念，所有对象属性都是公有的。但在任何函数中定义的变量，都可以认为是私有变量。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链可以访问这些对象。就可以创建用于访问私有变量的公有方法。</p>\n<p>把有权访问私有变量和私有函数的公有方法成为特权方法。有两种在对象上创建特权方法的方式。</p>\n<p><strong>方式一：构造函数中定义特权方法</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    name = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Jack&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">// Jack</span></span><br><span class=\"line\">person.setName(<span class=\"string\">&#x27;Greg&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">// Greg</span></span><br></pre></td></tr></table></figure>\n\n<p>这种定义特权方法有一个缺点，就是只能使用构造函数模式。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法。</p>\n<p><strong>方式二：静态私有变量</strong></p>\n<p>通过在私有作用域中定义私有变量或函数，同样可以创建特权方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量和私有函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    name = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Person.prototype.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    name = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Jack&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.getName());</span><br><span class=\"line\">person.setName(<span class=\"string\">&#x27;Greg&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.getName());</span><br></pre></td></tr></table></figure>"},{"title":"31天JavaScript学习-第11天","reprint":false,"date":"2022-03-04T08:04:08.000Z","updated":"2022-03-04T08:04:08.000Z","conver":null,"_content":"\n# BOM和客户端检测\n\n<!--more-->\n\n## BOM\n\n**BOM（Browser Object Model，浏览器对象模型）**，BOM可以操作浏览器部分功能的API。\n\n**常见的BOM对象**\n\n- **Window：**代表整个浏览器的窗口，同时 window 也是网页中的全局对象。\n- **Navigator：**代表当前浏览器的信息，通过该对象可以识别不同的浏览器。\n- **Location**：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。\n- **History：**代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。\n- **Screen：**代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。\n\n**注：**这些 BOM 对象都是作为 window 对象的属性保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 `window.location.href`，也可以直接使用 `location.href`，二者是等价的。\n\n### window对象\n\n在浏览器中，window对象有两种角色，它既是JS访问浏览器窗口的一个接口，又是ES规定的Global对象。\n\n如果页面中包含框架`<frame>`，则每个框架都有自己的window对象，并保存在frames集合中。每个window对象都有一个name属性，其中包含框架名称。\n\n**window对象常用的方法**\n\n| 方法            | 描述                |\n| --------------- | ------------------- |\n| window.moveTo   | 移动窗口到x, y      |\n| window.resizeTo | 调整窗口到w, h      |\n| window.open     | 导航到一个特定的url |\n| alert()         | 弹出警告            |\n| confirm()       | 弹出带确认的警告    |\n| prompt()        | 弹出输入提示框      |\n\n### navigator对象\n\nwindow.navigator 的一些属性可以获取客户端的一些信息。\n\n- userAgent：系统，浏览器)\n- platform：浏览器支持的系统，win/mac/linux\n\n### location对象\n\n`window.location`可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。\n\n**location对象的属性**\n\n- **href**：跳转\n- hash 返回url中#后面的内容，包含#\n- host 主机名，包括端口\n- hostname 主机名\n- pathname url中的路径部分\n- protocol 协议 一般是http、https\n- search 查询字符串\n\n**location对象的方法**\n\n- location.assign()：改变浏览器地址栏的地址，并记录到历史中\n\n设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。\n\n- location.replace()：替换浏览器地址栏的地址，不会记录到历史中\n- location.reload()：重新加载\n\n## 客户端检测\n\n","source":"_posts/31天JavaScript学习-第11天.md","raw":"---\ntitle: 31天JavaScript学习-第11天\nreprint: false\ndate: 2022-03-04 16:04:08\nupdated: 2022-03-04 16:04:08\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# BOM和客户端检测\n\n<!--more-->\n\n## BOM\n\n**BOM（Browser Object Model，浏览器对象模型）**，BOM可以操作浏览器部分功能的API。\n\n**常见的BOM对象**\n\n- **Window：**代表整个浏览器的窗口，同时 window 也是网页中的全局对象。\n- **Navigator：**代表当前浏览器的信息，通过该对象可以识别不同的浏览器。\n- **Location**：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。\n- **History：**代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。\n- **Screen：**代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。\n\n**注：**这些 BOM 对象都是作为 window 对象的属性保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 `window.location.href`，也可以直接使用 `location.href`，二者是等价的。\n\n### window对象\n\n在浏览器中，window对象有两种角色，它既是JS访问浏览器窗口的一个接口，又是ES规定的Global对象。\n\n如果页面中包含框架`<frame>`，则每个框架都有自己的window对象，并保存在frames集合中。每个window对象都有一个name属性，其中包含框架名称。\n\n**window对象常用的方法**\n\n| 方法            | 描述                |\n| --------------- | ------------------- |\n| window.moveTo   | 移动窗口到x, y      |\n| window.resizeTo | 调整窗口到w, h      |\n| window.open     | 导航到一个特定的url |\n| alert()         | 弹出警告            |\n| confirm()       | 弹出带确认的警告    |\n| prompt()        | 弹出输入提示框      |\n\n### navigator对象\n\nwindow.navigator 的一些属性可以获取客户端的一些信息。\n\n- userAgent：系统，浏览器)\n- platform：浏览器支持的系统，win/mac/linux\n\n### location对象\n\n`window.location`可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。\n\n**location对象的属性**\n\n- **href**：跳转\n- hash 返回url中#后面的内容，包含#\n- host 主机名，包括端口\n- hostname 主机名\n- pathname url中的路径部分\n- protocol 协议 一般是http、https\n- search 查询字符串\n\n**location对象的方法**\n\n- location.assign()：改变浏览器地址栏的地址，并记录到历史中\n\n设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。\n\n- location.replace()：替换浏览器地址栏的地址，不会记录到历史中\n- location.reload()：重新加载\n\n## 客户端检测\n\n","slug":"31天JavaScript学习-第11天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl29s00017owzhbhnfrl6","content":"<h1 id=\"BOM和客户端检测\"><a href=\"#BOM和客户端检测\" class=\"headerlink\" title=\"BOM和客户端检测\"></a>BOM和客户端检测</h1><span id=\"more\"></span>\n\n<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h2><p><strong>BOM（Browser Object Model，浏览器对象模型）</strong>，BOM可以操作浏览器部分功能的API。</p>\n<p><strong>常见的BOM对象</strong></p>\n<ul>\n<li><strong>Window：</strong>代表整个浏览器的窗口，同时 window 也是网页中的全局对象。</li>\n<li><strong>Navigator：</strong>代表当前浏览器的信息，通过该对象可以识别不同的浏览器。</li>\n<li><strong>Location</strong>：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。</li>\n<li><strong>History：</strong>代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。</li>\n<li><strong>Screen：</strong>代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。</li>\n</ul>\n<p><strong>注：</strong>这些 BOM 对象都是作为 window 对象的属性保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 <code>window.location.href</code>，也可以直接使用 <code>location.href</code>，二者是等价的。</p>\n<h3 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h3><p>在浏览器中，window对象有两种角色，它既是JS访问浏览器窗口的一个接口，又是ES规定的Global对象。</p>\n<p>如果页面中包含框架<code>&lt;frame&gt;</code>，则每个框架都有自己的window对象，并保存在frames集合中。每个window对象都有一个name属性，其中包含框架名称。</p>\n<p><strong>window对象常用的方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>window.moveTo</td>\n<td>移动窗口到x, y</td>\n</tr>\n<tr>\n<td>window.resizeTo</td>\n<td>调整窗口到w, h</td>\n</tr>\n<tr>\n<td>window.open</td>\n<td>导航到一个特定的url</td>\n</tr>\n<tr>\n<td>alert()</td>\n<td>弹出警告</td>\n</tr>\n<tr>\n<td>confirm()</td>\n<td>弹出带确认的警告</td>\n</tr>\n<tr>\n<td>prompt()</td>\n<td>弹出输入提示框</td>\n</tr>\n</tbody></table>\n<h3 id=\"navigator对象\"><a href=\"#navigator对象\" class=\"headerlink\" title=\"navigator对象\"></a>navigator对象</h3><p>window.navigator 的一些属性可以获取客户端的一些信息。</p>\n<ul>\n<li>userAgent：系统，浏览器)</li>\n<li>platform：浏览器支持的系统，win/mac/linux</li>\n</ul>\n<h3 id=\"location对象\"><a href=\"#location对象\" class=\"headerlink\" title=\"location对象\"></a>location对象</h3><p><code>window.location</code>可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。</p>\n<p><strong>location对象的属性</strong></p>\n<ul>\n<li><strong>href</strong>：跳转</li>\n<li>hash 返回url中#后面的内容，包含#</li>\n<li>host 主机名，包括端口</li>\n<li>hostname 主机名</li>\n<li>pathname url中的路径部分</li>\n<li>protocol 协议 一般是http、https</li>\n<li>search 查询字符串</li>\n</ul>\n<p><strong>location对象的方法</strong></p>\n<ul>\n<li>location.assign()：改变浏览器地址栏的地址，并记录到历史中</li>\n</ul>\n<p>设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。</p>\n<ul>\n<li>location.replace()：替换浏览器地址栏的地址，不会记录到历史中</li>\n<li>location.reload()：重新加载</li>\n</ul>\n<h2 id=\"客户端检测\"><a href=\"#客户端检测\" class=\"headerlink\" title=\"客户端检测\"></a>客户端检测</h2>","site":{"data":{}},"excerpt":"<h1 id=\"BOM和客户端检测\"><a href=\"#BOM和客户端检测\" class=\"headerlink\" title=\"BOM和客户端检测\"></a>BOM和客户端检测</h1>","more":"<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h2><p><strong>BOM（Browser Object Model，浏览器对象模型）</strong>，BOM可以操作浏览器部分功能的API。</p>\n<p><strong>常见的BOM对象</strong></p>\n<ul>\n<li><strong>Window：</strong>代表整个浏览器的窗口，同时 window 也是网页中的全局对象。</li>\n<li><strong>Navigator：</strong>代表当前浏览器的信息，通过该对象可以识别不同的浏览器。</li>\n<li><strong>Location</strong>：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。</li>\n<li><strong>History：</strong>代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。</li>\n<li><strong>Screen：</strong>代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。</li>\n</ul>\n<p><strong>注：</strong>这些 BOM 对象都是作为 window 对象的属性保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 <code>window.location.href</code>，也可以直接使用 <code>location.href</code>，二者是等价的。</p>\n<h3 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h3><p>在浏览器中，window对象有两种角色，它既是JS访问浏览器窗口的一个接口，又是ES规定的Global对象。</p>\n<p>如果页面中包含框架<code>&lt;frame&gt;</code>，则每个框架都有自己的window对象，并保存在frames集合中。每个window对象都有一个name属性，其中包含框架名称。</p>\n<p><strong>window对象常用的方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>window.moveTo</td>\n<td>移动窗口到x, y</td>\n</tr>\n<tr>\n<td>window.resizeTo</td>\n<td>调整窗口到w, h</td>\n</tr>\n<tr>\n<td>window.open</td>\n<td>导航到一个特定的url</td>\n</tr>\n<tr>\n<td>alert()</td>\n<td>弹出警告</td>\n</tr>\n<tr>\n<td>confirm()</td>\n<td>弹出带确认的警告</td>\n</tr>\n<tr>\n<td>prompt()</td>\n<td>弹出输入提示框</td>\n</tr>\n</tbody></table>\n<h3 id=\"navigator对象\"><a href=\"#navigator对象\" class=\"headerlink\" title=\"navigator对象\"></a>navigator对象</h3><p>window.navigator 的一些属性可以获取客户端的一些信息。</p>\n<ul>\n<li>userAgent：系统，浏览器)</li>\n<li>platform：浏览器支持的系统，win/mac/linux</li>\n</ul>\n<h3 id=\"location对象\"><a href=\"#location对象\" class=\"headerlink\" title=\"location对象\"></a>location对象</h3><p><code>window.location</code>可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。</p>\n<p><strong>location对象的属性</strong></p>\n<ul>\n<li><strong>href</strong>：跳转</li>\n<li>hash 返回url中#后面的内容，包含#</li>\n<li>host 主机名，包括端口</li>\n<li>hostname 主机名</li>\n<li>pathname url中的路径部分</li>\n<li>protocol 协议 一般是http、https</li>\n<li>search 查询字符串</li>\n</ul>\n<p><strong>location对象的方法</strong></p>\n<ul>\n<li>location.assign()：改变浏览器地址栏的地址，并记录到历史中</li>\n</ul>\n<p>设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。</p>\n<ul>\n<li>location.replace()：替换浏览器地址栏的地址，不会记录到历史中</li>\n<li>location.reload()：重新加载</li>\n</ul>\n<h2 id=\"客户端检测\"><a href=\"#客户端检测\" class=\"headerlink\" title=\"客户端检测\"></a>客户端检测</h2>"},{"title":"31天JavaScript学习-第13天","reprint":false,"date":"2022-03-06T08:48:28.000Z","updated":"2022-03-06T08:48:28.000Z","conver":null,"_content":"\n# 事件\n\n<!--more-->\n\nJS与HTML之间的交互是通过**事件**实现的。\n\n**事件的三要素：事件源、事件、事件驱动程序**。\n\n## 事件流\n\n事件流是描述从页面中接收事件的顺序。IE的事件流是**事件流冒泡**，Netscape的事件流是**事件捕获流**。\n\n### 事件流冒泡\n\n事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。\n\n```html\n<!DOCTYPE html>\n<head>\n  <title>Document</title>\n</head>\n<body>\n  <div id=\"myDiv\">Click Me</div>\n</body>\n</html>\n```\n\n如果你点击了页面中的`<div>`元素。那么这个click事件会按照如下的顺序传播：\n\n1. `<div>`\n2. `<body>`\n3. `<html>`\n4. document\n\n所有的现代浏览器都支持事件冒泡，Firfox、Chrome等会将事件一直冒泡到window对象。\n\n### 事件捕获流\n\n事件捕获流的顺序与事件冒泡流相反，不太具体的节点应该更早接收到事件。其用意时在事件达到预定目标之前捕获它。\n\n### DOM事件流\n\n**DOM2级事件**规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。\n\n以前面的点击div元素为例。\n\n1. 在事件捕获阶段，事件从document到`<html>`再到`<body>`就停止了。\n2. 下一个阶段时”处于目标阶段”，事件在`<div>`上发生，并在事件处理中被看成冒泡阶段的一部分。\n3. 冒泡阶段发生，事件又传播回文档。\n\n## 事件处理程序\n\n事件是用户或浏览器自身执行的某种动作。而响应某个事件的函数就叫做事件处理程序。\n\n### HTML事件处理程序\n\n```html\n<input type='button' value='Click Me' onclick='alert('Clicked')' />\n```\n\n```html\n<input type='button' value='Click Me' onclick='showMessage()' />\n<script>\n    function showMessage(){\n      alert(\"hello world\")\n    }\n </script>\n```\n\n### DOM0级事件处理程序\n\n```js\nvar btn = document.getElementById(\"myBtn\");\nbtn.onclick = function() {\n\talert(\"Clicked\");\n};\n```\n\n使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素内部的作用域中运行的。\n\n缺点：不能同时对一个DOM绑定多个相同事件。\n\n### DOM2级事件处理程序\n\n- addEventListener()\n- removeEventListener()\n\n所有的DOM节点都包含这两个方法，并都接收三个参数：\n\n- 要处理的事件名\n- 作为事件处理程序的函数\n- 一个布尔值：true，在捕获阶段调用事件处理程序；false，在冒泡阶段调用事件处理程序。\n\n```js\nvar btn = document.getElementById(\"myBtn\");\nbtn.addEventListener(\"click\", function(){\n    alert(\"this.id\");\n}, false);\nbtn.addEventListener(\"click\", function(){\n    alert(\"Hello world\");\n}, false);\n```\n\nDOM2级事件处理程序可以添加多个事件处理程序。\n\n通过`addEventListener()`添加的事件处理程序只能通过`removeEventListener()`来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着由于上面例子中传入的是匿名函数，因此无法在移除时添加相同的参数。正确例子如下：\n\n```js\nvar btn = document.getElementById(\"myBtn\");\nvar handler = function(){\n    alert(\"this.id\");\n};\nbtn.addEventListener(\"click\", handler, false);\nbtn.removeEventListener(\"click\", handler, false);\n```\n\n大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段。\n\n## 事件对象\n\n当触发DOM上的某个事件时，会产生一个事件对象event。浏览器每次都会将这个事件event作为实参传进之前的响应函数。\n\n```js\nvar btn = document.getElementById(\"myBtn\");\nbtn.onclick = function(event) {\n\talert(event.type);\n};\nbtn.addEventListener(\"click\", function(event){\n    alert(\"event.type\");\n}, false);\n```\n\n## 事件类型\n\n### UI事件\n\n**load事件**\n\n当页面完全加载完后（包括所有图像、JS文件、CSS文件等外部资源），就会触发window的load事件。\n\n有两种定义onload事件处理程序的方式。\n\n```js\nEventUtil.addHandler(window, \"load\", function(event){\n\talert(\"loaded\");\n});\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <title>Document</title>\n</head>\n<body onload=\"alert('loaded')\">\n    \n</body>\n</html>\n```\n\n一般来说，在window上面发生的任何事件都可以在`<body>`元素中通过相应的特性来指定，因为在HTML中无法访问window元素。\n\n在图像上也可以触发onload事件。\n\n**unload事件**\n\n当文档被完全卸载后触发，只要用户从一个页面切换到另一个页面，就会发生unload事件。\n\n**resize事件**\n\n当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。可以通过JS或`<body>`元素中的onresize特性来指定事件处理程序。\n\n**scroll事件**\n\n当浏览器窗口滚动时触发。\n\n### 焦点事件\n\n焦点事件会在页面元素获得或失去焦点时触发。有以下6个焦点事件：\n\n- blur：在元素失去焦点时触发。这个事件不会冒泡。\n- focus：在元素获得焦点时触发。这个事件不会冒泡。\n- DOMFocusIn：在元素获得焦点时触发。只有Opera支持该事件。DOM3已弃用。\n- DOMFocusOut：在元素失去焦点时触发。只有Opera支持该事件。DOM3已弃用。\n- focusing：在元素失去焦点时触发。这个事件会冒泡。\n- focusout：在元素获得焦点时触发。这个事件会冒泡。\n\n## 事件委托\n\n事件委托，就是把一个元素相应事件的函数委托到另一个元素。\n\n例如有一个无序列表ul，列表之中有大量的`<a>`标签，当鼠标移到`<a>`标签上的时候，需要触发相应的处理事件。通常的写法是为每个`<a>`标签都绑定类似onMouseOver的事件监听。\n\n```js\n    window.onload = function(){\n        var parentNode = document.getElementById(\"parent-list\");\n        var aNodes = parentNode.getElementByTagName(\"a\");\n        for(var i=0, l = aNodes.length; i < l; i++){\n\n            aNodes[i].onclick = function() {\n                console.log('我是超链接 a 的单击相应函数');\n            }\n        }\n    }\n```\n\n但是这种做法过于消耗性能。**我们希望，只绑定一次事件，即可应用到多个元素上**，即使元素是后来添加的。\n\n因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 `ul` 上，然后在执行事件函数的时候再去匹配判断目标元素。如下：\n\n```html\n<ul id=\"parent-list\">\n    <li><a href=\"javascript:;\" class=\"my_link\">超链接一</a></li>\n    <li><a href=\"javascript:;\" class=\"my_link\">超链接二</a></li>\n    <li><a href=\"javascript:;\" class=\"my_link\">超链接三</a></li>\n</ul>\n\n<script>\n\twindow.onload = function(){\n        // 获取父节点，并为它绑定click单击事件。 false 表示事件在冒泡阶段触发（默认）\n        document.getElementById('parent-list').addEventListener('click', function(event){\n            event = event || window.event;\n            \n             // e.target 表示：触发事件的对象\n             //如果触发事件的对象是我们期望的元素，则执行否则不执行\n            if (event.target && event.target.className == 'my_link') {\n\t\t\t\tconsole.log('我是ul的单击响应函数');\n            }\n        }, false);\n    };\n</script>\n```\n\n为父节点注册click事件，当子节点被点击时，click事件会向父节点冒泡。父节点捕获到事件后，通过判断`event.target`拿到被点击的子节点的相应信息，并做处理。\n","source":"_posts/31天JavaScript学习-第13天.md","raw":"---\ntitle: 31天JavaScript学习-第13天\nreprint: false\ndate: 2022-03-06 16:48:28\nupdated: 2022-03-06 16:48:28\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# 事件\n\n<!--more-->\n\nJS与HTML之间的交互是通过**事件**实现的。\n\n**事件的三要素：事件源、事件、事件驱动程序**。\n\n## 事件流\n\n事件流是描述从页面中接收事件的顺序。IE的事件流是**事件流冒泡**，Netscape的事件流是**事件捕获流**。\n\n### 事件流冒泡\n\n事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。\n\n```html\n<!DOCTYPE html>\n<head>\n  <title>Document</title>\n</head>\n<body>\n  <div id=\"myDiv\">Click Me</div>\n</body>\n</html>\n```\n\n如果你点击了页面中的`<div>`元素。那么这个click事件会按照如下的顺序传播：\n\n1. `<div>`\n2. `<body>`\n3. `<html>`\n4. document\n\n所有的现代浏览器都支持事件冒泡，Firfox、Chrome等会将事件一直冒泡到window对象。\n\n### 事件捕获流\n\n事件捕获流的顺序与事件冒泡流相反，不太具体的节点应该更早接收到事件。其用意时在事件达到预定目标之前捕获它。\n\n### DOM事件流\n\n**DOM2级事件**规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。\n\n以前面的点击div元素为例。\n\n1. 在事件捕获阶段，事件从document到`<html>`再到`<body>`就停止了。\n2. 下一个阶段时”处于目标阶段”，事件在`<div>`上发生，并在事件处理中被看成冒泡阶段的一部分。\n3. 冒泡阶段发生，事件又传播回文档。\n\n## 事件处理程序\n\n事件是用户或浏览器自身执行的某种动作。而响应某个事件的函数就叫做事件处理程序。\n\n### HTML事件处理程序\n\n```html\n<input type='button' value='Click Me' onclick='alert('Clicked')' />\n```\n\n```html\n<input type='button' value='Click Me' onclick='showMessage()' />\n<script>\n    function showMessage(){\n      alert(\"hello world\")\n    }\n </script>\n```\n\n### DOM0级事件处理程序\n\n```js\nvar btn = document.getElementById(\"myBtn\");\nbtn.onclick = function() {\n\talert(\"Clicked\");\n};\n```\n\n使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素内部的作用域中运行的。\n\n缺点：不能同时对一个DOM绑定多个相同事件。\n\n### DOM2级事件处理程序\n\n- addEventListener()\n- removeEventListener()\n\n所有的DOM节点都包含这两个方法，并都接收三个参数：\n\n- 要处理的事件名\n- 作为事件处理程序的函数\n- 一个布尔值：true，在捕获阶段调用事件处理程序；false，在冒泡阶段调用事件处理程序。\n\n```js\nvar btn = document.getElementById(\"myBtn\");\nbtn.addEventListener(\"click\", function(){\n    alert(\"this.id\");\n}, false);\nbtn.addEventListener(\"click\", function(){\n    alert(\"Hello world\");\n}, false);\n```\n\nDOM2级事件处理程序可以添加多个事件处理程序。\n\n通过`addEventListener()`添加的事件处理程序只能通过`removeEventListener()`来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着由于上面例子中传入的是匿名函数，因此无法在移除时添加相同的参数。正确例子如下：\n\n```js\nvar btn = document.getElementById(\"myBtn\");\nvar handler = function(){\n    alert(\"this.id\");\n};\nbtn.addEventListener(\"click\", handler, false);\nbtn.removeEventListener(\"click\", handler, false);\n```\n\n大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段。\n\n## 事件对象\n\n当触发DOM上的某个事件时，会产生一个事件对象event。浏览器每次都会将这个事件event作为实参传进之前的响应函数。\n\n```js\nvar btn = document.getElementById(\"myBtn\");\nbtn.onclick = function(event) {\n\talert(event.type);\n};\nbtn.addEventListener(\"click\", function(event){\n    alert(\"event.type\");\n}, false);\n```\n\n## 事件类型\n\n### UI事件\n\n**load事件**\n\n当页面完全加载完后（包括所有图像、JS文件、CSS文件等外部资源），就会触发window的load事件。\n\n有两种定义onload事件处理程序的方式。\n\n```js\nEventUtil.addHandler(window, \"load\", function(event){\n\talert(\"loaded\");\n});\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <title>Document</title>\n</head>\n<body onload=\"alert('loaded')\">\n    \n</body>\n</html>\n```\n\n一般来说，在window上面发生的任何事件都可以在`<body>`元素中通过相应的特性来指定，因为在HTML中无法访问window元素。\n\n在图像上也可以触发onload事件。\n\n**unload事件**\n\n当文档被完全卸载后触发，只要用户从一个页面切换到另一个页面，就会发生unload事件。\n\n**resize事件**\n\n当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。可以通过JS或`<body>`元素中的onresize特性来指定事件处理程序。\n\n**scroll事件**\n\n当浏览器窗口滚动时触发。\n\n### 焦点事件\n\n焦点事件会在页面元素获得或失去焦点时触发。有以下6个焦点事件：\n\n- blur：在元素失去焦点时触发。这个事件不会冒泡。\n- focus：在元素获得焦点时触发。这个事件不会冒泡。\n- DOMFocusIn：在元素获得焦点时触发。只有Opera支持该事件。DOM3已弃用。\n- DOMFocusOut：在元素失去焦点时触发。只有Opera支持该事件。DOM3已弃用。\n- focusing：在元素失去焦点时触发。这个事件会冒泡。\n- focusout：在元素获得焦点时触发。这个事件会冒泡。\n\n## 事件委托\n\n事件委托，就是把一个元素相应事件的函数委托到另一个元素。\n\n例如有一个无序列表ul，列表之中有大量的`<a>`标签，当鼠标移到`<a>`标签上的时候，需要触发相应的处理事件。通常的写法是为每个`<a>`标签都绑定类似onMouseOver的事件监听。\n\n```js\n    window.onload = function(){\n        var parentNode = document.getElementById(\"parent-list\");\n        var aNodes = parentNode.getElementByTagName(\"a\");\n        for(var i=0, l = aNodes.length; i < l; i++){\n\n            aNodes[i].onclick = function() {\n                console.log('我是超链接 a 的单击相应函数');\n            }\n        }\n    }\n```\n\n但是这种做法过于消耗性能。**我们希望，只绑定一次事件，即可应用到多个元素上**，即使元素是后来添加的。\n\n因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 `ul` 上，然后在执行事件函数的时候再去匹配判断目标元素。如下：\n\n```html\n<ul id=\"parent-list\">\n    <li><a href=\"javascript:;\" class=\"my_link\">超链接一</a></li>\n    <li><a href=\"javascript:;\" class=\"my_link\">超链接二</a></li>\n    <li><a href=\"javascript:;\" class=\"my_link\">超链接三</a></li>\n</ul>\n\n<script>\n\twindow.onload = function(){\n        // 获取父节点，并为它绑定click单击事件。 false 表示事件在冒泡阶段触发（默认）\n        document.getElementById('parent-list').addEventListener('click', function(event){\n            event = event || window.event;\n            \n             // e.target 表示：触发事件的对象\n             //如果触发事件的对象是我们期望的元素，则执行否则不执行\n            if (event.target && event.target.className == 'my_link') {\n\t\t\t\tconsole.log('我是ul的单击响应函数');\n            }\n        }, false);\n    };\n</script>\n```\n\n为父节点注册click事件，当子节点被点击时，click事件会向父节点冒泡。父节点捕获到事件后，通过判断`event.target`拿到被点击的子节点的相应信息，并做处理。\n","slug":"31天JavaScript学习-第13天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl29v00047owze8bzelbf","content":"<h1 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h1><span id=\"more\"></span>\n\n<p>JS与HTML之间的交互是通过<strong>事件</strong>实现的。</p>\n<p><strong>事件的三要素：事件源、事件、事件驱动程序</strong>。</p>\n<h2 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h2><p>事件流是描述从页面中接收事件的顺序。IE的事件流是<strong>事件流冒泡</strong>，Netscape的事件流是<strong>事件捕获流</strong>。</p>\n<h3 id=\"事件流冒泡\"><a href=\"#事件流冒泡\" class=\"headerlink\" title=\"事件流冒泡\"></a>事件流冒泡</h3><p>事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myDiv&quot;</span>&gt;</span>Click Me<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你点击了页面中的<code>&lt;div&gt;</code>元素。那么这个click事件会按照如下的顺序传播：</p>\n<ol>\n<li><code>&lt;div&gt;</code></li>\n<li><code>&lt;body&gt;</code></li>\n<li><code>&lt;html&gt;</code></li>\n<li>document</li>\n</ol>\n<p>所有的现代浏览器都支持事件冒泡，Firfox、Chrome等会将事件一直冒泡到window对象。</p>\n<h3 id=\"事件捕获流\"><a href=\"#事件捕获流\" class=\"headerlink\" title=\"事件捕获流\"></a>事件捕获流</h3><p>事件捕获流的顺序与事件冒泡流相反，不太具体的节点应该更早接收到事件。其用意时在事件达到预定目标之前捕获它。</p>\n<h3 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h3><p><strong>DOM2级事件</strong>规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。</p>\n<p>以前面的点击div元素为例。</p>\n<ol>\n<li>在事件捕获阶段，事件从document到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>就停止了。</li>\n<li>下一个阶段时”处于目标阶段”，事件在<code>&lt;div&gt;</code>上发生，并在事件处理中被看成冒泡阶段的一部分。</li>\n<li>冒泡阶段发生，事件又传播回文档。</li>\n</ol>\n<h2 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h2><p>事件是用户或浏览器自身执行的某种动作。而响应某个事件的函数就叫做事件处理程序。</p>\n<h3 id=\"HTML事件处理程序\"><a href=\"#HTML事件处理程序\" class=\"headerlink\" title=\"HTML事件处理程序\"></a>HTML事件处理程序</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;button&#x27;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;Click Me&#x27;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&#x27;alert(&#x27;</span><span class=\"attr\">Clicked</span>&#x27;)&#x27; /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;button&#x27;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;Click Me&#x27;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&#x27;showMessage()&#x27;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showMessage</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      alert(<span class=\"string\">&quot;hello world&quot;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"> </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DOM0级事件处理程序\"><a href=\"#DOM0级事件处理程序\" class=\"headerlink\" title=\"DOM0级事件处理程序\"></a>DOM0级事件处理程序</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myBtn&quot;</span>);</span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">&quot;Clicked&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素内部的作用域中运行的。</p>\n<p>缺点：不能同时对一个DOM绑定多个相同事件。</p>\n<h3 id=\"DOM2级事件处理程序\"><a href=\"#DOM2级事件处理程序\" class=\"headerlink\" title=\"DOM2级事件处理程序\"></a>DOM2级事件处理程序</h3><ul>\n<li>addEventListener()</li>\n<li>removeEventListener()</li>\n</ul>\n<p>所有的DOM节点都包含这两个方法，并都接收三个参数：</p>\n<ul>\n<li>要处理的事件名</li>\n<li>作为事件处理程序的函数</li>\n<li>一个布尔值：true，在捕获阶段调用事件处理程序；false，在冒泡阶段调用事件处理程序。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myBtn&quot;</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;this.id&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;Hello world&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>DOM2级事件处理程序可以添加多个事件处理程序。</p>\n<p>通过<code>addEventListener()</code>添加的事件处理程序只能通过<code>removeEventListener()</code>来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着由于上面例子中传入的是匿名函数，因此无法在移除时添加相同的参数。正确例子如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myBtn&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;this.id&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">btn.removeEventListener(<span class=\"string\">&quot;click&quot;</span>, handler, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段。</p>\n<h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><p>当触发DOM上的某个事件时，会产生一个事件对象event。浏览器每次都会将这个事件event作为实参传进之前的响应函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myBtn&quot;</span>);</span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\talert(event.type);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;event.type&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h2><h3 id=\"UI事件\"><a href=\"#UI事件\" class=\"headerlink\" title=\"UI事件\"></a>UI事件</h3><p><strong>load事件</strong></p>\n<p>当页面完全加载完后（包括所有图像、JS文件、CSS文件等外部资源），就会触发window的load事件。</p>\n<p>有两种定义onload事件处理程序的方式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventUtil.addHandler(<span class=\"built_in\">window</span>, <span class=\"string\">&quot;load&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">&quot;loaded&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span>=<span class=\"string\">&quot;alert(&#x27;loaded&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>一般来说，在window上面发生的任何事件都可以在<code>&lt;body&gt;</code>元素中通过相应的特性来指定，因为在HTML中无法访问window元素。</p>\n<p>在图像上也可以触发onload事件。</p>\n<p><strong>unload事件</strong></p>\n<p>当文档被完全卸载后触发，只要用户从一个页面切换到另一个页面，就会发生unload事件。</p>\n<p><strong>resize事件</strong></p>\n<p>当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。可以通过JS或<code>&lt;body&gt;</code>元素中的onresize特性来指定事件处理程序。</p>\n<p><strong>scroll事件</strong></p>\n<p>当浏览器窗口滚动时触发。</p>\n<h3 id=\"焦点事件\"><a href=\"#焦点事件\" class=\"headerlink\" title=\"焦点事件\"></a>焦点事件</h3><p>焦点事件会在页面元素获得或失去焦点时触发。有以下6个焦点事件：</p>\n<ul>\n<li>blur：在元素失去焦点时触发。这个事件不会冒泡。</li>\n<li>focus：在元素获得焦点时触发。这个事件不会冒泡。</li>\n<li>DOMFocusIn：在元素获得焦点时触发。只有Opera支持该事件。DOM3已弃用。</li>\n<li>DOMFocusOut：在元素失去焦点时触发。只有Opera支持该事件。DOM3已弃用。</li>\n<li>focusing：在元素失去焦点时触发。这个事件会冒泡。</li>\n<li>focusout：在元素获得焦点时触发。这个事件会冒泡。</li>\n</ul>\n<h2 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h2><p>事件委托，就是把一个元素相应事件的函数委托到另一个元素。</p>\n<p>例如有一个无序列表ul，列表之中有大量的<code>&lt;a&gt;</code>标签，当鼠标移到<code>&lt;a&gt;</code>标签上的时候，需要触发相应的处理事件。通常的写法是为每个<code>&lt;a&gt;</code>标签都绑定类似onMouseOver的事件监听。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parentNode = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;parent-list&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> aNodes = parentNode.getElementByTagName(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>, l = aNodes.length; i &lt; l; i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        aNodes[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是超链接 a 的单击相应函数&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这种做法过于消耗性能。<strong>我们希望，只绑定一次事件，即可应用到多个元素上</strong>，即使元素是后来添加的。</p>\n<p>因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 <code>ul</code> 上，然后在执行事件函数的时候再去匹配判断目标元素。如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;parent-list&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;my_link&quot;</span>&gt;</span>超链接一<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;my_link&quot;</span>&gt;</span>超链接二<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;my_link&quot;</span>&gt;</span>超链接三<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 获取父节点，并为它绑定click单击事件。 false 表示事件在冒泡阶段触发（默认）</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;parent-list&#x27;</span>).addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            event = event || <span class=\"built_in\">window</span>.event;</span></span><br><span class=\"line\"><span class=\"javascript\">            </span></span><br><span class=\"line\"><span class=\"javascript\">             <span class=\"comment\">// e.target 表示：触发事件的对象</span></span></span><br><span class=\"line\"><span class=\"javascript\">             <span class=\"comment\">//如果触发事件的对象是我们期望的元素，则执行否则不执行</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (event.target &amp;&amp; event.target.className == <span class=\"string\">&#x27;my_link&#x27;</span>) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是ul的单击响应函数&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        &#125;, <span class=\"literal\">false</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>为父节点注册click事件，当子节点被点击时，click事件会向父节点冒泡。父节点捕获到事件后，通过判断<code>event.target</code>拿到被点击的子节点的相应信息，并做处理。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h1>","more":"<p>JS与HTML之间的交互是通过<strong>事件</strong>实现的。</p>\n<p><strong>事件的三要素：事件源、事件、事件驱动程序</strong>。</p>\n<h2 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h2><p>事件流是描述从页面中接收事件的顺序。IE的事件流是<strong>事件流冒泡</strong>，Netscape的事件流是<strong>事件捕获流</strong>。</p>\n<h3 id=\"事件流冒泡\"><a href=\"#事件流冒泡\" class=\"headerlink\" title=\"事件流冒泡\"></a>事件流冒泡</h3><p>事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myDiv&quot;</span>&gt;</span>Click Me<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果你点击了页面中的<code>&lt;div&gt;</code>元素。那么这个click事件会按照如下的顺序传播：</p>\n<ol>\n<li><code>&lt;div&gt;</code></li>\n<li><code>&lt;body&gt;</code></li>\n<li><code>&lt;html&gt;</code></li>\n<li>document</li>\n</ol>\n<p>所有的现代浏览器都支持事件冒泡，Firfox、Chrome等会将事件一直冒泡到window对象。</p>\n<h3 id=\"事件捕获流\"><a href=\"#事件捕获流\" class=\"headerlink\" title=\"事件捕获流\"></a>事件捕获流</h3><p>事件捕获流的顺序与事件冒泡流相反，不太具体的节点应该更早接收到事件。其用意时在事件达到预定目标之前捕获它。</p>\n<h3 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h3><p><strong>DOM2级事件</strong>规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。</p>\n<p>以前面的点击div元素为例。</p>\n<ol>\n<li>在事件捕获阶段，事件从document到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>就停止了。</li>\n<li>下一个阶段时”处于目标阶段”，事件在<code>&lt;div&gt;</code>上发生，并在事件处理中被看成冒泡阶段的一部分。</li>\n<li>冒泡阶段发生，事件又传播回文档。</li>\n</ol>\n<h2 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h2><p>事件是用户或浏览器自身执行的某种动作。而响应某个事件的函数就叫做事件处理程序。</p>\n<h3 id=\"HTML事件处理程序\"><a href=\"#HTML事件处理程序\" class=\"headerlink\" title=\"HTML事件处理程序\"></a>HTML事件处理程序</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;button&#x27;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;Click Me&#x27;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&#x27;alert(&#x27;</span><span class=\"attr\">Clicked</span>&#x27;)&#x27; /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;button&#x27;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;Click Me&#x27;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&#x27;showMessage()&#x27;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showMessage</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      alert(<span class=\"string\">&quot;hello world&quot;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"> </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DOM0级事件处理程序\"><a href=\"#DOM0级事件处理程序\" class=\"headerlink\" title=\"DOM0级事件处理程序\"></a>DOM0级事件处理程序</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myBtn&quot;</span>);</span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">&quot;Clicked&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素内部的作用域中运行的。</p>\n<p>缺点：不能同时对一个DOM绑定多个相同事件。</p>\n<h3 id=\"DOM2级事件处理程序\"><a href=\"#DOM2级事件处理程序\" class=\"headerlink\" title=\"DOM2级事件处理程序\"></a>DOM2级事件处理程序</h3><ul>\n<li>addEventListener()</li>\n<li>removeEventListener()</li>\n</ul>\n<p>所有的DOM节点都包含这两个方法，并都接收三个参数：</p>\n<ul>\n<li>要处理的事件名</li>\n<li>作为事件处理程序的函数</li>\n<li>一个布尔值：true，在捕获阶段调用事件处理程序；false，在冒泡阶段调用事件处理程序。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myBtn&quot;</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;this.id&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;Hello world&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>DOM2级事件处理程序可以添加多个事件处理程序。</p>\n<p>通过<code>addEventListener()</code>添加的事件处理程序只能通过<code>removeEventListener()</code>来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着由于上面例子中传入的是匿名函数，因此无法在移除时添加相同的参数。正确例子如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myBtn&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;this.id&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">btn.removeEventListener(<span class=\"string\">&quot;click&quot;</span>, handler, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段。</p>\n<h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><p>当触发DOM上的某个事件时，会产生一个事件对象event。浏览器每次都会将这个事件event作为实参传进之前的响应函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myBtn&quot;</span>);</span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">\talert(event.type);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;event.type&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h2><h3 id=\"UI事件\"><a href=\"#UI事件\" class=\"headerlink\" title=\"UI事件\"></a>UI事件</h3><p><strong>load事件</strong></p>\n<p>当页面完全加载完后（包括所有图像、JS文件、CSS文件等外部资源），就会触发window的load事件。</p>\n<p>有两种定义onload事件处理程序的方式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventUtil.addHandler(<span class=\"built_in\">window</span>, <span class=\"string\">&quot;load&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">&quot;loaded&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span>=<span class=\"string\">&quot;alert(&#x27;loaded&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>一般来说，在window上面发生的任何事件都可以在<code>&lt;body&gt;</code>元素中通过相应的特性来指定，因为在HTML中无法访问window元素。</p>\n<p>在图像上也可以触发onload事件。</p>\n<p><strong>unload事件</strong></p>\n<p>当文档被完全卸载后触发，只要用户从一个页面切换到另一个页面，就会发生unload事件。</p>\n<p><strong>resize事件</strong></p>\n<p>当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。可以通过JS或<code>&lt;body&gt;</code>元素中的onresize特性来指定事件处理程序。</p>\n<p><strong>scroll事件</strong></p>\n<p>当浏览器窗口滚动时触发。</p>\n<h3 id=\"焦点事件\"><a href=\"#焦点事件\" class=\"headerlink\" title=\"焦点事件\"></a>焦点事件</h3><p>焦点事件会在页面元素获得或失去焦点时触发。有以下6个焦点事件：</p>\n<ul>\n<li>blur：在元素失去焦点时触发。这个事件不会冒泡。</li>\n<li>focus：在元素获得焦点时触发。这个事件不会冒泡。</li>\n<li>DOMFocusIn：在元素获得焦点时触发。只有Opera支持该事件。DOM3已弃用。</li>\n<li>DOMFocusOut：在元素失去焦点时触发。只有Opera支持该事件。DOM3已弃用。</li>\n<li>focusing：在元素失去焦点时触发。这个事件会冒泡。</li>\n<li>focusout：在元素获得焦点时触发。这个事件会冒泡。</li>\n</ul>\n<h2 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h2><p>事件委托，就是把一个元素相应事件的函数委托到另一个元素。</p>\n<p>例如有一个无序列表ul，列表之中有大量的<code>&lt;a&gt;</code>标签，当鼠标移到<code>&lt;a&gt;</code>标签上的时候，需要触发相应的处理事件。通常的写法是为每个<code>&lt;a&gt;</code>标签都绑定类似onMouseOver的事件监听。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parentNode = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;parent-list&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> aNodes = parentNode.getElementByTagName(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>, l = aNodes.length; i &lt; l; i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        aNodes[i].onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是超链接 a 的单击相应函数&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这种做法过于消耗性能。<strong>我们希望，只绑定一次事件，即可应用到多个元素上</strong>，即使元素是后来添加的。</p>\n<p>因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 <code>ul</code> 上，然后在执行事件函数的时候再去匹配判断目标元素。如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;parent-list&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;my_link&quot;</span>&gt;</span>超链接一<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;my_link&quot;</span>&gt;</span>超链接二<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;my_link&quot;</span>&gt;</span>超链接三<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 获取父节点，并为它绑定click单击事件。 false 表示事件在冒泡阶段触发（默认）</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;parent-list&#x27;</span>).addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            event = event || <span class=\"built_in\">window</span>.event;</span></span><br><span class=\"line\"><span class=\"javascript\">            </span></span><br><span class=\"line\"><span class=\"javascript\">             <span class=\"comment\">// e.target 表示：触发事件的对象</span></span></span><br><span class=\"line\"><span class=\"javascript\">             <span class=\"comment\">//如果触发事件的对象是我们期望的元素，则执行否则不执行</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (event.target &amp;&amp; event.target.className == <span class=\"string\">&#x27;my_link&#x27;</span>) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;我是ul的单击响应函数&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        &#125;, <span class=\"literal\">false</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>为父节点注册click事件，当子节点被点击时，click事件会向父节点冒泡。父节点捕获到事件后，通过判断<code>event.target</code>拿到被点击的子节点的相应信息，并做处理。</p>"},{"title":"31天JavaScript学习-第12天","reprint":false,"date":"2022-03-05T08:53:32.000Z","updated":"2022-03-05T08:53:32.000Z","conver":null,"_content":"\n# DOM\n\n<!--more-->\n\n## Node类型\n\nDOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。\n\n**节点**（Node）是构成HTML的最基本单元。\n\nDOM1级定义了一个Node接口，该接口实现了DOM中的所有节点类型。这个Node接口在JS中是作为Node类型实现的，所有节点类型都继承自Node类型，因此所有的节点类型都共享着相同的属性和方法。\n\n**每个节点都有一个NodeType属性**，用于表明节点的类型：\n\n| 节点类型                         | 值   |\n| -------------------------------- | ---- |\n| Node.ELEMENT_NODE                | 1    |\n| Node.ATTRIBUTE_NODE              | 2    |\n| Node.TEXT_NODE                   | 3    |\n| Node.CDATA_SECTION_NODE          | 4    |\n| Node.ENTITY_REFERENCE_NODE       | 5    |\n| Node.ENTITY_NODE                 | 6    |\n| Node.PROCESSING_INSTRUCTION_NODE | 7    |\n| Node.COMMENT_NODE                | 8    |\n| Node.DOCUMENT_NODE               | 9    |\n| Node.DOCUMENT_TYPE_NODE          | 10   |\n| Node.DOCUMENT_FRAGMENT_NODE      | 11   |\n| Node.NOTATION_NODE               | 12   |\n\n### 节点关系\n\n节点之间存在着以下几种关系，均可通过节点属性访问\n\n- childNodes：子节点\n- parentNode：父节点\n- previousSibling：上一个兄弟节点\n- nextSibling：下一个兄弟节点\n- firstChild：第一个子节点\n- lastChild：最后一个子节点\n- ownerDocument：指向整个文档的文档节点\n\n### 节点操作\n\nDOM树可以看成是由一系列指针连接起来的，但任何DOM节点不能同时出现在文档的多个位置上。\n\n#### 节点创建和删除\n\nDOM提供了一些操作节点的方法\n\n| 方法            | 说明                             | 备注                                   |\n| --------------- | -------------------------------- | -------------------------------------- |\n| appendChild()   | 向childNodes列表末尾添加一个节点 | 返回新增的节点                         |\n| insertBefore()  | 往特定的位置之前插入节点         | 返回新增的节点                         |\n| replaceChild()  | 用新节点替换旧节点               | 被替代的节点仍在文档中，只是没有了位置 |\n| removeChild()   | 移除节点                         | 返回移除的节点，仍在文档中             |\n| createElement() | 创建节点                         | 返回新增的节点                         |\n| cloneNode()     | 创建节点的副本                   | true深复制，false浅复制                |\n\n## Document类型\n\n### 文档信息\n\ndocument对象是HTMLDocument的一个实例，存在一些表现网页的一些信息的属性。\n\n| 属性              | 说明                  |\n| ----------------- | --------------------- |\n| document.title    | `<title>`元素中的文本 |\n| document.URL      | 页面完整的URL         |\n| document.domain   | 页面的域名            |\n| document.referrer | 链接到当前页面的URL   |\n\n| 方法                              | 说明                       | 备注 |\n| --------------------------------- | -------------------------- | ---- |\n| document.getElementById()         | 通过id获取一个元素节点     |      |\n| document.getElementsByTagName()   | 通过标签名获取元素节点数组 |      |\n| document.getElementsByClassName() | 通过类名获取元素节点数组   |      |\n\n## Element类型\n\n### 节点属性\n\n| 方法              | 说明             |\n| ----------------- | ---------------- |\n| getAttribute()    | 获取节点的属性值 |\n| setAttribute()    | 设置节点的属性值 |\n| removeAttribute() | 删除节点的属性   |\n\n","source":"_posts/31天JavaScript学习-第12天.md","raw":"---\ntitle: 31天JavaScript学习-第12天\nreprint: false\ndate: 2022-03-05 16:53:32\nupdated: 2022-03-05 16:53:32\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# DOM\n\n<!--more-->\n\n## Node类型\n\nDOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。\n\n**节点**（Node）是构成HTML的最基本单元。\n\nDOM1级定义了一个Node接口，该接口实现了DOM中的所有节点类型。这个Node接口在JS中是作为Node类型实现的，所有节点类型都继承自Node类型，因此所有的节点类型都共享着相同的属性和方法。\n\n**每个节点都有一个NodeType属性**，用于表明节点的类型：\n\n| 节点类型                         | 值   |\n| -------------------------------- | ---- |\n| Node.ELEMENT_NODE                | 1    |\n| Node.ATTRIBUTE_NODE              | 2    |\n| Node.TEXT_NODE                   | 3    |\n| Node.CDATA_SECTION_NODE          | 4    |\n| Node.ENTITY_REFERENCE_NODE       | 5    |\n| Node.ENTITY_NODE                 | 6    |\n| Node.PROCESSING_INSTRUCTION_NODE | 7    |\n| Node.COMMENT_NODE                | 8    |\n| Node.DOCUMENT_NODE               | 9    |\n| Node.DOCUMENT_TYPE_NODE          | 10   |\n| Node.DOCUMENT_FRAGMENT_NODE      | 11   |\n| Node.NOTATION_NODE               | 12   |\n\n### 节点关系\n\n节点之间存在着以下几种关系，均可通过节点属性访问\n\n- childNodes：子节点\n- parentNode：父节点\n- previousSibling：上一个兄弟节点\n- nextSibling：下一个兄弟节点\n- firstChild：第一个子节点\n- lastChild：最后一个子节点\n- ownerDocument：指向整个文档的文档节点\n\n### 节点操作\n\nDOM树可以看成是由一系列指针连接起来的，但任何DOM节点不能同时出现在文档的多个位置上。\n\n#### 节点创建和删除\n\nDOM提供了一些操作节点的方法\n\n| 方法            | 说明                             | 备注                                   |\n| --------------- | -------------------------------- | -------------------------------------- |\n| appendChild()   | 向childNodes列表末尾添加一个节点 | 返回新增的节点                         |\n| insertBefore()  | 往特定的位置之前插入节点         | 返回新增的节点                         |\n| replaceChild()  | 用新节点替换旧节点               | 被替代的节点仍在文档中，只是没有了位置 |\n| removeChild()   | 移除节点                         | 返回移除的节点，仍在文档中             |\n| createElement() | 创建节点                         | 返回新增的节点                         |\n| cloneNode()     | 创建节点的副本                   | true深复制，false浅复制                |\n\n## Document类型\n\n### 文档信息\n\ndocument对象是HTMLDocument的一个实例，存在一些表现网页的一些信息的属性。\n\n| 属性              | 说明                  |\n| ----------------- | --------------------- |\n| document.title    | `<title>`元素中的文本 |\n| document.URL      | 页面完整的URL         |\n| document.domain   | 页面的域名            |\n| document.referrer | 链接到当前页面的URL   |\n\n| 方法                              | 说明                       | 备注 |\n| --------------------------------- | -------------------------- | ---- |\n| document.getElementById()         | 通过id获取一个元素节点     |      |\n| document.getElementsByTagName()   | 通过标签名获取元素节点数组 |      |\n| document.getElementsByClassName() | 通过类名获取元素节点数组   |      |\n\n## Element类型\n\n### 节点属性\n\n| 方法              | 说明             |\n| ----------------- | ---------------- |\n| getAttribute()    | 获取节点的属性值 |\n| setAttribute()    | 设置节点的属性值 |\n| removeAttribute() | 删除节点的属性   |\n\n","slug":"31天JavaScript学习-第12天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl29w00057owz75lo55lg","content":"<h1 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h1><span id=\"more\"></span>\n\n<h2 id=\"Node类型\"><a href=\"#Node类型\" class=\"headerlink\" title=\"Node类型\"></a>Node类型</h2><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。</p>\n<p><strong>节点</strong>（Node）是构成HTML的最基本单元。</p>\n<p>DOM1级定义了一个Node接口，该接口实现了DOM中的所有节点类型。这个Node接口在JS中是作为Node类型实现的，所有节点类型都继承自Node类型，因此所有的节点类型都共享着相同的属性和方法。</p>\n<p><strong>每个节点都有一个NodeType属性</strong>，用于表明节点的类型：</p>\n<table>\n<thead>\n<tr>\n<th>节点类型</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node.ELEMENT_NODE</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Node.ATTRIBUTE_NODE</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Node.TEXT_NODE</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Node.CDATA_SECTION_NODE</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Node.ENTITY_REFERENCE_NODE</td>\n<td>5</td>\n</tr>\n<tr>\n<td>Node.ENTITY_NODE</td>\n<td>6</td>\n</tr>\n<tr>\n<td>Node.PROCESSING_INSTRUCTION_NODE</td>\n<td>7</td>\n</tr>\n<tr>\n<td>Node.COMMENT_NODE</td>\n<td>8</td>\n</tr>\n<tr>\n<td>Node.DOCUMENT_NODE</td>\n<td>9</td>\n</tr>\n<tr>\n<td>Node.DOCUMENT_TYPE_NODE</td>\n<td>10</td>\n</tr>\n<tr>\n<td>Node.DOCUMENT_FRAGMENT_NODE</td>\n<td>11</td>\n</tr>\n<tr>\n<td>Node.NOTATION_NODE</td>\n<td>12</td>\n</tr>\n</tbody></table>\n<h3 id=\"节点关系\"><a href=\"#节点关系\" class=\"headerlink\" title=\"节点关系\"></a>节点关系</h3><p>节点之间存在着以下几种关系，均可通过节点属性访问</p>\n<ul>\n<li>childNodes：子节点</li>\n<li>parentNode：父节点</li>\n<li>previousSibling：上一个兄弟节点</li>\n<li>nextSibling：下一个兄弟节点</li>\n<li>firstChild：第一个子节点</li>\n<li>lastChild：最后一个子节点</li>\n<li>ownerDocument：指向整个文档的文档节点</li>\n</ul>\n<h3 id=\"节点操作\"><a href=\"#节点操作\" class=\"headerlink\" title=\"节点操作\"></a>节点操作</h3><p>DOM树可以看成是由一系列指针连接起来的，但任何DOM节点不能同时出现在文档的多个位置上。</p>\n<h4 id=\"节点创建和删除\"><a href=\"#节点创建和删除\" class=\"headerlink\" title=\"节点创建和删除\"></a>节点创建和删除</h4><p>DOM提供了一些操作节点的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>appendChild()</td>\n<td>向childNodes列表末尾添加一个节点</td>\n<td>返回新增的节点</td>\n</tr>\n<tr>\n<td>insertBefore()</td>\n<td>往特定的位置之前插入节点</td>\n<td>返回新增的节点</td>\n</tr>\n<tr>\n<td>replaceChild()</td>\n<td>用新节点替换旧节点</td>\n<td>被替代的节点仍在文档中，只是没有了位置</td>\n</tr>\n<tr>\n<td>removeChild()</td>\n<td>移除节点</td>\n<td>返回移除的节点，仍在文档中</td>\n</tr>\n<tr>\n<td>createElement()</td>\n<td>创建节点</td>\n<td>返回新增的节点</td>\n</tr>\n<tr>\n<td>cloneNode()</td>\n<td>创建节点的副本</td>\n<td>true深复制，false浅复制</td>\n</tr>\n</tbody></table>\n<h2 id=\"Document类型\"><a href=\"#Document类型\" class=\"headerlink\" title=\"Document类型\"></a>Document类型</h2><h3 id=\"文档信息\"><a href=\"#文档信息\" class=\"headerlink\" title=\"文档信息\"></a>文档信息</h3><p>document对象是HTMLDocument的一个实例，存在一些表现网页的一些信息的属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>document.title</td>\n<td><code>&lt;title&gt;</code>元素中的文本</td>\n</tr>\n<tr>\n<td>document.URL</td>\n<td>页面完整的URL</td>\n</tr>\n<tr>\n<td>document.domain</td>\n<td>页面的域名</td>\n</tr>\n<tr>\n<td>document.referrer</td>\n<td>链接到当前页面的URL</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>document.getElementById()</td>\n<td>通过id获取一个元素节点</td>\n<td></td>\n</tr>\n<tr>\n<td>document.getElementsByTagName()</td>\n<td>通过标签名获取元素节点数组</td>\n<td></td>\n</tr>\n<tr>\n<td>document.getElementsByClassName()</td>\n<td>通过类名获取元素节点数组</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"Element类型\"><a href=\"#Element类型\" class=\"headerlink\" title=\"Element类型\"></a>Element类型</h2><h3 id=\"节点属性\"><a href=\"#节点属性\" class=\"headerlink\" title=\"节点属性\"></a>节点属性</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getAttribute()</td>\n<td>获取节点的属性值</td>\n</tr>\n<tr>\n<td>setAttribute()</td>\n<td>设置节点的属性值</td>\n</tr>\n<tr>\n<td>removeAttribute()</td>\n<td>删除节点的属性</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<h1 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h1>","more":"<h2 id=\"Node类型\"><a href=\"#Node类型\" class=\"headerlink\" title=\"Node类型\"></a>Node类型</h2><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。</p>\n<p><strong>节点</strong>（Node）是构成HTML的最基本单元。</p>\n<p>DOM1级定义了一个Node接口，该接口实现了DOM中的所有节点类型。这个Node接口在JS中是作为Node类型实现的，所有节点类型都继承自Node类型，因此所有的节点类型都共享着相同的属性和方法。</p>\n<p><strong>每个节点都有一个NodeType属性</strong>，用于表明节点的类型：</p>\n<table>\n<thead>\n<tr>\n<th>节点类型</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node.ELEMENT_NODE</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Node.ATTRIBUTE_NODE</td>\n<td>2</td>\n</tr>\n<tr>\n<td>Node.TEXT_NODE</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Node.CDATA_SECTION_NODE</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Node.ENTITY_REFERENCE_NODE</td>\n<td>5</td>\n</tr>\n<tr>\n<td>Node.ENTITY_NODE</td>\n<td>6</td>\n</tr>\n<tr>\n<td>Node.PROCESSING_INSTRUCTION_NODE</td>\n<td>7</td>\n</tr>\n<tr>\n<td>Node.COMMENT_NODE</td>\n<td>8</td>\n</tr>\n<tr>\n<td>Node.DOCUMENT_NODE</td>\n<td>9</td>\n</tr>\n<tr>\n<td>Node.DOCUMENT_TYPE_NODE</td>\n<td>10</td>\n</tr>\n<tr>\n<td>Node.DOCUMENT_FRAGMENT_NODE</td>\n<td>11</td>\n</tr>\n<tr>\n<td>Node.NOTATION_NODE</td>\n<td>12</td>\n</tr>\n</tbody></table>\n<h3 id=\"节点关系\"><a href=\"#节点关系\" class=\"headerlink\" title=\"节点关系\"></a>节点关系</h3><p>节点之间存在着以下几种关系，均可通过节点属性访问</p>\n<ul>\n<li>childNodes：子节点</li>\n<li>parentNode：父节点</li>\n<li>previousSibling：上一个兄弟节点</li>\n<li>nextSibling：下一个兄弟节点</li>\n<li>firstChild：第一个子节点</li>\n<li>lastChild：最后一个子节点</li>\n<li>ownerDocument：指向整个文档的文档节点</li>\n</ul>\n<h3 id=\"节点操作\"><a href=\"#节点操作\" class=\"headerlink\" title=\"节点操作\"></a>节点操作</h3><p>DOM树可以看成是由一系列指针连接起来的，但任何DOM节点不能同时出现在文档的多个位置上。</p>\n<h4 id=\"节点创建和删除\"><a href=\"#节点创建和删除\" class=\"headerlink\" title=\"节点创建和删除\"></a>节点创建和删除</h4><p>DOM提供了一些操作节点的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>appendChild()</td>\n<td>向childNodes列表末尾添加一个节点</td>\n<td>返回新增的节点</td>\n</tr>\n<tr>\n<td>insertBefore()</td>\n<td>往特定的位置之前插入节点</td>\n<td>返回新增的节点</td>\n</tr>\n<tr>\n<td>replaceChild()</td>\n<td>用新节点替换旧节点</td>\n<td>被替代的节点仍在文档中，只是没有了位置</td>\n</tr>\n<tr>\n<td>removeChild()</td>\n<td>移除节点</td>\n<td>返回移除的节点，仍在文档中</td>\n</tr>\n<tr>\n<td>createElement()</td>\n<td>创建节点</td>\n<td>返回新增的节点</td>\n</tr>\n<tr>\n<td>cloneNode()</td>\n<td>创建节点的副本</td>\n<td>true深复制，false浅复制</td>\n</tr>\n</tbody></table>\n<h2 id=\"Document类型\"><a href=\"#Document类型\" class=\"headerlink\" title=\"Document类型\"></a>Document类型</h2><h3 id=\"文档信息\"><a href=\"#文档信息\" class=\"headerlink\" title=\"文档信息\"></a>文档信息</h3><p>document对象是HTMLDocument的一个实例，存在一些表现网页的一些信息的属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>document.title</td>\n<td><code>&lt;title&gt;</code>元素中的文本</td>\n</tr>\n<tr>\n<td>document.URL</td>\n<td>页面完整的URL</td>\n</tr>\n<tr>\n<td>document.domain</td>\n<td>页面的域名</td>\n</tr>\n<tr>\n<td>document.referrer</td>\n<td>链接到当前页面的URL</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>document.getElementById()</td>\n<td>通过id获取一个元素节点</td>\n<td></td>\n</tr>\n<tr>\n<td>document.getElementsByTagName()</td>\n<td>通过标签名获取元素节点数组</td>\n<td></td>\n</tr>\n<tr>\n<td>document.getElementsByClassName()</td>\n<td>通过类名获取元素节点数组</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"Element类型\"><a href=\"#Element类型\" class=\"headerlink\" title=\"Element类型\"></a>Element类型</h2><h3 id=\"节点属性\"><a href=\"#节点属性\" class=\"headerlink\" title=\"节点属性\"></a>节点属性</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getAttribute()</td>\n<td>获取节点的属性值</td>\n</tr>\n<tr>\n<td>setAttribute()</td>\n<td>设置节点的属性值</td>\n</tr>\n<tr>\n<td>removeAttribute()</td>\n<td>删除节点的属性</td>\n</tr>\n</tbody></table>"},{"title":"31天JavaScript学习-第15天","reprint":false,"date":"2022-03-08T12:04:28.000Z","updated":"2022-03-08T12:04:28.000Z","conver":null,"_content":"\n# JS异步\n\n<!--more-->\n\nJS作为浏览器的脚本语言，其执行环境是单线程。\n\n具体来说，是JS引擎中负责解释和执行JS代码的线程只有一个，一次只能完成一项任务。所有的任务都需要排队。但JS引擎执行异步代码而不用等待，是因有为有消息队列和事件循环。\n\n## 同步与异步\n\n- **同步任务：**在**主线程**上排队执行的任务。只有前一个任务执行完成，才能执行下一个任务。\n- **异步任务：**不进入主线程，而是进入**任务队列**的任务，该任务不会阻塞后面的任务执行。\n\n**异步的使用场景：**\n\n1. 事件监听（例如按钮绑定点击事件）\n2. 回调函数：\n   1. 定时器：setTimeout、setInterval\n   2. ajax请求\n   3. Node.js中的一些方法回调\n3. ES6中的Promise、Generator、async/await\n\n## JS的事件循环机制\n\nJS主线程把执行栈的代码取出来依次执行。如果代码是同步的会放入**执行栈**主线程去执行；如果是异步则会放入`Event Table`中，当异步任务完成后会放入**事件队列**`Event Queue`中，这里面存储的是异步任务完成后做的事。等主线程把执行栈里的任务全部完成后，主线程空闲出来，这时才会读取异步队列`Event Queue`里面的函数，如果队列里有就取出来放到主线程去执行，执行完成后再查看事件队列`Event Queue`中是否还有异步任务，如果有继续执行。\n\n![img](31天JavaScript学习-第15天/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png)\n\n注：异步调用的结果如果存在依赖，则需要通过回调函数进行嵌套\n\n```js\nconsole.log(1);\n\nsetTimeout(() => {\n    console.log(2);\n}, 0); // 即使等待事件为0，也要等到主线程任务完成才能执行异步任务\nconsole.log(3);\nconsole.log(4);\n```\n\n```\n1\n3\n4\n2\n```\n\n## 宏任务微任务\n\nJS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。\n\n- **宏任务（macrotask）：**常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I/O、postMessage、messageChannel、setImmediate（node.js环境）\n- **微任务（microtask）：**如Promise、MutaionObserver、process.nextTick(node.js环境)\n\nJS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。\n\n","source":"_posts/31天JavaScript学习-第15天.md","raw":"---\ntitle: 31天JavaScript学习-第15天\nreprint: false\ndate: 2022-03-08 20:04:28\nupdated: 2022-03-08 20:04:28\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# JS异步\n\n<!--more-->\n\nJS作为浏览器的脚本语言，其执行环境是单线程。\n\n具体来说，是JS引擎中负责解释和执行JS代码的线程只有一个，一次只能完成一项任务。所有的任务都需要排队。但JS引擎执行异步代码而不用等待，是因有为有消息队列和事件循环。\n\n## 同步与异步\n\n- **同步任务：**在**主线程**上排队执行的任务。只有前一个任务执行完成，才能执行下一个任务。\n- **异步任务：**不进入主线程，而是进入**任务队列**的任务，该任务不会阻塞后面的任务执行。\n\n**异步的使用场景：**\n\n1. 事件监听（例如按钮绑定点击事件）\n2. 回调函数：\n   1. 定时器：setTimeout、setInterval\n   2. ajax请求\n   3. Node.js中的一些方法回调\n3. ES6中的Promise、Generator、async/await\n\n## JS的事件循环机制\n\nJS主线程把执行栈的代码取出来依次执行。如果代码是同步的会放入**执行栈**主线程去执行；如果是异步则会放入`Event Table`中，当异步任务完成后会放入**事件队列**`Event Queue`中，这里面存储的是异步任务完成后做的事。等主线程把执行栈里的任务全部完成后，主线程空闲出来，这时才会读取异步队列`Event Queue`里面的函数，如果队列里有就取出来放到主线程去执行，执行完成后再查看事件队列`Event Queue`中是否还有异步任务，如果有继续执行。\n\n![img](31天JavaScript学习-第15天/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png)\n\n注：异步调用的结果如果存在依赖，则需要通过回调函数进行嵌套\n\n```js\nconsole.log(1);\n\nsetTimeout(() => {\n    console.log(2);\n}, 0); // 即使等待事件为0，也要等到主线程任务完成才能执行异步任务\nconsole.log(3);\nconsole.log(4);\n```\n\n```\n1\n3\n4\n2\n```\n\n## 宏任务微任务\n\nJS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。\n\n- **宏任务（macrotask）：**常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I/O、postMessage、messageChannel、setImmediate（node.js环境）\n- **微任务（microtask）：**如Promise、MutaionObserver、process.nextTick(node.js环境)\n\nJS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。\n\n","slug":"31天JavaScript学习-第15天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl29y00067owzc36f1d8j","content":"<h1 id=\"JS异步\"><a href=\"#JS异步\" class=\"headerlink\" title=\"JS异步\"></a>JS异步</h1><span id=\"more\"></span>\n\n<p>JS作为浏览器的脚本语言，其执行环境是单线程。</p>\n<p>具体来说，是JS引擎中负责解释和执行JS代码的线程只有一个，一次只能完成一项任务。所有的任务都需要排队。但JS引擎执行异步代码而不用等待，是因有为有消息队列和事件循环。</p>\n<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><ul>\n<li><strong>同步任务：</strong>在<strong>主线程</strong>上排队执行的任务。只有前一个任务执行完成，才能执行下一个任务。</li>\n<li><strong>异步任务：</strong>不进入主线程，而是进入<strong>任务队列</strong>的任务，该任务不会阻塞后面的任务执行。</li>\n</ul>\n<p><strong>异步的使用场景：</strong></p>\n<ol>\n<li>事件监听（例如按钮绑定点击事件）</li>\n<li>回调函数：<ol>\n<li>定时器：setTimeout、setInterval</li>\n<li>ajax请求</li>\n<li>Node.js中的一些方法回调</li>\n</ol>\n</li>\n<li>ES6中的Promise、Generator、async/await</li>\n</ol>\n<h2 id=\"JS的事件循环机制\"><a href=\"#JS的事件循环机制\" class=\"headerlink\" title=\"JS的事件循环机制\"></a>JS的事件循环机制</h2><p>JS主线程把执行栈的代码取出来依次执行。如果代码是同步的会放入<strong>执行栈</strong>主线程去执行；如果是异步则会放入<code>Event Table</code>中，当异步任务完成后会放入<strong>事件队列</strong><code>Event Queue</code>中，这里面存储的是异步任务完成后做的事。等主线程把执行栈里的任务全部完成后，主线程空闲出来，这时才会读取异步队列<code>Event Queue</code>里面的函数，如果队列里有就取出来放到主线程去执行，执行完成后再查看事件队列<code>Event Queue</code>中是否还有异步任务，如果有继续执行。</p>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/03/08/d21dc573f3b7/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png\" alt=\"img\" class=\"lazyload\"></p>\n<p>注：异步调用的结果如果存在依赖，则需要通过回调函数进行嵌套</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>); <span class=\"comment\">// 即使等待事件为0，也要等到主线程任务完成才能执行异步任务</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"宏任务微任务\"><a href=\"#宏任务微任务\" class=\"headerlink\" title=\"宏任务微任务\"></a>宏任务微任务</h2><p>JS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。</p>\n<ul>\n<li><strong>宏任务（macrotask）：</strong>常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I/O、postMessage、messageChannel、setImmediate（node.js环境）</li>\n<li><strong>微任务（microtask）：</strong>如Promise、MutaionObserver、process.nextTick(node.js环境)</li>\n</ul>\n<p>JS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"JS异步\"><a href=\"#JS异步\" class=\"headerlink\" title=\"JS异步\"></a>JS异步</h1>","more":"<p>JS作为浏览器的脚本语言，其执行环境是单线程。</p>\n<p>具体来说，是JS引擎中负责解释和执行JS代码的线程只有一个，一次只能完成一项任务。所有的任务都需要排队。但JS引擎执行异步代码而不用等待，是因有为有消息队列和事件循环。</p>\n<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><ul>\n<li><strong>同步任务：</strong>在<strong>主线程</strong>上排队执行的任务。只有前一个任务执行完成，才能执行下一个任务。</li>\n<li><strong>异步任务：</strong>不进入主线程，而是进入<strong>任务队列</strong>的任务，该任务不会阻塞后面的任务执行。</li>\n</ul>\n<p><strong>异步的使用场景：</strong></p>\n<ol>\n<li>事件监听（例如按钮绑定点击事件）</li>\n<li>回调函数：<ol>\n<li>定时器：setTimeout、setInterval</li>\n<li>ajax请求</li>\n<li>Node.js中的一些方法回调</li>\n</ol>\n</li>\n<li>ES6中的Promise、Generator、async/await</li>\n</ol>\n<h2 id=\"JS的事件循环机制\"><a href=\"#JS的事件循环机制\" class=\"headerlink\" title=\"JS的事件循环机制\"></a>JS的事件循环机制</h2><p>JS主线程把执行栈的代码取出来依次执行。如果代码是同步的会放入<strong>执行栈</strong>主线程去执行；如果是异步则会放入<code>Event Table</code>中，当异步任务完成后会放入<strong>事件队列</strong><code>Event Queue</code>中，这里面存储的是异步任务完成后做的事。等主线程把执行栈里的任务全部完成后，主线程空闲出来，这时才会读取异步队列<code>Event Queue</code>里面的函数，如果队列里有就取出来放到主线程去执行，执行完成后再查看事件队列<code>Event Queue</code>中是否还有异步任务，如果有继续执行。</p>\n<p><img src=\"/2022/03/08/d21dc573f3b7/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png\" alt=\"img\"></p>\n<p>注：异步调用的结果如果存在依赖，则需要通过回调函数进行嵌套</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>); <span class=\"comment\">// 即使等待事件为0，也要等到主线程任务完成才能执行异步任务</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"宏任务微任务\"><a href=\"#宏任务微任务\" class=\"headerlink\" title=\"宏任务微任务\"></a>宏任务微任务</h2><p>JS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。</p>\n<ul>\n<li><strong>宏任务（macrotask）：</strong>常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I/O、postMessage、messageChannel、setImmediate（node.js环境）</li>\n<li><strong>微任务（microtask）：</strong>如Promise、MutaionObserver、process.nextTick(node.js环境)</li>\n</ul>\n<p>JS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。</p>"},{"title":"31天JavaScript学习-第14天","reprint":false,"date":"2022-03-07T02:39:41.000Z","updated":"2022-03-07T02:39:41.000Z","conver":null,"_content":"\n# **ES6语法**\n\n<!--more-->\n\n## 简介\n\nES 的全称是 ECMAScript，它是由 ECMA 国际标准化组织 制定的一套**脚本语言的标准化规范**。\n\nES6 是新的 JS 语法标准。**ES6 实际上是一个泛指，泛指 ES 2015 及后续的版本**。\n\n> 掌握 ES6 之后，如果你的业务需要考虑 ES5 的兼容性，则可以这样做：写 ES6 语法的 js 代码，然后通过 `Babel`将 ES6 转换为 ES5。\n\n> PS：我们在写代码时，能用单引号尽量用单引号，而不是双引号，前者在压缩之后，程序执行会更快。\n\n## let、const和块级作用域\n\nES6中，新增了let和const来定义变量：\n\n- **let：**定义变量，替代var。用let声明的变量，具有块级作用域，只在局部起作用。\n- **const：**定义常量，定义后不可修改。用const声明的常量，只在块级作用域内起作用，且必须在声明时赋值。\n\n**暂时性死区（TDZ）**\n\nES6规定，使用let/const声明的变量，会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。\n\n**let 和 const 的特点【重要】**\n\n- 不属于顶层对象 Window\n- 不允许重复声明\n- 不存在变量提升\n- 暂时性死区\n- 支持块级作用域\n\n相反， 用`var`声明的变量：存在变量提升、可以重复声明、**没有块级作用域**。\n\n## 变量的解构赋值\n\nES6允许我们，按照一一对应的方式，从数组或对象中提取值，再将提取出来的值赋值给变量。\n\n### 数组的解构赋值\n\n将数组中的值按照位置提取出来，然后赋值给变量\n\n```js\nlet [a, b, c] = [1, 2, 3];\n```\n\n**两边数量不相等的情况：**\n\n- **变量数量>值的数量：**多余的变量被赋值为undefined\n- **变量数量<值的数量：**正常赋值\n\n**解构时，左边变量可以有默认值**\n\n```js\nlet [a, b, c=10] = [1, 2]\nconsole.log(a); // 1\nconsole.log(b); // 2\nconsole.log(c); // 10\n```\n\n**赋值中含有undefined和null的情况**\n\n```js\nlet [a, b, c=10] = [1, undefined, undefined]\nconsole.log(a); // 1\nconsole.log(b); // undefined\nconsole.log(c); // 10\n```\n\n```js\nlet [a, b, c=10] = [1, null, null]\nconsole.log(a); // 1\nconsole.log(b); // null\nconsole.log(c); // null\n```\n\n### 对象的解构赋值\n\n将对象中的值按照属性匹配的方式提取出来，然后赋值给变量。\n\nES6前，我们从接口拿到json数据后，一般这么赋值\n\n```js\nvar name = json.name;\n\nvar age = json.age;\n\nvar sex = json.sex;\n```\n\nES6后，可以简化成\n\n```js\nconst person = { name: 'zrtty', age: 28, sex: '男' };\nlet { age, name, sex } = person; // 对象的结构赋值\n\nconsole.log(name); // 打印结果：zrtty\nconsole.log(age); // 打印结果：28\nconsole.log(sex); // 打印结果：男\n```\n\n上方代码可以看出，对象的解构与数组的结构，有一个重要的区别：**数组**的元素是按次序排列的，变量的取值由它的**位置**决定；而**对象的属性没有次序**，是**根据键来取值**的。\n\n**两边数量不相等的情况：**\n\n- **变量数量>值的数量：**多余的变量被赋值为undefined\n- **变量数量<值的数量：**正常赋值\n\n**变量自定义命名解构赋值**\n\n```js\nconst person = { name: 'zrtty', age: 28 };\nlet { name: myName, age: myAge } = person; // 对象的结构赋值\n\nconsole.log(myName); // 打印结果：zrtty\nconsole.log(myAge); // 打印结果：28\n\nconsole.log(name); // 打印报错：Uncaught ReferenceError: name is not defined\nconsole.log(age); // 打印报错：Uncaught ReferenceError: age is not defined\n```\n\n**圆括号的使用**\n\n如果变量 foo 在解构之前就已经定义了，此时你再去解构，就会出现问题。下面是错误的代码，编译会报错：\n\n```\n\tlet foo = 'haha';\n\t{ foo } = { foo: 'smyhvae' };\n\tconsole.log(foo);\n```\n\n要解决报错，只要在解构的语句外边，加一个圆括号即可：\n\n```\nlet foo = 'haha';\n({ foo } = { foo: 'smyhvae' });\nconsole.log(foo); //输出结果：smyhvae\n```\n\n### 字符串结构\n\n字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。举例如下：\n\n```js\nconst [a, b, c, d] = 'hello';\nconsole.log(a); // h\nconsole.log(b); // e\nconsole.log(c); // l\n\nconsole.log(typeof a); // string\n```\n\n## 箭头函数\n\nES6的箭头函数语法：\n\n`(arg1, agr2, ...) => { 函数体 }`\n\n注：\n\n- 如果有且仅有1个形参，则`()`可以省略\n- 如果函数体内有且仅有1条语句，则`{}`可以省略，前提是这条语句必须时return语句，且返回语句无需return关键字\n\n如\n\n```js\nfunction fn1 (a, b) {\n\tconsole.log('haa');\n\treturn a + b;\n}\n\nconst fn2 = (a, b) => {\n    console.log('haha');\n    return a + b;\n}\n\nconst fn3 = a => {\n    console.log('haha' + a);\n}\n\nconst fn4 = (a, b) => a - b;\n```\n\n###  this指向\n\n箭头函数的作用只是为了写法更简洁吗？不仅仅是这个原因，还有一个很大的作用是this的指向有关。\n\n**this指向的区别**\n\n- **ES5：**this指向函数被调用的对象\n- **ES6：**箭头函数本身不绑定this，this指向的是箭头函数定义位置的this（箭头函数在哪个位置定义的，this就跟这个位置的this指向相同）。\n\n例如\n\n```js\nconst obj = { name: 'zrtty' };\n\nfunction fn1() {\n  console.log(this); // { name: 'zrtty' }\n  return () => {\n    console.log(this);\n  };\n}\n\nconst fn2 = fn1.call(obj);\nfn2(); // { name: 'zrtty' }\n```\n\n`fn1.call(obj)`执行之后，第一个this就指向了被调用的对象obj；而箭头函数是在fn1()函数里定义的，所以第二个this和第一个this指向的是同一个位置。\n\n**面试题**\n\n```js\nvar name = '许嵩';\nvar obj = {\n    name: 'zrtty',\n    sayHello: () => {\n        console.log(this.name);\n    },\n};\n\nobj.sayHello();\n```\n\n打印结果是`许嵩`。因为obj对象并不产生作用域，定义在obj内部的sayHello箭头函数实际仍定义在全局作用域中，也就是this指向window。\n\n### 参数默认值\n\n传统写法：\n\n```js\nfunction fn(param) {\n    let p = param || 'hello';\n    console.log(p);\n}\n```\n\nES6写法：\n\n```js\nfunction fn(param = 'hello') {\n    console.log(param);\n}\n```\n\n**注：**默认值的后面，不能再有**没有默认值的变量**\n\n### 剩余参数\n\n**剩余参数**允许我们将不确定数量的**剩余的元素**放到一个**数组**中。\n\n比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。\n\n**传统写法（会报错）**\n\n```js\nfunction fn(a, b, c) {\n    console.log(a);\n    console.log(b);\n    console.log(c);\n    console.log(d);\n}\n\nfn(1, 2, 3);\n```\n\n**ES6 写法**：\n\n```js\nconst fn = (...args) => {\n    //当不确定方法的参数时，可以使用剩余参数\n    console.log(args[0]);\n    console.log(args[1]);\n    console.log(args[2]);\n    console.log(args[3]);\n};\n\nfn(1, 2); // 1 2 undefined undefined\nfn(1, 2, 3); // 1 2 3 undefined\n```\n\n方法的定义中了四个参数，但调用函数时只使用了三个参数，ES6 中并不会报错。\n\n**注：**args 参数之后，不能再加别的参数，否则编译报错。\n\n## 扩展语法（展开语法）\n\n扩展运算符和剩余参数是相反的。\n\n剩余参数是将剩余的元素放到一个数组中；而扩展运算符是将数组或者对象拆分成逗号分隔的参数序列。\n\n如\n\n```js\nconst arr = [10, 20, 30];\n\nconsole.log(arr); // [ 10, 20, 30 ]\nconsole.log(...arr); // 10 20 30\nconsole.log(10, 20, 30); // 10 20 30\n```\n\n**举例1：数组赋值**\n\n```js\nlet arr1 = ['www', 'smyhvae', 'com'];\nlet arr2 = arr1; // 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址\nconsole.log('arr1:' + arr1); // arr1:www,smyhvae,com\nconsole.log('arr2:' + arr2); // arr2:www,smyhvae,com\n\narr2.push('你懂得'); //往 arr2 里添加一部分内容\nconsole.log('arr1:' + arr1); // arr1:www,smyhvae,com,你懂得\nconsole.log('arr2:' + arr2); // arr2:www,smyhvae,com,你懂得\n```\n\n```js\nlet arr1 = ['www', 'smyhvae', 'com'];\nlet arr2 = [...arr1]; //【重要代码】arr2 会重新开辟内存地址\nconsole.log('arr1:' + arr1);\nconsole.log('arr2:' + arr2);\n\narr2.push('你懂得'); //往arr2 里添加一部分内容\nconsole.log('arr1:' + arr1); // arr1:www,smyhvae,com\nconsole.log('arr2:' + arr2); // arr2:www,smyhvae,com,你懂得\n```\n\n**举例2：合并数组**\n\n```js\nlet arr1 = ['王一', '王二', '王三'];\nlet arr2 = ['王四', '王五', '王六'];\n// ...arr1  // '王一','王二','王三'\n// ...arr2  // '王四','王五','王六'\n\n// 方法1\nlet arr3 = [...arr1, ...arr2];\nconsole.log(arr3); // [\"王一\", \"王二\", \"王三\", \"王四\", \"王五\", \"王六\"]\n\n// 方法2\narr1.push(...arr2);\nconsole.log(arr1); // [\"王一\", \"王二\", \"王三\", \"王四\", \"王五\", \"王六\"]\n```\n\n**举例3：将伪数组或者可遍历对象转换为真正的数组**\n\n```js\nconst myDivs = document.getElementsByClassName('div');\nconst divArr = [...myDivs]; // 利用扩展运算符，将伪数组转为真正的数组\n```\n\n## Set数据结构\n\nES6提供了新的数据结构Set。Set类似于数组，但成员的值都是唯一的，没有重复的值。\n\n**Set的创建**\n\n```js\nconst set1 = new Set();\nconsole.log(set1.size);\n```\n\n**Set的用法之一：数组去重**\n\n```js\nconst set2 = new Set(['张三', '李四', '王五', '张三']); // 注意，这个数组里有重复的值\n\n// 注意，这里的 set2 并不是数组，而是一个单纯的 Set 数据结构\nconsole.log(set2); // {\"张三\", \"李四\", \"王五\"}\nconsole.log(typeof set2); // object\nconsole.log(set2 instanceof Array); \n\n// 通过扩展运算符，拿到 set 中的元素（用逗号分隔的序列）\n// ...set2 //  \"张三\", \"李四\", \"王五\"\n\n// 注意，到这一步，才获取到了真正的数组\nconsole.log([...set2]); // [\"张三\", \"李四\", \"王五\"]\n```\n\n","source":"_posts/31天JavaScript学习-第14天.md","raw":"---\ntitle: 31天JavaScript学习-第14天\nreprint: false\ndate: 2022-03-07 10:39:41\nupdated: 2022-03-07 10:39:41\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# **ES6语法**\n\n<!--more-->\n\n## 简介\n\nES 的全称是 ECMAScript，它是由 ECMA 国际标准化组织 制定的一套**脚本语言的标准化规范**。\n\nES6 是新的 JS 语法标准。**ES6 实际上是一个泛指，泛指 ES 2015 及后续的版本**。\n\n> 掌握 ES6 之后，如果你的业务需要考虑 ES5 的兼容性，则可以这样做：写 ES6 语法的 js 代码，然后通过 `Babel`将 ES6 转换为 ES5。\n\n> PS：我们在写代码时，能用单引号尽量用单引号，而不是双引号，前者在压缩之后，程序执行会更快。\n\n## let、const和块级作用域\n\nES6中，新增了let和const来定义变量：\n\n- **let：**定义变量，替代var。用let声明的变量，具有块级作用域，只在局部起作用。\n- **const：**定义常量，定义后不可修改。用const声明的常量，只在块级作用域内起作用，且必须在声明时赋值。\n\n**暂时性死区（TDZ）**\n\nES6规定，使用let/const声明的变量，会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。\n\n**let 和 const 的特点【重要】**\n\n- 不属于顶层对象 Window\n- 不允许重复声明\n- 不存在变量提升\n- 暂时性死区\n- 支持块级作用域\n\n相反， 用`var`声明的变量：存在变量提升、可以重复声明、**没有块级作用域**。\n\n## 变量的解构赋值\n\nES6允许我们，按照一一对应的方式，从数组或对象中提取值，再将提取出来的值赋值给变量。\n\n### 数组的解构赋值\n\n将数组中的值按照位置提取出来，然后赋值给变量\n\n```js\nlet [a, b, c] = [1, 2, 3];\n```\n\n**两边数量不相等的情况：**\n\n- **变量数量>值的数量：**多余的变量被赋值为undefined\n- **变量数量<值的数量：**正常赋值\n\n**解构时，左边变量可以有默认值**\n\n```js\nlet [a, b, c=10] = [1, 2]\nconsole.log(a); // 1\nconsole.log(b); // 2\nconsole.log(c); // 10\n```\n\n**赋值中含有undefined和null的情况**\n\n```js\nlet [a, b, c=10] = [1, undefined, undefined]\nconsole.log(a); // 1\nconsole.log(b); // undefined\nconsole.log(c); // 10\n```\n\n```js\nlet [a, b, c=10] = [1, null, null]\nconsole.log(a); // 1\nconsole.log(b); // null\nconsole.log(c); // null\n```\n\n### 对象的解构赋值\n\n将对象中的值按照属性匹配的方式提取出来，然后赋值给变量。\n\nES6前，我们从接口拿到json数据后，一般这么赋值\n\n```js\nvar name = json.name;\n\nvar age = json.age;\n\nvar sex = json.sex;\n```\n\nES6后，可以简化成\n\n```js\nconst person = { name: 'zrtty', age: 28, sex: '男' };\nlet { age, name, sex } = person; // 对象的结构赋值\n\nconsole.log(name); // 打印结果：zrtty\nconsole.log(age); // 打印结果：28\nconsole.log(sex); // 打印结果：男\n```\n\n上方代码可以看出，对象的解构与数组的结构，有一个重要的区别：**数组**的元素是按次序排列的，变量的取值由它的**位置**决定；而**对象的属性没有次序**，是**根据键来取值**的。\n\n**两边数量不相等的情况：**\n\n- **变量数量>值的数量：**多余的变量被赋值为undefined\n- **变量数量<值的数量：**正常赋值\n\n**变量自定义命名解构赋值**\n\n```js\nconst person = { name: 'zrtty', age: 28 };\nlet { name: myName, age: myAge } = person; // 对象的结构赋值\n\nconsole.log(myName); // 打印结果：zrtty\nconsole.log(myAge); // 打印结果：28\n\nconsole.log(name); // 打印报错：Uncaught ReferenceError: name is not defined\nconsole.log(age); // 打印报错：Uncaught ReferenceError: age is not defined\n```\n\n**圆括号的使用**\n\n如果变量 foo 在解构之前就已经定义了，此时你再去解构，就会出现问题。下面是错误的代码，编译会报错：\n\n```\n\tlet foo = 'haha';\n\t{ foo } = { foo: 'smyhvae' };\n\tconsole.log(foo);\n```\n\n要解决报错，只要在解构的语句外边，加一个圆括号即可：\n\n```\nlet foo = 'haha';\n({ foo } = { foo: 'smyhvae' });\nconsole.log(foo); //输出结果：smyhvae\n```\n\n### 字符串结构\n\n字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。举例如下：\n\n```js\nconst [a, b, c, d] = 'hello';\nconsole.log(a); // h\nconsole.log(b); // e\nconsole.log(c); // l\n\nconsole.log(typeof a); // string\n```\n\n## 箭头函数\n\nES6的箭头函数语法：\n\n`(arg1, agr2, ...) => { 函数体 }`\n\n注：\n\n- 如果有且仅有1个形参，则`()`可以省略\n- 如果函数体内有且仅有1条语句，则`{}`可以省略，前提是这条语句必须时return语句，且返回语句无需return关键字\n\n如\n\n```js\nfunction fn1 (a, b) {\n\tconsole.log('haa');\n\treturn a + b;\n}\n\nconst fn2 = (a, b) => {\n    console.log('haha');\n    return a + b;\n}\n\nconst fn3 = a => {\n    console.log('haha' + a);\n}\n\nconst fn4 = (a, b) => a - b;\n```\n\n###  this指向\n\n箭头函数的作用只是为了写法更简洁吗？不仅仅是这个原因，还有一个很大的作用是this的指向有关。\n\n**this指向的区别**\n\n- **ES5：**this指向函数被调用的对象\n- **ES6：**箭头函数本身不绑定this，this指向的是箭头函数定义位置的this（箭头函数在哪个位置定义的，this就跟这个位置的this指向相同）。\n\n例如\n\n```js\nconst obj = { name: 'zrtty' };\n\nfunction fn1() {\n  console.log(this); // { name: 'zrtty' }\n  return () => {\n    console.log(this);\n  };\n}\n\nconst fn2 = fn1.call(obj);\nfn2(); // { name: 'zrtty' }\n```\n\n`fn1.call(obj)`执行之后，第一个this就指向了被调用的对象obj；而箭头函数是在fn1()函数里定义的，所以第二个this和第一个this指向的是同一个位置。\n\n**面试题**\n\n```js\nvar name = '许嵩';\nvar obj = {\n    name: 'zrtty',\n    sayHello: () => {\n        console.log(this.name);\n    },\n};\n\nobj.sayHello();\n```\n\n打印结果是`许嵩`。因为obj对象并不产生作用域，定义在obj内部的sayHello箭头函数实际仍定义在全局作用域中，也就是this指向window。\n\n### 参数默认值\n\n传统写法：\n\n```js\nfunction fn(param) {\n    let p = param || 'hello';\n    console.log(p);\n}\n```\n\nES6写法：\n\n```js\nfunction fn(param = 'hello') {\n    console.log(param);\n}\n```\n\n**注：**默认值的后面，不能再有**没有默认值的变量**\n\n### 剩余参数\n\n**剩余参数**允许我们将不确定数量的**剩余的元素**放到一个**数组**中。\n\n比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。\n\n**传统写法（会报错）**\n\n```js\nfunction fn(a, b, c) {\n    console.log(a);\n    console.log(b);\n    console.log(c);\n    console.log(d);\n}\n\nfn(1, 2, 3);\n```\n\n**ES6 写法**：\n\n```js\nconst fn = (...args) => {\n    //当不确定方法的参数时，可以使用剩余参数\n    console.log(args[0]);\n    console.log(args[1]);\n    console.log(args[2]);\n    console.log(args[3]);\n};\n\nfn(1, 2); // 1 2 undefined undefined\nfn(1, 2, 3); // 1 2 3 undefined\n```\n\n方法的定义中了四个参数，但调用函数时只使用了三个参数，ES6 中并不会报错。\n\n**注：**args 参数之后，不能再加别的参数，否则编译报错。\n\n## 扩展语法（展开语法）\n\n扩展运算符和剩余参数是相反的。\n\n剩余参数是将剩余的元素放到一个数组中；而扩展运算符是将数组或者对象拆分成逗号分隔的参数序列。\n\n如\n\n```js\nconst arr = [10, 20, 30];\n\nconsole.log(arr); // [ 10, 20, 30 ]\nconsole.log(...arr); // 10 20 30\nconsole.log(10, 20, 30); // 10 20 30\n```\n\n**举例1：数组赋值**\n\n```js\nlet arr1 = ['www', 'smyhvae', 'com'];\nlet arr2 = arr1; // 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址\nconsole.log('arr1:' + arr1); // arr1:www,smyhvae,com\nconsole.log('arr2:' + arr2); // arr2:www,smyhvae,com\n\narr2.push('你懂得'); //往 arr2 里添加一部分内容\nconsole.log('arr1:' + arr1); // arr1:www,smyhvae,com,你懂得\nconsole.log('arr2:' + arr2); // arr2:www,smyhvae,com,你懂得\n```\n\n```js\nlet arr1 = ['www', 'smyhvae', 'com'];\nlet arr2 = [...arr1]; //【重要代码】arr2 会重新开辟内存地址\nconsole.log('arr1:' + arr1);\nconsole.log('arr2:' + arr2);\n\narr2.push('你懂得'); //往arr2 里添加一部分内容\nconsole.log('arr1:' + arr1); // arr1:www,smyhvae,com\nconsole.log('arr2:' + arr2); // arr2:www,smyhvae,com,你懂得\n```\n\n**举例2：合并数组**\n\n```js\nlet arr1 = ['王一', '王二', '王三'];\nlet arr2 = ['王四', '王五', '王六'];\n// ...arr1  // '王一','王二','王三'\n// ...arr2  // '王四','王五','王六'\n\n// 方法1\nlet arr3 = [...arr1, ...arr2];\nconsole.log(arr3); // [\"王一\", \"王二\", \"王三\", \"王四\", \"王五\", \"王六\"]\n\n// 方法2\narr1.push(...arr2);\nconsole.log(arr1); // [\"王一\", \"王二\", \"王三\", \"王四\", \"王五\", \"王六\"]\n```\n\n**举例3：将伪数组或者可遍历对象转换为真正的数组**\n\n```js\nconst myDivs = document.getElementsByClassName('div');\nconst divArr = [...myDivs]; // 利用扩展运算符，将伪数组转为真正的数组\n```\n\n## Set数据结构\n\nES6提供了新的数据结构Set。Set类似于数组，但成员的值都是唯一的，没有重复的值。\n\n**Set的创建**\n\n```js\nconst set1 = new Set();\nconsole.log(set1.size);\n```\n\n**Set的用法之一：数组去重**\n\n```js\nconst set2 = new Set(['张三', '李四', '王五', '张三']); // 注意，这个数组里有重复的值\n\n// 注意，这里的 set2 并不是数组，而是一个单纯的 Set 数据结构\nconsole.log(set2); // {\"张三\", \"李四\", \"王五\"}\nconsole.log(typeof set2); // object\nconsole.log(set2 instanceof Array); \n\n// 通过扩展运算符，拿到 set 中的元素（用逗号分隔的序列）\n// ...set2 //  \"张三\", \"李四\", \"王五\"\n\n// 注意，到这一步，才获取到了真正的数组\nconsole.log([...set2]); // [\"张三\", \"李四\", \"王五\"]\n```\n\n","slug":"31天JavaScript学习-第14天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a0000a7owzdfwm4st4","content":"<h1 id=\"ES6语法\"><a href=\"#ES6语法\" class=\"headerlink\" title=\"ES6语法\"></a><strong>ES6语法</strong></h1><span id=\"more\"></span>\n\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ES 的全称是 ECMAScript，它是由 ECMA 国际标准化组织 制定的一套<strong>脚本语言的标准化规范</strong>。</p>\n<p>ES6 是新的 JS 语法标准。<strong>ES6 实际上是一个泛指，泛指 ES 2015 及后续的版本</strong>。</p>\n<blockquote>\n<p>掌握 ES6 之后，如果你的业务需要考虑 ES5 的兼容性，则可以这样做：写 ES6 语法的 js 代码，然后通过 <code>Babel</code>将 ES6 转换为 ES5。</p>\n</blockquote>\n<blockquote>\n<p>PS：我们在写代码时，能用单引号尽量用单引号，而不是双引号，前者在压缩之后，程序执行会更快。</p>\n</blockquote>\n<h2 id=\"let、const和块级作用域\"><a href=\"#let、const和块级作用域\" class=\"headerlink\" title=\"let、const和块级作用域\"></a>let、const和块级作用域</h2><p>ES6中，新增了let和const来定义变量：</p>\n<ul>\n<li><strong>let：</strong>定义变量，替代var。用let声明的变量，具有块级作用域，只在局部起作用。</li>\n<li><strong>const：</strong>定义常量，定义后不可修改。用const声明的常量，只在块级作用域内起作用，且必须在声明时赋值。</li>\n</ul>\n<p><strong>暂时性死区（TDZ）</strong></p>\n<p>ES6规定，使用let/const声明的变量，会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。</p>\n<p><strong>let 和 const 的特点【重要】</strong></p>\n<ul>\n<li>不属于顶层对象 Window</li>\n<li>不允许重复声明</li>\n<li>不存在变量提升</li>\n<li>暂时性死区</li>\n<li>支持块级作用域</li>\n</ul>\n<p>相反， 用<code>var</code>声明的变量：存在变量提升、可以重复声明、<strong>没有块级作用域</strong>。</p>\n<h2 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a>变量的解构赋值</h2><p>ES6允许我们，按照一一对应的方式，从数组或对象中提取值，再将提取出来的值赋值给变量。</p>\n<h3 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h3><p>将数组中的值按照位置提取出来，然后赋值给变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<p><strong>两边数量不相等的情况：</strong></p>\n<ul>\n<li><strong>变量数量&gt;值的数量：</strong>多余的变量被赋值为undefined</li>\n<li><strong>变量数量&lt;值的数量：</strong>正常赋值</li>\n</ul>\n<p><strong>解构时，左边变量可以有默认值</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c=<span class=\"number\">10</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>赋值中含有undefined和null的情况</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c=<span class=\"number\">10</span>] = [<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c=<span class=\"number\">10</span>] = [<span class=\"number\">1</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h3><p>将对象中的值按照属性匹配的方式提取出来，然后赋值给变量。</p>\n<p>ES6前，我们从接口拿到json数据后，一般这么赋值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = json.name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> age = json.age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sex = json.sex;</span><br></pre></td></tr></table></figure>\n\n<p>ES6后，可以简化成</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;男&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; age, name, sex &#125; = person; <span class=\"comment\">// 对象的结构赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// 打印结果：zrtty</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age); <span class=\"comment\">// 打印结果：28</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sex); <span class=\"comment\">// 打印结果：男</span></span><br></pre></td></tr></table></figure>\n\n<p>上方代码可以看出，对象的解构与数组的结构，有一个重要的区别：<strong>数组</strong>的元素是按次序排列的，变量的取值由它的<strong>位置</strong>决定；而<strong>对象的属性没有次序</strong>，是<strong>根据键来取值</strong>的。</p>\n<p><strong>两边数量不相等的情况：</strong></p>\n<ul>\n<li><strong>变量数量&gt;值的数量：</strong>多余的变量被赋值为undefined</li>\n<li><strong>变量数量&lt;值的数量：</strong>正常赋值</li>\n</ul>\n<p><strong>变量自定义命名解构赋值</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">name</span>: myName, <span class=\"attr\">age</span>: myAge &#125; = person; <span class=\"comment\">// 对象的结构赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myName); <span class=\"comment\">// 打印结果：zrtty</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myAge); <span class=\"comment\">// 打印结果：28</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// 打印报错：Uncaught ReferenceError: name is not defined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age); <span class=\"comment\">// 打印报错：Uncaught ReferenceError: age is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>圆括号的使用</strong></p>\n<p>如果变量 foo 在解构之前就已经定义了，此时你再去解构，就会出现问题。下面是错误的代码，编译会报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#x27;haha&#x27;;</span><br><span class=\"line\">&#123; foo &#125; = &#123; foo: &#x27;smyhvae&#x27; &#125;;</span><br><span class=\"line\">console.log(foo);</span><br></pre></td></tr></table></figure>\n\n<p>要解决报错，只要在解构的语句外边，加一个圆括号即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#x27;haha&#x27;;</span><br><span class=\"line\">(&#123; foo &#125; = &#123; foo: &#x27;smyhvae&#x27; &#125;);</span><br><span class=\"line\">console.log(foo); //输出结果：smyhvae</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串结构\"><a href=\"#字符串结构\" class=\"headerlink\" title=\"字符串结构\"></a>字符串结构</h3><p>字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。举例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d] = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// h</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// e</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// l</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">// string</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6的箭头函数语法：</p>\n<p><code>(arg1, agr2, ...) =&gt; &#123; 函数体 &#125;</code></p>\n<p>注：</p>\n<ul>\n<li>如果有且仅有1个形参，则<code>()</code>可以省略</li>\n<li>如果函数体内有且仅有1条语句，则<code>&#123;&#125;</code>可以省略，前提是这条语句必须时return语句，且返回语句无需return关键字</li>\n</ul>\n<p>如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;haa&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn2 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;haha&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn3 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;haha&#x27;</span> + a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn4 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"this指向\"><a href=\"#this指向\" class=\"headerlink\" title=\"this指向\"></a>this指向</h3><p>箭头函数的作用只是为了写法更简洁吗？不仅仅是这个原因，还有一个很大的作用是this的指向有关。</p>\n<p><strong>this指向的区别</strong></p>\n<ul>\n<li><strong>ES5：</strong>this指向函数被调用的对象</li>\n<li><strong>ES6：</strong>箭头函数本身不绑定this，this指向的是箭头函数定义位置的this（箭头函数在哪个位置定义的，this就跟这个位置的this指向相同）。</li>\n</ul>\n<p>例如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>); <span class=\"comment\">// &#123; name: &#x27;zrtty&#x27; &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn2 = fn1.call(obj);</span><br><span class=\"line\">fn2(); <span class=\"comment\">// &#123; name: &#x27;zrtty&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>fn1.call(obj)</code>执行之后，第一个this就指向了被调用的对象obj；而箭头函数是在fn1()函数里定义的，所以第二个this和第一个this指向的是同一个位置。</p>\n<p><strong>面试题</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;许嵩&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.sayHello();</span><br></pre></td></tr></table></figure>\n\n<p>打印结果是<code>许嵩</code>。因为obj对象并不产生作用域，定义在obj内部的sayHello箭头函数实际仍定义在全局作用域中，也就是this指向window。</p>\n<h3 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h3><p>传统写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = param || <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ES6写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">param = <span class=\"string\">&#x27;hello&#x27;</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(param);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：</strong>默认值的后面，不能再有<strong>没有默认值的变量</strong></p>\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><p><strong>剩余参数</strong>允许我们将不确定数量的<strong>剩余的元素</strong>放到一个<strong>数组</strong>中。</p>\n<p>比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。</p>\n<p><strong>传统写法（会报错）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(c);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>ES6 写法</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fn = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当不确定方法的参数时，可以使用剩余参数</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args[<span class=\"number\">3</span>]);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 1 2 undefined undefined</span></span><br><span class=\"line\">fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 1 2 3 undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>方法的定义中了四个参数，但调用函数时只使用了三个参数，ES6 中并不会报错。</p>\n<p><strong>注：</strong>args 参数之后，不能再加别的参数，否则编译报错。</p>\n<h2 id=\"扩展语法（展开语法）\"><a href=\"#扩展语法（展开语法）\" class=\"headerlink\" title=\"扩展语法（展开语法）\"></a>扩展语法（展开语法）</h2><p>扩展运算符和剩余参数是相反的。</p>\n<p>剩余参数是将剩余的元素放到一个数组中；而扩展运算符是将数组或者对象拆分成逗号分隔的参数序列。</p>\n<p>如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 10, 20, 30 ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(...arr); <span class=\"comment\">// 10 20 30</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 10 20 30</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>举例1：数组赋值</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"string\">&#x27;www&#x27;</span>, <span class=\"string\">&#x27;smyhvae&#x27;</span>, <span class=\"string\">&#x27;com&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = arr1; <span class=\"comment\">// 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr1:&#x27;</span> + arr1); <span class=\"comment\">// arr1:www,smyhvae,com</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr2:&#x27;</span> + arr2); <span class=\"comment\">// arr2:www,smyhvae,com</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr2.push(<span class=\"string\">&#x27;你懂得&#x27;</span>); <span class=\"comment\">//往 arr2 里添加一部分内容</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr1:&#x27;</span> + arr1); <span class=\"comment\">// arr1:www,smyhvae,com,你懂得</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr2:&#x27;</span> + arr2); <span class=\"comment\">// arr2:www,smyhvae,com,你懂得</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"string\">&#x27;www&#x27;</span>, <span class=\"string\">&#x27;smyhvae&#x27;</span>, <span class=\"string\">&#x27;com&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [...arr1]; <span class=\"comment\">//【重要代码】arr2 会重新开辟内存地址</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr1:&#x27;</span> + arr1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr2:&#x27;</span> + arr2);</span><br><span class=\"line\"></span><br><span class=\"line\">arr2.push(<span class=\"string\">&#x27;你懂得&#x27;</span>); <span class=\"comment\">//往arr2 里添加一部分内容</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr1:&#x27;</span> + arr1); <span class=\"comment\">// arr1:www,smyhvae,com</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr2:&#x27;</span> + arr2); <span class=\"comment\">// arr2:www,smyhvae,com,你懂得</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>举例2：合并数组</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"string\">&#x27;王一&#x27;</span>, <span class=\"string\">&#x27;王二&#x27;</span>, <span class=\"string\">&#x27;王三&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [<span class=\"string\">&#x27;王四&#x27;</span>, <span class=\"string\">&#x27;王五&#x27;</span>, <span class=\"string\">&#x27;王六&#x27;</span>];</span><br><span class=\"line\"><span class=\"comment\">// ...arr1  // &#x27;王一&#x27;,&#x27;王二&#x27;,&#x27;王三&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// ...arr2  // &#x27;王四&#x27;,&#x27;王五&#x27;,&#x27;王六&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = [...arr1, ...arr2];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3); <span class=\"comment\">// [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;, &quot;王四&quot;, &quot;王五&quot;, &quot;王六&quot;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2</span></span><br><span class=\"line\">arr1.push(...arr2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1); <span class=\"comment\">// [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;, &quot;王四&quot;, &quot;王五&quot;, &quot;王六&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>举例3：将伪数组或者可遍历对象转换为真正的数组</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myDivs = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">&#x27;div&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> divArr = [...myDivs]; <span class=\"comment\">// 利用扩展运算符，将伪数组转为真正的数组</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set数据结构\"><a href=\"#Set数据结构\" class=\"headerlink\" title=\"Set数据结构\"></a>Set数据结构</h2><p>ES6提供了新的数据结构Set。Set类似于数组，但成员的值都是唯一的，没有重复的值。</p>\n<p><strong>Set的创建</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1.size);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Set的用法之一：数组去重</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">&#x27;张三&#x27;</span>, <span class=\"string\">&#x27;李四&#x27;</span>, <span class=\"string\">&#x27;王五&#x27;</span>, <span class=\"string\">&#x27;张三&#x27;</span>]); <span class=\"comment\">// 注意，这个数组里有重复的值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意，这里的 set2 并不是数组，而是一个单纯的 Set 数据结构</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set2); <span class=\"comment\">// &#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> set2); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set2 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过扩展运算符，拿到 set 中的元素（用逗号分隔的序列）</span></span><br><span class=\"line\"><span class=\"comment\">// ...set2 //  &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意，到这一步，才获取到了真正的数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([...set2]); <span class=\"comment\">// [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"ES6语法\"><a href=\"#ES6语法\" class=\"headerlink\" title=\"ES6语法\"></a><strong>ES6语法</strong></h1>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ES 的全称是 ECMAScript，它是由 ECMA 国际标准化组织 制定的一套<strong>脚本语言的标准化规范</strong>。</p>\n<p>ES6 是新的 JS 语法标准。<strong>ES6 实际上是一个泛指，泛指 ES 2015 及后续的版本</strong>。</p>\n<blockquote>\n<p>掌握 ES6 之后，如果你的业务需要考虑 ES5 的兼容性，则可以这样做：写 ES6 语法的 js 代码，然后通过 <code>Babel</code>将 ES6 转换为 ES5。</p>\n</blockquote>\n<blockquote>\n<p>PS：我们在写代码时，能用单引号尽量用单引号，而不是双引号，前者在压缩之后，程序执行会更快。</p>\n</blockquote>\n<h2 id=\"let、const和块级作用域\"><a href=\"#let、const和块级作用域\" class=\"headerlink\" title=\"let、const和块级作用域\"></a>let、const和块级作用域</h2><p>ES6中，新增了let和const来定义变量：</p>\n<ul>\n<li><strong>let：</strong>定义变量，替代var。用let声明的变量，具有块级作用域，只在局部起作用。</li>\n<li><strong>const：</strong>定义常量，定义后不可修改。用const声明的常量，只在块级作用域内起作用，且必须在声明时赋值。</li>\n</ul>\n<p><strong>暂时性死区（TDZ）</strong></p>\n<p>ES6规定，使用let/const声明的变量，会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。</p>\n<p><strong>let 和 const 的特点【重要】</strong></p>\n<ul>\n<li>不属于顶层对象 Window</li>\n<li>不允许重复声明</li>\n<li>不存在变量提升</li>\n<li>暂时性死区</li>\n<li>支持块级作用域</li>\n</ul>\n<p>相反， 用<code>var</code>声明的变量：存在变量提升、可以重复声明、<strong>没有块级作用域</strong>。</p>\n<h2 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a>变量的解构赋值</h2><p>ES6允许我们，按照一一对应的方式，从数组或对象中提取值，再将提取出来的值赋值给变量。</p>\n<h3 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h3><p>将数组中的值按照位置提取出来，然后赋值给变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<p><strong>两边数量不相等的情况：</strong></p>\n<ul>\n<li><strong>变量数量&gt;值的数量：</strong>多余的变量被赋值为undefined</li>\n<li><strong>变量数量&lt;值的数量：</strong>正常赋值</li>\n</ul>\n<p><strong>解构时，左边变量可以有默认值</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c=<span class=\"number\">10</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>赋值中含有undefined和null的情况</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c=<span class=\"number\">10</span>] = [<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c=<span class=\"number\">10</span>] = [<span class=\"number\">1</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// null</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h3><p>将对象中的值按照属性匹配的方式提取出来，然后赋值给变量。</p>\n<p>ES6前，我们从接口拿到json数据后，一般这么赋值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = json.name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> age = json.age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sex = json.sex;</span><br></pre></td></tr></table></figure>\n\n<p>ES6后，可以简化成</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;男&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; age, name, sex &#125; = person; <span class=\"comment\">// 对象的结构赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// 打印结果：zrtty</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age); <span class=\"comment\">// 打印结果：28</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sex); <span class=\"comment\">// 打印结果：男</span></span><br></pre></td></tr></table></figure>\n\n<p>上方代码可以看出，对象的解构与数组的结构，有一个重要的区别：<strong>数组</strong>的元素是按次序排列的，变量的取值由它的<strong>位置</strong>决定；而<strong>对象的属性没有次序</strong>，是<strong>根据键来取值</strong>的。</p>\n<p><strong>两边数量不相等的情况：</strong></p>\n<ul>\n<li><strong>变量数量&gt;值的数量：</strong>多余的变量被赋值为undefined</li>\n<li><strong>变量数量&lt;值的数量：</strong>正常赋值</li>\n</ul>\n<p><strong>变量自定义命名解构赋值</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">name</span>: myName, <span class=\"attr\">age</span>: myAge &#125; = person; <span class=\"comment\">// 对象的结构赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myName); <span class=\"comment\">// 打印结果：zrtty</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myAge); <span class=\"comment\">// 打印结果：28</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// 打印报错：Uncaught ReferenceError: name is not defined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age); <span class=\"comment\">// 打印报错：Uncaught ReferenceError: age is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>圆括号的使用</strong></p>\n<p>如果变量 foo 在解构之前就已经定义了，此时你再去解构，就会出现问题。下面是错误的代码，编译会报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#x27;haha&#x27;;</span><br><span class=\"line\">&#123; foo &#125; = &#123; foo: &#x27;smyhvae&#x27; &#125;;</span><br><span class=\"line\">console.log(foo);</span><br></pre></td></tr></table></figure>\n\n<p>要解决报错，只要在解构的语句外边，加一个圆括号即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let foo = &#x27;haha&#x27;;</span><br><span class=\"line\">(&#123; foo &#125; = &#123; foo: &#x27;smyhvae&#x27; &#125;);</span><br><span class=\"line\">console.log(foo); //输出结果：smyhvae</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串结构\"><a href=\"#字符串结构\" class=\"headerlink\" title=\"字符串结构\"></a>字符串结构</h3><p>字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。举例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d] = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// h</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// e</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">// l</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">// string</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6的箭头函数语法：</p>\n<p><code>(arg1, agr2, ...) =&gt; &#123; 函数体 &#125;</code></p>\n<p>注：</p>\n<ul>\n<li>如果有且仅有1个形参，则<code>()</code>可以省略</li>\n<li>如果函数体内有且仅有1条语句，则<code>&#123;&#125;</code>可以省略，前提是这条语句必须时return语句，且返回语句无需return关键字</li>\n</ul>\n<p>如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;haa&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn2 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;haha&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn3 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;haha&#x27;</span> + a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn4 = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"this指向\"><a href=\"#this指向\" class=\"headerlink\" title=\"this指向\"></a>this指向</h3><p>箭头函数的作用只是为了写法更简洁吗？不仅仅是这个原因，还有一个很大的作用是this的指向有关。</p>\n<p><strong>this指向的区别</strong></p>\n<ul>\n<li><strong>ES5：</strong>this指向函数被调用的对象</li>\n<li><strong>ES6：</strong>箭头函数本身不绑定this，this指向的是箭头函数定义位置的this（箭头函数在哪个位置定义的，this就跟这个位置的this指向相同）。</li>\n</ul>\n<p>例如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>); <span class=\"comment\">// &#123; name: &#x27;zrtty&#x27; &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn2 = fn1.call(obj);</span><br><span class=\"line\">fn2(); <span class=\"comment\">// &#123; name: &#x27;zrtty&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>fn1.call(obj)</code>执行之后，第一个this就指向了被调用的对象obj；而箭头函数是在fn1()函数里定义的，所以第二个this和第一个this指向的是同一个位置。</p>\n<p><strong>面试题</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;许嵩&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.sayHello();</span><br></pre></td></tr></table></figure>\n\n<p>打印结果是<code>许嵩</code>。因为obj对象并不产生作用域，定义在obj内部的sayHello箭头函数实际仍定义在全局作用域中，也就是this指向window。</p>\n<h3 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h3><p>传统写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> p = param || <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ES6写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">param = <span class=\"string\">&#x27;hello&#x27;</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(param);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：</strong>默认值的后面，不能再有<strong>没有默认值的变量</strong></p>\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><p><strong>剩余参数</strong>允许我们将不确定数量的<strong>剩余的元素</strong>放到一个<strong>数组</strong>中。</p>\n<p>比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。</p>\n<p><strong>传统写法（会报错）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(c);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>ES6 写法</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fn = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当不确定方法的参数时，可以使用剩余参数</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args[<span class=\"number\">3</span>]);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 1 2 undefined undefined</span></span><br><span class=\"line\">fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 1 2 3 undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>方法的定义中了四个参数，但调用函数时只使用了三个参数，ES6 中并不会报错。</p>\n<p><strong>注：</strong>args 参数之后，不能再加别的参数，否则编译报错。</p>\n<h2 id=\"扩展语法（展开语法）\"><a href=\"#扩展语法（展开语法）\" class=\"headerlink\" title=\"扩展语法（展开语法）\"></a>扩展语法（展开语法）</h2><p>扩展运算符和剩余参数是相反的。</p>\n<p>剩余参数是将剩余的元素放到一个数组中；而扩展运算符是将数组或者对象拆分成逗号分隔的参数序列。</p>\n<p>如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ 10, 20, 30 ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(...arr); <span class=\"comment\">// 10 20 30</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 10 20 30</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>举例1：数组赋值</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"string\">&#x27;www&#x27;</span>, <span class=\"string\">&#x27;smyhvae&#x27;</span>, <span class=\"string\">&#x27;com&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = arr1; <span class=\"comment\">// 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr1:&#x27;</span> + arr1); <span class=\"comment\">// arr1:www,smyhvae,com</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr2:&#x27;</span> + arr2); <span class=\"comment\">// arr2:www,smyhvae,com</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr2.push(<span class=\"string\">&#x27;你懂得&#x27;</span>); <span class=\"comment\">//往 arr2 里添加一部分内容</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr1:&#x27;</span> + arr1); <span class=\"comment\">// arr1:www,smyhvae,com,你懂得</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr2:&#x27;</span> + arr2); <span class=\"comment\">// arr2:www,smyhvae,com,你懂得</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"string\">&#x27;www&#x27;</span>, <span class=\"string\">&#x27;smyhvae&#x27;</span>, <span class=\"string\">&#x27;com&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [...arr1]; <span class=\"comment\">//【重要代码】arr2 会重新开辟内存地址</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr1:&#x27;</span> + arr1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr2:&#x27;</span> + arr2);</span><br><span class=\"line\"></span><br><span class=\"line\">arr2.push(<span class=\"string\">&#x27;你懂得&#x27;</span>); <span class=\"comment\">//往arr2 里添加一部分内容</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr1:&#x27;</span> + arr1); <span class=\"comment\">// arr1:www,smyhvae,com</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr2:&#x27;</span> + arr2); <span class=\"comment\">// arr2:www,smyhvae,com,你懂得</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>举例2：合并数组</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"string\">&#x27;王一&#x27;</span>, <span class=\"string\">&#x27;王二&#x27;</span>, <span class=\"string\">&#x27;王三&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [<span class=\"string\">&#x27;王四&#x27;</span>, <span class=\"string\">&#x27;王五&#x27;</span>, <span class=\"string\">&#x27;王六&#x27;</span>];</span><br><span class=\"line\"><span class=\"comment\">// ...arr1  // &#x27;王一&#x27;,&#x27;王二&#x27;,&#x27;王三&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// ...arr2  // &#x27;王四&#x27;,&#x27;王五&#x27;,&#x27;王六&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = [...arr1, ...arr2];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3); <span class=\"comment\">// [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;, &quot;王四&quot;, &quot;王五&quot;, &quot;王六&quot;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2</span></span><br><span class=\"line\">arr1.push(...arr2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1); <span class=\"comment\">// [&quot;王一&quot;, &quot;王二&quot;, &quot;王三&quot;, &quot;王四&quot;, &quot;王五&quot;, &quot;王六&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>举例3：将伪数组或者可遍历对象转换为真正的数组</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myDivs = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">&#x27;div&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> divArr = [...myDivs]; <span class=\"comment\">// 利用扩展运算符，将伪数组转为真正的数组</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set数据结构\"><a href=\"#Set数据结构\" class=\"headerlink\" title=\"Set数据结构\"></a>Set数据结构</h2><p>ES6提供了新的数据结构Set。Set类似于数组，但成员的值都是唯一的，没有重复的值。</p>\n<p><strong>Set的创建</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1.size);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Set的用法之一：数组去重</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">&#x27;张三&#x27;</span>, <span class=\"string\">&#x27;李四&#x27;</span>, <span class=\"string\">&#x27;王五&#x27;</span>, <span class=\"string\">&#x27;张三&#x27;</span>]); <span class=\"comment\">// 注意，这个数组里有重复的值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意，这里的 set2 并不是数组，而是一个单纯的 Set 数据结构</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set2); <span class=\"comment\">// &#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> set2); <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set2 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过扩展运算符，拿到 set 中的元素（用逗号分隔的序列）</span></span><br><span class=\"line\"><span class=\"comment\">// ...set2 //  &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意，到这一步，才获取到了真正的数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([...set2]); <span class=\"comment\">// [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</span></span><br></pre></td></tr></table></figure>"},{"title":"31天JavaScript学习-第16天","reprint":false,"date":"2022-03-10T07:44:43.000Z","updated":"2022-03-10T07:44:43.000Z","conver":null,"_content":"\n# Ajax（一）\n\n<!--more-->\n\nAjax：Asynchronous JavaScript And XML（异步JavaScript和XML）。Ajax的核心是JS对象：XMLHttpRequest\n\n即可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。\n\n## Ajax原理\n\n一个完整的http请求需要的是：\n\n- 请求的网址、请求的方法get/post\n- 提交请求的内容数据、请求主体\n- 接收响应回来的内容\n\n对应的，发送Ajax请求的步骤：\n\n1. 创建异步对象，即XMLHttpRequest对象\n2. 使用open方法设置请求参数。`open(method, url, async)`\n3. 发送请求：`send()`\n4. 注册事件：注册`onreadystatechange`事件，状态改变时就会调用\n5. 服务端响应，获取返回的数据\n\n话不多说，手写一个Ajax：\n\n```js\n// 创建XMLHttpRequest对象\nlet xmlhttp = new XMLHttpRequest();\n\n// 设置请求的参数。请求的方法、请求的url\n// 调用open方法并不会真正发送请求，而只是启动一个请求以备发送\n// 第三个参数true（异步）false（同步），默认true\nxmlhttp.open('get', 'ajax.php', false);\n\n// 发送请求\n// send方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据\n// 则必须传入null。调用send()之后，请求就会被分派到服务器\nxmlhttp.send(null);\n\n// 注册事件\nxmlhttp.onreadystatechange = function (){\n  // 为了保证数据完整返回，一般判断两个值\n  if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n    // 服务端响应\n    console.log('数据返回成功' + JSON.stringify(xmlhttp.responseText));\n  }\n};\n```\n\n在收到响应后，响应的数据会自动填充XHR对象的属性：\n\n- **responseText：**作为响应主体被返回的文本\n- **responseXML：**如果响应的内容类型是\"text/xml\"或\"application/xml\"，这个属性中将保存包含响应数据的XML DOM文档。\n- **status：**响应的HTTP状态\n- **statusText：**HTTP状态的说明\n\n**readyState属性**\n\n多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下：\n\n- **0：**未初始化，尚未调用open()方法\n- **1：**启动，已经调用open()方法，但尚未调用send()方法\n- **2：**发送，已经调用send()方法，但尚未接收到响应\n- **3：**接收，已经接收到部分响应数据\n- **4：**完成，已经接收到全部的响应数据，已经可以在客户端使用了\n\n每次readyState属性值发生变动，都会触发一次readystatechange事件。\n\n## HTTP头部信息\n\n每个HTTP请求和响应都会带有相应的头部信息：\n\n| Head            | Explain                                         |\n| --------------- | ----------------------------------------------- |\n| Accept          | 浏览器能够处理的内容类型                        |\n| Accept-Charset  | 浏览器能够显示的字符集                          |\n| Accept-Encoding | 浏览器能处理的压缩编码                          |\n| Accept-Language | 浏览器当前设置的语言                            |\n| Connection      | 浏览器与服务器之间连接的类型                    |\n| Cookie          | 当前页面设置的任何Cookie                        |\n| Host            | 发出请求的页面所在域                            |\n| Referer         | 发出请求的页面的URI（HTTP规范把referrer拼错了） |\n| User-Agent      | 浏览器的用户代理字符串                          |\n\n使用`setRequestHeader()`方法可以设置自定义的请求头部信息。接收两个参数：头部字段的名称和头部字段的值。在open()方法之后且调用send()方法之前使用。\n\n## get请求\n\nget请求将查询字符串参数追加到URL末尾，以便将信息发送给服务器。对于XHR对象，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，而且所有名-值对都必须由&分割：\n\n```js\nfunction addURLParam(url, name, value) {\n  url += (url.indexOf(\"?\") == -1 ? \"?\" : \"&\");\n  url += encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n  return url;\n}\n\nlet url = 'example.php';\nurl = addURLParam(url, \"name\", \"Nick\");\nxmlhttp.open(\"get\", url, false);\n```\n\n## post请求\n\npost请求通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交。\n\n## 封装Ajax请求\n\n```js\nfunction myAjax(url, success, fail) {\n  // 1、创建XMLHttpRequest对象\n  let xmlhttp;\n  if (window.XMLHttpRequest) {\n    xmlhttp = new XMLHttpRequest();\n  } else {\n    xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');\n  }\n  // 2、发送请求\n  xmlhttp.open('GET', url, true);\n  xmlhttp.send();\n  // 3、服务器响应\n  xmlhttp.onreadystatechange = function() {\n    if (xmlhttp.readyState === 4 && xmlhttp.status ===200) {\n      let obj = JSON.parse(xmlhttp.responseText);\n      console.log('数据返回成功' + obj);\n      success && success(xmlhttp.responseText);\n    } else {\n      fail && fail(new Error('接口请求失败'));\n    }\n  };\n}\n\nmyAjax('a.json', (res) => {\n  console.log(res);\n});\n```\n\n实际开发中，经常会涉及接口请求之间的依赖：即需要上一个接口请求返回的数据，来发送本次请求。这种层层嵌套的代码，会导致**回调地狱**的问题，不利于后续的维护。ES6使用Promise来解决该问题。\n\n## JQuery中的Ajax\n\n```js\n$.ajax({\n  url: 'https://xxx.com/getUserInfo.php',\n  data: 'name=fox&age=18',\n  type: 'GET',\n  success: function (argument) {\n    console.log('success');\n  },\n  beforeSend: function (argument) { },\n  error: function (argument) {\n    console.log('error');\n  }\n});\n```\n\n","source":"_posts/31天JavaScript学习-第16天.md","raw":"---\ntitle: 31天JavaScript学习-第16天\nreprint: false\ndate: 2022-03-10 15:44:43\nupdated: 2022-03-10 15:44:43\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# Ajax（一）\n\n<!--more-->\n\nAjax：Asynchronous JavaScript And XML（异步JavaScript和XML）。Ajax的核心是JS对象：XMLHttpRequest\n\n即可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。\n\n## Ajax原理\n\n一个完整的http请求需要的是：\n\n- 请求的网址、请求的方法get/post\n- 提交请求的内容数据、请求主体\n- 接收响应回来的内容\n\n对应的，发送Ajax请求的步骤：\n\n1. 创建异步对象，即XMLHttpRequest对象\n2. 使用open方法设置请求参数。`open(method, url, async)`\n3. 发送请求：`send()`\n4. 注册事件：注册`onreadystatechange`事件，状态改变时就会调用\n5. 服务端响应，获取返回的数据\n\n话不多说，手写一个Ajax：\n\n```js\n// 创建XMLHttpRequest对象\nlet xmlhttp = new XMLHttpRequest();\n\n// 设置请求的参数。请求的方法、请求的url\n// 调用open方法并不会真正发送请求，而只是启动一个请求以备发送\n// 第三个参数true（异步）false（同步），默认true\nxmlhttp.open('get', 'ajax.php', false);\n\n// 发送请求\n// send方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据\n// 则必须传入null。调用send()之后，请求就会被分派到服务器\nxmlhttp.send(null);\n\n// 注册事件\nxmlhttp.onreadystatechange = function (){\n  // 为了保证数据完整返回，一般判断两个值\n  if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n    // 服务端响应\n    console.log('数据返回成功' + JSON.stringify(xmlhttp.responseText));\n  }\n};\n```\n\n在收到响应后，响应的数据会自动填充XHR对象的属性：\n\n- **responseText：**作为响应主体被返回的文本\n- **responseXML：**如果响应的内容类型是\"text/xml\"或\"application/xml\"，这个属性中将保存包含响应数据的XML DOM文档。\n- **status：**响应的HTTP状态\n- **statusText：**HTTP状态的说明\n\n**readyState属性**\n\n多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下：\n\n- **0：**未初始化，尚未调用open()方法\n- **1：**启动，已经调用open()方法，但尚未调用send()方法\n- **2：**发送，已经调用send()方法，但尚未接收到响应\n- **3：**接收，已经接收到部分响应数据\n- **4：**完成，已经接收到全部的响应数据，已经可以在客户端使用了\n\n每次readyState属性值发生变动，都会触发一次readystatechange事件。\n\n## HTTP头部信息\n\n每个HTTP请求和响应都会带有相应的头部信息：\n\n| Head            | Explain                                         |\n| --------------- | ----------------------------------------------- |\n| Accept          | 浏览器能够处理的内容类型                        |\n| Accept-Charset  | 浏览器能够显示的字符集                          |\n| Accept-Encoding | 浏览器能处理的压缩编码                          |\n| Accept-Language | 浏览器当前设置的语言                            |\n| Connection      | 浏览器与服务器之间连接的类型                    |\n| Cookie          | 当前页面设置的任何Cookie                        |\n| Host            | 发出请求的页面所在域                            |\n| Referer         | 发出请求的页面的URI（HTTP规范把referrer拼错了） |\n| User-Agent      | 浏览器的用户代理字符串                          |\n\n使用`setRequestHeader()`方法可以设置自定义的请求头部信息。接收两个参数：头部字段的名称和头部字段的值。在open()方法之后且调用send()方法之前使用。\n\n## get请求\n\nget请求将查询字符串参数追加到URL末尾，以便将信息发送给服务器。对于XHR对象，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，而且所有名-值对都必须由&分割：\n\n```js\nfunction addURLParam(url, name, value) {\n  url += (url.indexOf(\"?\") == -1 ? \"?\" : \"&\");\n  url += encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n  return url;\n}\n\nlet url = 'example.php';\nurl = addURLParam(url, \"name\", \"Nick\");\nxmlhttp.open(\"get\", url, false);\n```\n\n## post请求\n\npost请求通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交。\n\n## 封装Ajax请求\n\n```js\nfunction myAjax(url, success, fail) {\n  // 1、创建XMLHttpRequest对象\n  let xmlhttp;\n  if (window.XMLHttpRequest) {\n    xmlhttp = new XMLHttpRequest();\n  } else {\n    xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');\n  }\n  // 2、发送请求\n  xmlhttp.open('GET', url, true);\n  xmlhttp.send();\n  // 3、服务器响应\n  xmlhttp.onreadystatechange = function() {\n    if (xmlhttp.readyState === 4 && xmlhttp.status ===200) {\n      let obj = JSON.parse(xmlhttp.responseText);\n      console.log('数据返回成功' + obj);\n      success && success(xmlhttp.responseText);\n    } else {\n      fail && fail(new Error('接口请求失败'));\n    }\n  };\n}\n\nmyAjax('a.json', (res) => {\n  console.log(res);\n});\n```\n\n实际开发中，经常会涉及接口请求之间的依赖：即需要上一个接口请求返回的数据，来发送本次请求。这种层层嵌套的代码，会导致**回调地狱**的问题，不利于后续的维护。ES6使用Promise来解决该问题。\n\n## JQuery中的Ajax\n\n```js\n$.ajax({\n  url: 'https://xxx.com/getUserInfo.php',\n  data: 'name=fox&age=18',\n  type: 'GET',\n  success: function (argument) {\n    console.log('success');\n  },\n  beforeSend: function (argument) { },\n  error: function (argument) {\n    console.log('error');\n  }\n});\n```\n\n","slug":"31天JavaScript学习-第16天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a1000c7owzck6a69c9","content":"<h1 id=\"Ajax（一）\"><a href=\"#Ajax（一）\" class=\"headerlink\" title=\"Ajax（一）\"></a>Ajax（一）</h1><span id=\"more\"></span>\n\n<p>Ajax：Asynchronous JavaScript And XML（异步JavaScript和XML）。Ajax的核心是JS对象：XMLHttpRequest</p>\n<p>即可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。</p>\n<h2 id=\"Ajax原理\"><a href=\"#Ajax原理\" class=\"headerlink\" title=\"Ajax原理\"></a>Ajax原理</h2><p>一个完整的http请求需要的是：</p>\n<ul>\n<li>请求的网址、请求的方法get/post</li>\n<li>提交请求的内容数据、请求主体</li>\n<li>接收响应回来的内容</li>\n</ul>\n<p>对应的，发送Ajax请求的步骤：</p>\n<ol>\n<li>创建异步对象，即XMLHttpRequest对象</li>\n<li>使用open方法设置请求参数。<code>open(method, url, async)</code></li>\n<li>发送请求：<code>send()</code></li>\n<li>注册事件：注册<code>onreadystatechange</code>事件，状态改变时就会调用</li>\n<li>服务端响应，获取返回的数据</li>\n</ol>\n<p>话不多说，手写一个Ajax：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建XMLHttpRequest对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置请求的参数。请求的方法、请求的url</span></span><br><span class=\"line\"><span class=\"comment\">// 调用open方法并不会真正发送请求，而只是启动一个请求以备发送</span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数true（异步）false（同步），默认true</span></span><br><span class=\"line\">xmlhttp.open(<span class=\"string\">&#x27;get&#x27;</span>, <span class=\"string\">&#x27;ajax.php&#x27;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送请求</span></span><br><span class=\"line\"><span class=\"comment\">// send方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据</span></span><br><span class=\"line\"><span class=\"comment\">// 则必须传入null。调用send()之后，请求就会被分派到服务器</span></span><br><span class=\"line\">xmlhttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 为了保证数据完整返回，一般判断两个值</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xmlhttp.readyState == <span class=\"number\">4</span> &amp;&amp; xmlhttp.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 服务端响应</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;数据返回成功&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(xmlhttp.responseText));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在收到响应后，响应的数据会自动填充XHR对象的属性：</p>\n<ul>\n<li><strong>responseText：</strong>作为响应主体被返回的文本</li>\n<li><strong>responseXML：</strong>如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含响应数据的XML DOM文档。</li>\n<li><strong>status：</strong>响应的HTTP状态</li>\n<li><strong>statusText：</strong>HTTP状态的说明</li>\n</ul>\n<p><strong>readyState属性</strong></p>\n<p>多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下：</p>\n<ul>\n<li><strong>0：</strong>未初始化，尚未调用open()方法</li>\n<li><strong>1：</strong>启动，已经调用open()方法，但尚未调用send()方法</li>\n<li><strong>2：</strong>发送，已经调用send()方法，但尚未接收到响应</li>\n<li><strong>3：</strong>接收，已经接收到部分响应数据</li>\n<li><strong>4：</strong>完成，已经接收到全部的响应数据，已经可以在客户端使用了</li>\n</ul>\n<p>每次readyState属性值发生变动，都会触发一次readystatechange事件。</p>\n<h2 id=\"HTTP头部信息\"><a href=\"#HTTP头部信息\" class=\"headerlink\" title=\"HTTP头部信息\"></a>HTTP头部信息</h2><p>每个HTTP请求和响应都会带有相应的头部信息：</p>\n<table>\n<thead>\n<tr>\n<th>Head</th>\n<th>Explain</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept</td>\n<td>浏览器能够处理的内容类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>浏览器能够显示的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>浏览器能处理的压缩编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>浏览器当前设置的语言</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>浏览器与服务器之间连接的类型</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>当前页面设置的任何Cookie</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>发出请求的页面所在域</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>发出请求的页面的URI（HTTP规范把referrer拼错了）</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>浏览器的用户代理字符串</td>\n</tr>\n</tbody></table>\n<p>使用<code>setRequestHeader()</code>方法可以设置自定义的请求头部信息。接收两个参数：头部字段的名称和头部字段的值。在open()方法之后且调用send()方法之前使用。</p>\n<h2 id=\"get请求\"><a href=\"#get请求\" class=\"headerlink\" title=\"get请求\"></a>get请求</h2><p>get请求将查询字符串参数追加到URL末尾，以便将信息发送给服务器。对于XHR对象，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，而且所有名-值对都必须由&amp;分割：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addURLParam</span>(<span class=\"params\">url, name, value</span>) </span>&#123;</span><br><span class=\"line\">  url += (url.indexOf(<span class=\"string\">&quot;?&quot;</span>) == -<span class=\"number\">1</span> ? <span class=\"string\">&quot;?&quot;</span> : <span class=\"string\">&quot;&amp;&quot;</span>);</span><br><span class=\"line\">  url += <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">&quot;=&quot;</span> + <span class=\"built_in\">encodeURIComponent</span>(value);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> url;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"string\">&#x27;example.php&#x27;</span>;</span><br><span class=\"line\">url = addURLParam(url, <span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Nick&quot;</span>);</span><br><span class=\"line\">xmlhttp.open(<span class=\"string\">&quot;get&quot;</span>, url, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"post请求\"><a href=\"#post请求\" class=\"headerlink\" title=\"post请求\"></a>post请求</h2><p>post请求通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交。</p>\n<h2 id=\"封装Ajax请求\"><a href=\"#封装Ajax请求\" class=\"headerlink\" title=\"封装Ajax请求\"></a>封装Ajax请求</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAjax</span>(<span class=\"params\">url, success, fail</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1、创建XMLHttpRequest对象</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> xmlhttp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest) &#123;</span><br><span class=\"line\">    xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    xmlhttp = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">&#x27;Microsoft.XMLHTTP&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 2、发送请求</span></span><br><span class=\"line\">  xmlhttp.open(<span class=\"string\">&#x27;GET&#x27;</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  xmlhttp.send();</span><br><span class=\"line\">  <span class=\"comment\">// 3、服务器响应</span></span><br><span class=\"line\">  xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp.readyState === <span class=\"number\">4</span> &amp;&amp; xmlhttp.status ===<span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> obj = <span class=\"built_in\">JSON</span>.parse(xmlhttp.responseText);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;数据返回成功&#x27;</span> + obj);</span><br><span class=\"line\">      success &amp;&amp; success(xmlhttp.responseText);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      fail &amp;&amp; fail(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;接口请求失败&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myAjax(<span class=\"string\">&#x27;a.json&#x27;</span>, <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>实际开发中，经常会涉及接口请求之间的依赖：即需要上一个接口请求返回的数据，来发送本次请求。这种层层嵌套的代码，会导致<strong>回调地狱</strong>的问题，不利于后续的维护。ES6使用Promise来解决该问题。</p>\n<h2 id=\"JQuery中的Ajax\"><a href=\"#JQuery中的Ajax\" class=\"headerlink\" title=\"JQuery中的Ajax\"></a>JQuery中的Ajax</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">&#x27;https://xxx.com/getUserInfo.php&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"string\">&#x27;name=fox&amp;age=18&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;success&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">beforeSend</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argument</span>) </span>&#123; &#125;,</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;error&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"Ajax（一）\"><a href=\"#Ajax（一）\" class=\"headerlink\" title=\"Ajax（一）\"></a>Ajax（一）</h1>","more":"<p>Ajax：Asynchronous JavaScript And XML（异步JavaScript和XML）。Ajax的核心是JS对象：XMLHttpRequest</p>\n<p>即可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。</p>\n<h2 id=\"Ajax原理\"><a href=\"#Ajax原理\" class=\"headerlink\" title=\"Ajax原理\"></a>Ajax原理</h2><p>一个完整的http请求需要的是：</p>\n<ul>\n<li>请求的网址、请求的方法get/post</li>\n<li>提交请求的内容数据、请求主体</li>\n<li>接收响应回来的内容</li>\n</ul>\n<p>对应的，发送Ajax请求的步骤：</p>\n<ol>\n<li>创建异步对象，即XMLHttpRequest对象</li>\n<li>使用open方法设置请求参数。<code>open(method, url, async)</code></li>\n<li>发送请求：<code>send()</code></li>\n<li>注册事件：注册<code>onreadystatechange</code>事件，状态改变时就会调用</li>\n<li>服务端响应，获取返回的数据</li>\n</ol>\n<p>话不多说，手写一个Ajax：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建XMLHttpRequest对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置请求的参数。请求的方法、请求的url</span></span><br><span class=\"line\"><span class=\"comment\">// 调用open方法并不会真正发送请求，而只是启动一个请求以备发送</span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数true（异步）false（同步），默认true</span></span><br><span class=\"line\">xmlhttp.open(<span class=\"string\">&#x27;get&#x27;</span>, <span class=\"string\">&#x27;ajax.php&#x27;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送请求</span></span><br><span class=\"line\"><span class=\"comment\">// send方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据</span></span><br><span class=\"line\"><span class=\"comment\">// 则必须传入null。调用send()之后，请求就会被分派到服务器</span></span><br><span class=\"line\">xmlhttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 为了保证数据完整返回，一般判断两个值</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xmlhttp.readyState == <span class=\"number\">4</span> &amp;&amp; xmlhttp.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 服务端响应</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;数据返回成功&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(xmlhttp.responseText));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在收到响应后，响应的数据会自动填充XHR对象的属性：</p>\n<ul>\n<li><strong>responseText：</strong>作为响应主体被返回的文本</li>\n<li><strong>responseXML：</strong>如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含响应数据的XML DOM文档。</li>\n<li><strong>status：</strong>响应的HTTP状态</li>\n<li><strong>statusText：</strong>HTTP状态的说明</li>\n</ul>\n<p><strong>readyState属性</strong></p>\n<p>多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下：</p>\n<ul>\n<li><strong>0：</strong>未初始化，尚未调用open()方法</li>\n<li><strong>1：</strong>启动，已经调用open()方法，但尚未调用send()方法</li>\n<li><strong>2：</strong>发送，已经调用send()方法，但尚未接收到响应</li>\n<li><strong>3：</strong>接收，已经接收到部分响应数据</li>\n<li><strong>4：</strong>完成，已经接收到全部的响应数据，已经可以在客户端使用了</li>\n</ul>\n<p>每次readyState属性值发生变动，都会触发一次readystatechange事件。</p>\n<h2 id=\"HTTP头部信息\"><a href=\"#HTTP头部信息\" class=\"headerlink\" title=\"HTTP头部信息\"></a>HTTP头部信息</h2><p>每个HTTP请求和响应都会带有相应的头部信息：</p>\n<table>\n<thead>\n<tr>\n<th>Head</th>\n<th>Explain</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept</td>\n<td>浏览器能够处理的内容类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>浏览器能够显示的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>浏览器能处理的压缩编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>浏览器当前设置的语言</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>浏览器与服务器之间连接的类型</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>当前页面设置的任何Cookie</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>发出请求的页面所在域</td>\n</tr>\n<tr>\n<td>Referer</td>\n<td>发出请求的页面的URI（HTTP规范把referrer拼错了）</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>浏览器的用户代理字符串</td>\n</tr>\n</tbody></table>\n<p>使用<code>setRequestHeader()</code>方法可以设置自定义的请求头部信息。接收两个参数：头部字段的名称和头部字段的值。在open()方法之后且调用send()方法之前使用。</p>\n<h2 id=\"get请求\"><a href=\"#get请求\" class=\"headerlink\" title=\"get请求\"></a>get请求</h2><p>get请求将查询字符串参数追加到URL末尾，以便将信息发送给服务器。对于XHR对象，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，而且所有名-值对都必须由&amp;分割：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addURLParam</span>(<span class=\"params\">url, name, value</span>) </span>&#123;</span><br><span class=\"line\">  url += (url.indexOf(<span class=\"string\">&quot;?&quot;</span>) == -<span class=\"number\">1</span> ? <span class=\"string\">&quot;?&quot;</span> : <span class=\"string\">&quot;&amp;&quot;</span>);</span><br><span class=\"line\">  url += <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">&quot;=&quot;</span> + <span class=\"built_in\">encodeURIComponent</span>(value);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> url;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"string\">&#x27;example.php&#x27;</span>;</span><br><span class=\"line\">url = addURLParam(url, <span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Nick&quot;</span>);</span><br><span class=\"line\">xmlhttp.open(<span class=\"string\">&quot;get&quot;</span>, url, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"post请求\"><a href=\"#post请求\" class=\"headerlink\" title=\"post请求\"></a>post请求</h2><p>post请求通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主体提交。</p>\n<h2 id=\"封装Ajax请求\"><a href=\"#封装Ajax请求\" class=\"headerlink\" title=\"封装Ajax请求\"></a>封装Ajax请求</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAjax</span>(<span class=\"params\">url, success, fail</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1、创建XMLHttpRequest对象</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> xmlhttp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest) &#123;</span><br><span class=\"line\">    xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    xmlhttp = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">&#x27;Microsoft.XMLHTTP&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 2、发送请求</span></span><br><span class=\"line\">  xmlhttp.open(<span class=\"string\">&#x27;GET&#x27;</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  xmlhttp.send();</span><br><span class=\"line\">  <span class=\"comment\">// 3、服务器响应</span></span><br><span class=\"line\">  xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp.readyState === <span class=\"number\">4</span> &amp;&amp; xmlhttp.status ===<span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> obj = <span class=\"built_in\">JSON</span>.parse(xmlhttp.responseText);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;数据返回成功&#x27;</span> + obj);</span><br><span class=\"line\">      success &amp;&amp; success(xmlhttp.responseText);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      fail &amp;&amp; fail(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;接口请求失败&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myAjax(<span class=\"string\">&#x27;a.json&#x27;</span>, <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>实际开发中，经常会涉及接口请求之间的依赖：即需要上一个接口请求返回的数据，来发送本次请求。这种层层嵌套的代码，会导致<strong>回调地狱</strong>的问题，不利于后续的维护。ES6使用Promise来解决该问题。</p>\n<h2 id=\"JQuery中的Ajax\"><a href=\"#JQuery中的Ajax\" class=\"headerlink\" title=\"JQuery中的Ajax\"></a>JQuery中的Ajax</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">&#x27;https://xxx.com/getUserInfo.php&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"string\">&#x27;name=fox&amp;age=18&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;success&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">beforeSend</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argument</span>) </span>&#123; &#125;,</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">argument</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;error&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"31天JavaScript学习-第17天.md","reprint":false,"date":"2022-03-13T12:39:56.000Z","updated":"2022-03-13T12:39:56.000Z","conver":null,"_content":"\n# Ajax（二）\n\n<!--more-->\n\n## JSON\n\nJSON(JavaScrtipt Object Notation)：是ES的子集。\n\n**JS中json字符串和js对象的互相转化**\n\n```js\nlet jsObj = JSON.parse(ajax.responseText); // 将JSON字符串转化未js对象\n\nlet Obj = {\n\tname: 'zrtty',\n\tage: 20\n};\nlet jsonStr = JSON.stringify(Obj);\n```\n\n## XMLHttpRequest2级\n\n规范化的XMLHttpRequest。\n\n### FormData\n\n现代Web应用中表单数据的序列化是一项频繁使用的功能。为此定义了FormData类型。\n\n```js\nlet data = new FormData();\ndata.append('name', 'zrtty'); // 分别接收两个参数：键和值\n```\n\n创建的FormData的实例，可以将它直接传给XHR的send()方法，不必明确地在XHR对象上设置请求头部。XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。\n\n### 超时设定\n\nXHR对象timeout属性，表示请求在等待响应多少毫秒后停止。\n\n```js\nxhr.open('get', 'timeout.php', true);\nxhr.timeout = 1000;\nxhr.ontimeout = function() {\n\talert('request timeout');\n};\nxhr.send(null);\n```\n\n### overrideMimeType()方法\n\n用于重写XHR响应的MIME类型。\n\n## 跨域源资源共享\n\n默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。同源指的是：**域名、协议、端口**完全相同。\n\nCORS（Cross-Origin Resource Sharing，跨域源资源共享）定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。其背后思想就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应是否成功。\n\n### IE中的CORS\n\nIE8中映入了XDR（XDomainRequest）类型。这个对象与XHR相似，单能实现安全可靠的跨域通信。\n\nXDR对象的使用方法和XHR对象非常相似。也是创建一个实例，调用open()方法，再调用send()方法。但XDR对象的open()方法只接收两个参数：请求的类型和URL。所有的XDR请求都是异步执行的，请求返回后，会触发load事件，响应的数据也会保存在responseText属性中。\n\n### 其他浏览器的CORS\n\n其他浏览器无需编写额外代码即可触发这个行为，只要使用标准的XHR对象并在open()方法中传入绝对URL即可。\n\n### 跨浏览器的CORS\n\n不同浏览器对CORS的支持程度并不都一样。所有浏览器都支持简单的请求。检测XHR是否支持CORS的最简单方式，就是检查是否存在withCredentials属性，再结合检测XDomainRequest对象是否存在，就可以兼顾所有浏览器了。\n\n## 其他跨域技术\n\n### 图像Ping\n\n### JSONP\n\nJSONP市JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法。\n\nJSONP是被包含在函数调用中的JSON，如\n\n```js\ncallback({ 'name': 'zrtty'} );\n```\n\nJSONP由两部分组成：回调函数和数据。其本质是利用了`<script src=''></script>`标签具有可跨域的特性，由服务端返回一个预先定义好的JS函数的调用，并且将服务器数据以该函数参数的形式传递过来。此方法需要前后端配合完成。\n\nhtml标签的src属性是支持跨域的，jsonp就是利用这个特性实现的跨域，但用到是script标签。\n\njsonp只能通过GET方式进行请求。\n\n```js\n  <script>\n    function handleResponse(response) {\n      console.log(response.ip);\n    }\n  </script>\n  <script src=\"http://freegeoip.net/json/?callback=handleResponse\"></script>\n```\n\n这个URL是在请求一个JSONP地理定位服务。这里指定的回调函数的名字叫handleResponse()。\n\n**JQuery的JSONP**\n\n```js\n$('#btn').click(function () {\n  $.ajax({\n    url: 'http://freegeoip.net/json/?callback=handleResponse',\n    dataType: 'jsonp',\n    type: 'get',\n    // jsonp: 'callback_name' // 传递给服务器的回调函数的毛宁子（默认callback)\n    // jsonCallBack: 'responseHandler' // 自定义的函数名。默认为jQuery自动生成的随机函数名\n    success: function (response) {\n      console.log(response.ip);\n    },\n    error: function (err) {\n      console.log(err);\n    }\n  });\n});\n```\n\n","source":"_posts/31天JavaScript学习-第17天.md","raw":"---\ntitle: 31天JavaScript学习-第17天.md\nreprint: false\ndate: 2022-03-13 20:39:56\nupdated: 2022-03-13 20:39:56\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# Ajax（二）\n\n<!--more-->\n\n## JSON\n\nJSON(JavaScrtipt Object Notation)：是ES的子集。\n\n**JS中json字符串和js对象的互相转化**\n\n```js\nlet jsObj = JSON.parse(ajax.responseText); // 将JSON字符串转化未js对象\n\nlet Obj = {\n\tname: 'zrtty',\n\tage: 20\n};\nlet jsonStr = JSON.stringify(Obj);\n```\n\n## XMLHttpRequest2级\n\n规范化的XMLHttpRequest。\n\n### FormData\n\n现代Web应用中表单数据的序列化是一项频繁使用的功能。为此定义了FormData类型。\n\n```js\nlet data = new FormData();\ndata.append('name', 'zrtty'); // 分别接收两个参数：键和值\n```\n\n创建的FormData的实例，可以将它直接传给XHR的send()方法，不必明确地在XHR对象上设置请求头部。XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。\n\n### 超时设定\n\nXHR对象timeout属性，表示请求在等待响应多少毫秒后停止。\n\n```js\nxhr.open('get', 'timeout.php', true);\nxhr.timeout = 1000;\nxhr.ontimeout = function() {\n\talert('request timeout');\n};\nxhr.send(null);\n```\n\n### overrideMimeType()方法\n\n用于重写XHR响应的MIME类型。\n\n## 跨域源资源共享\n\n默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。同源指的是：**域名、协议、端口**完全相同。\n\nCORS（Cross-Origin Resource Sharing，跨域源资源共享）定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。其背后思想就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应是否成功。\n\n### IE中的CORS\n\nIE8中映入了XDR（XDomainRequest）类型。这个对象与XHR相似，单能实现安全可靠的跨域通信。\n\nXDR对象的使用方法和XHR对象非常相似。也是创建一个实例，调用open()方法，再调用send()方法。但XDR对象的open()方法只接收两个参数：请求的类型和URL。所有的XDR请求都是异步执行的，请求返回后，会触发load事件，响应的数据也会保存在responseText属性中。\n\n### 其他浏览器的CORS\n\n其他浏览器无需编写额外代码即可触发这个行为，只要使用标准的XHR对象并在open()方法中传入绝对URL即可。\n\n### 跨浏览器的CORS\n\n不同浏览器对CORS的支持程度并不都一样。所有浏览器都支持简单的请求。检测XHR是否支持CORS的最简单方式，就是检查是否存在withCredentials属性，再结合检测XDomainRequest对象是否存在，就可以兼顾所有浏览器了。\n\n## 其他跨域技术\n\n### 图像Ping\n\n### JSONP\n\nJSONP市JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法。\n\nJSONP是被包含在函数调用中的JSON，如\n\n```js\ncallback({ 'name': 'zrtty'} );\n```\n\nJSONP由两部分组成：回调函数和数据。其本质是利用了`<script src=''></script>`标签具有可跨域的特性，由服务端返回一个预先定义好的JS函数的调用，并且将服务器数据以该函数参数的形式传递过来。此方法需要前后端配合完成。\n\nhtml标签的src属性是支持跨域的，jsonp就是利用这个特性实现的跨域，但用到是script标签。\n\njsonp只能通过GET方式进行请求。\n\n```js\n  <script>\n    function handleResponse(response) {\n      console.log(response.ip);\n    }\n  </script>\n  <script src=\"http://freegeoip.net/json/?callback=handleResponse\"></script>\n```\n\n这个URL是在请求一个JSONP地理定位服务。这里指定的回调函数的名字叫handleResponse()。\n\n**JQuery的JSONP**\n\n```js\n$('#btn').click(function () {\n  $.ajax({\n    url: 'http://freegeoip.net/json/?callback=handleResponse',\n    dataType: 'jsonp',\n    type: 'get',\n    // jsonp: 'callback_name' // 传递给服务器的回调函数的毛宁子（默认callback)\n    // jsonCallBack: 'responseHandler' // 自定义的函数名。默认为jQuery自动生成的随机函数名\n    success: function (response) {\n      console.log(response.ip);\n    },\n    error: function (err) {\n      console.log(err);\n    }\n  });\n});\n```\n\n","slug":"31天JavaScript学习-第17天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a2000h7owzbroo4u1z","content":"<h1 id=\"Ajax（二）\"><a href=\"#Ajax（二）\" class=\"headerlink\" title=\"Ajax（二）\"></a>Ajax（二）</h1><span id=\"more\"></span>\n\n<h2 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h2><p>JSON(JavaScrtipt Object Notation)：是ES的子集。</p>\n<p><strong>JS中json字符串和js对象的互相转化</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jsObj = <span class=\"built_in\">JSON</span>.parse(ajax.responseText); <span class=\"comment\">// 将JSON字符串转化未js对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> Obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>: <span class=\"number\">20</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> jsonStr = <span class=\"built_in\">JSON</span>.stringify(Obj);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"XMLHttpRequest2级\"><a href=\"#XMLHttpRequest2级\" class=\"headerlink\" title=\"XMLHttpRequest2级\"></a>XMLHttpRequest2级</h2><p>规范化的XMLHttpRequest。</p>\n<h3 id=\"FormData\"><a href=\"#FormData\" class=\"headerlink\" title=\"FormData\"></a>FormData</h3><p>现代Web应用中表单数据的序列化是一项频繁使用的功能。为此定义了FormData类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;zrtty&#x27;</span>); <span class=\"comment\">// 分别接收两个参数：键和值</span></span><br></pre></td></tr></table></figure>\n\n<p>创建的FormData的实例，可以将它直接传给XHR的send()方法，不必明确地在XHR对象上设置请求头部。XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。</p>\n<h3 id=\"超时设定\"><a href=\"#超时设定\" class=\"headerlink\" title=\"超时设定\"></a>超时设定</h3><p>XHR对象timeout属性，表示请求在等待响应多少毫秒后停止。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.open(<span class=\"string\">&#x27;get&#x27;</span>, <span class=\"string\">&#x27;timeout.php&#x27;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.timeout = <span class=\"number\">1000</span>;</span><br><span class=\"line\">xhr.ontimeout = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">&#x27;request timeout&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">xhr.send(<span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"overrideMimeType-方法\"><a href=\"#overrideMimeType-方法\" class=\"headerlink\" title=\"overrideMimeType()方法\"></a>overrideMimeType()方法</h3><p>用于重写XHR响应的MIME类型。</p>\n<h2 id=\"跨域源资源共享\"><a href=\"#跨域源资源共享\" class=\"headerlink\" title=\"跨域源资源共享\"></a>跨域源资源共享</h2><p>默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。同源指的是：<strong>域名、协议、端口</strong>完全相同。</p>\n<p>CORS（Cross-Origin Resource Sharing，跨域源资源共享）定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。其背后思想就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应是否成功。</p>\n<h3 id=\"IE中的CORS\"><a href=\"#IE中的CORS\" class=\"headerlink\" title=\"IE中的CORS\"></a>IE中的CORS</h3><p>IE8中映入了XDR（XDomainRequest）类型。这个对象与XHR相似，单能实现安全可靠的跨域通信。</p>\n<p>XDR对象的使用方法和XHR对象非常相似。也是创建一个实例，调用open()方法，再调用send()方法。但XDR对象的open()方法只接收两个参数：请求的类型和URL。所有的XDR请求都是异步执行的，请求返回后，会触发load事件，响应的数据也会保存在responseText属性中。</p>\n<h3 id=\"其他浏览器的CORS\"><a href=\"#其他浏览器的CORS\" class=\"headerlink\" title=\"其他浏览器的CORS\"></a>其他浏览器的CORS</h3><p>其他浏览器无需编写额外代码即可触发这个行为，只要使用标准的XHR对象并在open()方法中传入绝对URL即可。</p>\n<h3 id=\"跨浏览器的CORS\"><a href=\"#跨浏览器的CORS\" class=\"headerlink\" title=\"跨浏览器的CORS\"></a>跨浏览器的CORS</h3><p>不同浏览器对CORS的支持程度并不都一样。所有浏览器都支持简单的请求。检测XHR是否支持CORS的最简单方式，就是检查是否存在withCredentials属性，再结合检测XDomainRequest对象是否存在，就可以兼顾所有浏览器了。</p>\n<h2 id=\"其他跨域技术\"><a href=\"#其他跨域技术\" class=\"headerlink\" title=\"其他跨域技术\"></a>其他跨域技术</h2><h3 id=\"图像Ping\"><a href=\"#图像Ping\" class=\"headerlink\" title=\"图像Ping\"></a>图像Ping</h3><h3 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h3><p>JSONP市JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法。</p>\n<p>JSONP是被包含在函数调用中的JSON，如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback(&#123; <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>&#125; );</span><br></pre></td></tr></table></figure>\n\n<p>JSONP由两部分组成：回调函数和数据。其本质是利用了<code>&lt;script src=&#39;&#39;&gt;&lt;/script&gt;</code>标签具有可跨域的特性，由服务端返回一个预先定义好的JS函数的调用，并且将服务器数据以该函数参数的形式传递过来。此方法需要前后端配合完成。</p>\n<p>html标签的src属性是支持跨域的，jsonp就是利用这个特性实现的跨域，但用到是script标签。</p>\n<p>jsonp只能通过GET方式进行请求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleResponse</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response.ip);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://freegeoip.net/json/?callback=handleResponse&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个URL是在请求一个JSONP地理定位服务。这里指定的回调函数的名字叫handleResponse()。</p>\n<p><strong>JQuery的JSONP</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;#btn&#x27;</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  $.ajax(&#123;</span><br><span class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">&#x27;http://freegeoip.net/json/?callback=handleResponse&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">dataType</span>: <span class=\"string\">&#x27;jsonp&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;get&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// jsonp: &#x27;callback_name&#x27; // 传递给服务器的回调函数的毛宁子（默认callback)</span></span><br><span class=\"line\">    <span class=\"comment\">// jsonCallBack: &#x27;responseHandler&#x27; // 自定义的函数名。默认为jQuery自动生成的随机函数名</span></span><br><span class=\"line\">    <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(response.ip);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"Ajax（二）\"><a href=\"#Ajax（二）\" class=\"headerlink\" title=\"Ajax（二）\"></a>Ajax（二）</h1>","more":"<h2 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h2><p>JSON(JavaScrtipt Object Notation)：是ES的子集。</p>\n<p><strong>JS中json字符串和js对象的互相转化</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jsObj = <span class=\"built_in\">JSON</span>.parse(ajax.responseText); <span class=\"comment\">// 将JSON字符串转化未js对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> Obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>: <span class=\"number\">20</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> jsonStr = <span class=\"built_in\">JSON</span>.stringify(Obj);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"XMLHttpRequest2级\"><a href=\"#XMLHttpRequest2级\" class=\"headerlink\" title=\"XMLHttpRequest2级\"></a>XMLHttpRequest2级</h2><p>规范化的XMLHttpRequest。</p>\n<h3 id=\"FormData\"><a href=\"#FormData\" class=\"headerlink\" title=\"FormData\"></a>FormData</h3><p>现代Web应用中表单数据的序列化是一项频繁使用的功能。为此定义了FormData类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">data.append(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;zrtty&#x27;</span>); <span class=\"comment\">// 分别接收两个参数：键和值</span></span><br></pre></td></tr></table></figure>\n\n<p>创建的FormData的实例，可以将它直接传给XHR的send()方法，不必明确地在XHR对象上设置请求头部。XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息。</p>\n<h3 id=\"超时设定\"><a href=\"#超时设定\" class=\"headerlink\" title=\"超时设定\"></a>超时设定</h3><p>XHR对象timeout属性，表示请求在等待响应多少毫秒后停止。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.open(<span class=\"string\">&#x27;get&#x27;</span>, <span class=\"string\">&#x27;timeout.php&#x27;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.timeout = <span class=\"number\">1000</span>;</span><br><span class=\"line\">xhr.ontimeout = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">&#x27;request timeout&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">xhr.send(<span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"overrideMimeType-方法\"><a href=\"#overrideMimeType-方法\" class=\"headerlink\" title=\"overrideMimeType()方法\"></a>overrideMimeType()方法</h3><p>用于重写XHR响应的MIME类型。</p>\n<h2 id=\"跨域源资源共享\"><a href=\"#跨域源资源共享\" class=\"headerlink\" title=\"跨域源资源共享\"></a>跨域源资源共享</h2><p>默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。同源指的是：<strong>域名、协议、端口</strong>完全相同。</p>\n<p>CORS（Cross-Origin Resource Sharing，跨域源资源共享）定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。其背后思想就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定请求或响应是否成功。</p>\n<h3 id=\"IE中的CORS\"><a href=\"#IE中的CORS\" class=\"headerlink\" title=\"IE中的CORS\"></a>IE中的CORS</h3><p>IE8中映入了XDR（XDomainRequest）类型。这个对象与XHR相似，单能实现安全可靠的跨域通信。</p>\n<p>XDR对象的使用方法和XHR对象非常相似。也是创建一个实例，调用open()方法，再调用send()方法。但XDR对象的open()方法只接收两个参数：请求的类型和URL。所有的XDR请求都是异步执行的，请求返回后，会触发load事件，响应的数据也会保存在responseText属性中。</p>\n<h3 id=\"其他浏览器的CORS\"><a href=\"#其他浏览器的CORS\" class=\"headerlink\" title=\"其他浏览器的CORS\"></a>其他浏览器的CORS</h3><p>其他浏览器无需编写额外代码即可触发这个行为，只要使用标准的XHR对象并在open()方法中传入绝对URL即可。</p>\n<h3 id=\"跨浏览器的CORS\"><a href=\"#跨浏览器的CORS\" class=\"headerlink\" title=\"跨浏览器的CORS\"></a>跨浏览器的CORS</h3><p>不同浏览器对CORS的支持程度并不都一样。所有浏览器都支持简单的请求。检测XHR是否支持CORS的最简单方式，就是检查是否存在withCredentials属性，再结合检测XDomainRequest对象是否存在，就可以兼顾所有浏览器了。</p>\n<h2 id=\"其他跨域技术\"><a href=\"#其他跨域技术\" class=\"headerlink\" title=\"其他跨域技术\"></a>其他跨域技术</h2><h3 id=\"图像Ping\"><a href=\"#图像Ping\" class=\"headerlink\" title=\"图像Ping\"></a>图像Ping</h3><h3 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h3><p>JSONP市JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法。</p>\n<p>JSONP是被包含在函数调用中的JSON，如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback(&#123; <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;zrtty&#x27;</span>&#125; );</span><br></pre></td></tr></table></figure>\n\n<p>JSONP由两部分组成：回调函数和数据。其本质是利用了<code>&lt;script src=&#39;&#39;&gt;&lt;/script&gt;</code>标签具有可跨域的特性，由服务端返回一个预先定义好的JS函数的调用，并且将服务器数据以该函数参数的形式传递过来。此方法需要前后端配合完成。</p>\n<p>html标签的src属性是支持跨域的，jsonp就是利用这个特性实现的跨域，但用到是script标签。</p>\n<p>jsonp只能通过GET方式进行请求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleResponse</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response.ip);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://freegeoip.net/json/?callback=handleResponse&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个URL是在请求一个JSONP地理定位服务。这里指定的回调函数的名字叫handleResponse()。</p>\n<p><strong>JQuery的JSONP</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;#btn&#x27;</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  $.ajax(&#123;</span><br><span class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">&#x27;http://freegeoip.net/json/?callback=handleResponse&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">dataType</span>: <span class=\"string\">&#x27;jsonp&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;get&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// jsonp: &#x27;callback_name&#x27; // 传递给服务器的回调函数的毛宁子（默认callback)</span></span><br><span class=\"line\">    <span class=\"comment\">// jsonCallBack: &#x27;responseHandler&#x27; // 自定义的函数名。默认为jQuery自动生成的随机函数名</span></span><br><span class=\"line\">    <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(response.ip);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"31天JavaScript学习-第19天","reprint":false,"date":"2022-03-19T10:55:50.000Z","updated":"2022-03-19T10:55:50.000Z","conver":null,"_content":"\n# Promise（二）\n\n<!--more-->\n\n## Promise的实例方法\n\n实例方法指需要建立实例对象，再通过实例对象调用的方法叫做实例方法。Promise的实例方法有：\n\n- **then()：**获取异步任务的正常结果\n- **catch()：**获取异步任务的异常结果\n- **finally()：**异步任务无论成功与否，都会执行\n\n## Promise的静态方法\n\n静态方法指直接可以通过类名调用的方法。Promise提供的静态方法有：\n\n- **Promise.resolve()**\n- **Promise.reject()**\n- **Promise.all()**\n- **Promise.race()**\n- **Promise.allSettled()**\n- **Promise.any()**\n\n### Promise.resolve()和Promise.reject()\n\n在某些场景下，我们并没有异步操作，但仍想调用promise.then()，可以通过Promise.resolve()将其包装成成功的状态。\n\n```js\nfunction foo (flag) {\n  if (flag) {\n    return Promise.resolve('success'); // 直接返回字符串\n  } else {\n    return Promise.reject('fail'); //直接返回字符串\n  }\n}\n\nfoo(true).then((res) => {\n  console.log(res);\n});\nfoo(false).then((err) => {\n  console.log(err);\n});\n```\n\n### Promise.all()\n\n并发处理多个异步任务，所有任务都执行成功，才算成功，这时才会调用then()；如果有一个任务失败，就会调用catch()，整体任务视为失败。\n\nPromise.all()参数传入的时多个Promise实例对象的数组。\n\n**案例：多张图片上传**\n\n如现在有一个上传九张图的需求，每次请求接口时只能上传一张图片。\n\n```js\nconst imgArr = ['1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg', '6.jpg', '7.jpg', '8.jpg', '9.jpg'];\nconst promiseArr = [];\n\nimgArr.forEach((item) => {\n  const p = new Promise((resolve, reject) => {\n    // 上传图片伪代码\n    // imgUrl = Upload item;\n    if (imgUrl) {\n      // 单张图片上传成功\n      resolve(imgUrl);\n    } else {\n      reject(item + '上传失败');\n    }\n  });\n  promiseArr.push(p);\n});\n\nPromise.all(promiseArr)\n  .then((res) => {\n    console.log('全部上传成功' + res);\n  })\n  .catch((err) => {\n    console.log('上传失败');\n  });\n```\n\n如果某张图上传失败，则表现为：\n\n- 前端九张图都会reject，整体catch\n- 后端除了上传失败的图片，其余的都会正常请求接口并写入数据库\n\n### Promise.race()\n\n并发处理多个异步任务，返回的是第一个执行完成的promise，且状态和第一个完成的任务状态保持一致。\n\n多个同时执行的异步任务中，哪个异步任务最先执行完成（无论resolv还是reject），整体的状态就和这个任务的状态保持一致。\n\n**应用场景：**在众多Promise实例中，最终结果只取一个Promise，谁返回得最快就用谁的Promise\n\n**举例：timeout手动实现**\n\n一个Promise用于请求接口，另一个Promise用于执行setTimeout()。把两个Promise用Promise.race()方法组装\n\n```js\nfunction query(url, delay = 4000) {\n  let promsiseArr = [\n    myAjax(url),\n    new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject('timeout!')\n      }, delay);\n    })\n  ];\n  return Promise.race(promsiseArr);\n}\n\nquery('https://localhost:8888/someurl', 3000)\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n```\n\n### Promise.allSettled()\n\n该方法返回一个在所有给定的promise都fulfilled或reject后的promise，并带有一个对象数组，每个对象表示对应的promise结果。\n\n当有多个彼此不依赖的异步任务成功完成时，或者想知道每个promise的结果时，通常使用该方法。\n\n### Promise.any()\n\n该方法处理多个promise任务，只要其中任何一个promise成功，就返回那个成功的promise。若没有一个promise成功，就返回一个失败的promise和AggregError类型的实例。\n","source":"_posts/31天JavaScript学习-第19天.md","raw":"---\ntitle: 31天JavaScript学习-第19天\nreprint: false\ndate: 2022-03-19 18:55:50\nupdated: 2022-03-19 18:55:50\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# Promise（二）\n\n<!--more-->\n\n## Promise的实例方法\n\n实例方法指需要建立实例对象，再通过实例对象调用的方法叫做实例方法。Promise的实例方法有：\n\n- **then()：**获取异步任务的正常结果\n- **catch()：**获取异步任务的异常结果\n- **finally()：**异步任务无论成功与否，都会执行\n\n## Promise的静态方法\n\n静态方法指直接可以通过类名调用的方法。Promise提供的静态方法有：\n\n- **Promise.resolve()**\n- **Promise.reject()**\n- **Promise.all()**\n- **Promise.race()**\n- **Promise.allSettled()**\n- **Promise.any()**\n\n### Promise.resolve()和Promise.reject()\n\n在某些场景下，我们并没有异步操作，但仍想调用promise.then()，可以通过Promise.resolve()将其包装成成功的状态。\n\n```js\nfunction foo (flag) {\n  if (flag) {\n    return Promise.resolve('success'); // 直接返回字符串\n  } else {\n    return Promise.reject('fail'); //直接返回字符串\n  }\n}\n\nfoo(true).then((res) => {\n  console.log(res);\n});\nfoo(false).then((err) => {\n  console.log(err);\n});\n```\n\n### Promise.all()\n\n并发处理多个异步任务，所有任务都执行成功，才算成功，这时才会调用then()；如果有一个任务失败，就会调用catch()，整体任务视为失败。\n\nPromise.all()参数传入的时多个Promise实例对象的数组。\n\n**案例：多张图片上传**\n\n如现在有一个上传九张图的需求，每次请求接口时只能上传一张图片。\n\n```js\nconst imgArr = ['1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg', '6.jpg', '7.jpg', '8.jpg', '9.jpg'];\nconst promiseArr = [];\n\nimgArr.forEach((item) => {\n  const p = new Promise((resolve, reject) => {\n    // 上传图片伪代码\n    // imgUrl = Upload item;\n    if (imgUrl) {\n      // 单张图片上传成功\n      resolve(imgUrl);\n    } else {\n      reject(item + '上传失败');\n    }\n  });\n  promiseArr.push(p);\n});\n\nPromise.all(promiseArr)\n  .then((res) => {\n    console.log('全部上传成功' + res);\n  })\n  .catch((err) => {\n    console.log('上传失败');\n  });\n```\n\n如果某张图上传失败，则表现为：\n\n- 前端九张图都会reject，整体catch\n- 后端除了上传失败的图片，其余的都会正常请求接口并写入数据库\n\n### Promise.race()\n\n并发处理多个异步任务，返回的是第一个执行完成的promise，且状态和第一个完成的任务状态保持一致。\n\n多个同时执行的异步任务中，哪个异步任务最先执行完成（无论resolv还是reject），整体的状态就和这个任务的状态保持一致。\n\n**应用场景：**在众多Promise实例中，最终结果只取一个Promise，谁返回得最快就用谁的Promise\n\n**举例：timeout手动实现**\n\n一个Promise用于请求接口，另一个Promise用于执行setTimeout()。把两个Promise用Promise.race()方法组装\n\n```js\nfunction query(url, delay = 4000) {\n  let promsiseArr = [\n    myAjax(url),\n    new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject('timeout!')\n      }, delay);\n    })\n  ];\n  return Promise.race(promsiseArr);\n}\n\nquery('https://localhost:8888/someurl', 3000)\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n```\n\n### Promise.allSettled()\n\n该方法返回一个在所有给定的promise都fulfilled或reject后的promise，并带有一个对象数组，每个对象表示对应的promise结果。\n\n当有多个彼此不依赖的异步任务成功完成时，或者想知道每个promise的结果时，通常使用该方法。\n\n### Promise.any()\n\n该方法处理多个promise任务，只要其中任何一个promise成功，就返回那个成功的promise。若没有一个promise成功，就返回一个失败的promise和AggregError类型的实例。\n","slug":"31天JavaScript学习-第19天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a3000k7owz5bxdcqnm","content":"<h1 id=\"Promise（二）\"><a href=\"#Promise（二）\" class=\"headerlink\" title=\"Promise（二）\"></a>Promise（二）</h1><span id=\"more\"></span>\n\n<h2 id=\"Promise的实例方法\"><a href=\"#Promise的实例方法\" class=\"headerlink\" title=\"Promise的实例方法\"></a>Promise的实例方法</h2><p>实例方法指需要建立实例对象，再通过实例对象调用的方法叫做实例方法。Promise的实例方法有：</p>\n<ul>\n<li><strong>then()：</strong>获取异步任务的正常结果</li>\n<li><strong>catch()：</strong>获取异步任务的异常结果</li>\n<li><strong>finally()：</strong>异步任务无论成功与否，都会执行</li>\n</ul>\n<h2 id=\"Promise的静态方法\"><a href=\"#Promise的静态方法\" class=\"headerlink\" title=\"Promise的静态方法\"></a>Promise的静态方法</h2><p>静态方法指直接可以通过类名调用的方法。Promise提供的静态方法有：</p>\n<ul>\n<li><strong>Promise.resolve()</strong></li>\n<li><strong>Promise.reject()</strong></li>\n<li><strong>Promise.all()</strong></li>\n<li><strong>Promise.race()</strong></li>\n<li><strong>Promise.allSettled()</strong></li>\n<li><strong>Promise.any()</strong></li>\n</ul>\n<h3 id=\"Promise-resolve-和Promise-reject\"><a href=\"#Promise-resolve-和Promise-reject\" class=\"headerlink\" title=\"Promise.resolve()和Promise.reject()\"></a>Promise.resolve()和Promise.reject()</h3><p>在某些场景下，我们并没有异步操作，但仍想调用promise.then()，可以通过Promise.resolve()将其包装成成功的状态。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\">flag</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">&#x27;success&#x27;</span>); <span class=\"comment\">// 直接返回字符串</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;fail&#x27;</span>); <span class=\"comment\">//直接返回字符串</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"literal\">true</span>).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">foo(<span class=\"literal\">false</span>).then(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h3><p>并发处理多个异步任务，所有任务都执行成功，才算成功，这时才会调用then()；如果有一个任务失败，就会调用catch()，整体任务视为失败。</p>\n<p>Promise.all()参数传入的时多个Promise实例对象的数组。</p>\n<p><strong>案例：多张图片上传</strong></p>\n<p>如现在有一个上传九张图的需求，每次请求接口时只能上传一张图片。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> imgArr = [<span class=\"string\">&#x27;1.jpg&#x27;</span>, <span class=\"string\">&#x27;2.jpg&#x27;</span>, <span class=\"string\">&#x27;3.jpg&#x27;</span>, <span class=\"string\">&#x27;4.jpg&#x27;</span>, <span class=\"string\">&#x27;5.jpg&#x27;</span>, <span class=\"string\">&#x27;6.jpg&#x27;</span>, <span class=\"string\">&#x27;7.jpg&#x27;</span>, <span class=\"string\">&#x27;8.jpg&#x27;</span>, <span class=\"string\">&#x27;9.jpg&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseArr = [];</span><br><span class=\"line\"></span><br><span class=\"line\">imgArr.forEach(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 上传图片伪代码</span></span><br><span class=\"line\">    <span class=\"comment\">// imgUrl = Upload item;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (imgUrl) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 单张图片上传成功</span></span><br><span class=\"line\">      resolve(imgUrl);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      reject(item + <span class=\"string\">&#x27;上传失败&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  promiseArr.push(p);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promiseArr)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;全部上传成功&#x27;</span> + res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;上传失败&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如果某张图上传失败，则表现为：</p>\n<ul>\n<li>前端九张图都会reject，整体catch</li>\n<li>后端除了上传失败的图片，其余的都会正常请求接口并写入数据库</li>\n</ul>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h3><p>并发处理多个异步任务，返回的是第一个执行完成的promise，且状态和第一个完成的任务状态保持一致。</p>\n<p>多个同时执行的异步任务中，哪个异步任务最先执行完成（无论resolv还是reject），整体的状态就和这个任务的状态保持一致。</p>\n<p><strong>应用场景：</strong>在众多Promise实例中，最终结果只取一个Promise，谁返回得最快就用谁的Promise</p>\n<p><strong>举例：timeout手动实现</strong></p>\n<p>一个Promise用于请求接口，另一个Promise用于执行setTimeout()。把两个Promise用Promise.race()方法组装</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">query</span>(<span class=\"params\">url, delay = <span class=\"number\">4000</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promsiseArr = [</span><br><span class=\"line\">    myAjax(url),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"string\">&#x27;timeout!&#x27;</span>)</span><br><span class=\"line\">      &#125;, delay);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.race(promsiseArr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">query(<span class=\"string\">&#x27;https://localhost:8888/someurl&#x27;</span>, <span class=\"number\">3000</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled()\"></a>Promise.allSettled()</h3><p>该方法返回一个在所有给定的promise都fulfilled或reject后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p>\n<p>当有多个彼此不依赖的异步任务成功完成时，或者想知道每个promise的结果时，通常使用该方法。</p>\n<h3 id=\"Promise-any\"><a href=\"#Promise-any\" class=\"headerlink\" title=\"Promise.any()\"></a>Promise.any()</h3><p>该方法处理多个promise任务，只要其中任何一个promise成功，就返回那个成功的promise。若没有一个promise成功，就返回一个失败的promise和AggregError类型的实例。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Promise（二）\"><a href=\"#Promise（二）\" class=\"headerlink\" title=\"Promise（二）\"></a>Promise（二）</h1>","more":"<h2 id=\"Promise的实例方法\"><a href=\"#Promise的实例方法\" class=\"headerlink\" title=\"Promise的实例方法\"></a>Promise的实例方法</h2><p>实例方法指需要建立实例对象，再通过实例对象调用的方法叫做实例方法。Promise的实例方法有：</p>\n<ul>\n<li><strong>then()：</strong>获取异步任务的正常结果</li>\n<li><strong>catch()：</strong>获取异步任务的异常结果</li>\n<li><strong>finally()：</strong>异步任务无论成功与否，都会执行</li>\n</ul>\n<h2 id=\"Promise的静态方法\"><a href=\"#Promise的静态方法\" class=\"headerlink\" title=\"Promise的静态方法\"></a>Promise的静态方法</h2><p>静态方法指直接可以通过类名调用的方法。Promise提供的静态方法有：</p>\n<ul>\n<li><strong>Promise.resolve()</strong></li>\n<li><strong>Promise.reject()</strong></li>\n<li><strong>Promise.all()</strong></li>\n<li><strong>Promise.race()</strong></li>\n<li><strong>Promise.allSettled()</strong></li>\n<li><strong>Promise.any()</strong></li>\n</ul>\n<h3 id=\"Promise-resolve-和Promise-reject\"><a href=\"#Promise-resolve-和Promise-reject\" class=\"headerlink\" title=\"Promise.resolve()和Promise.reject()\"></a>Promise.resolve()和Promise.reject()</h3><p>在某些场景下，我们并没有异步操作，但仍想调用promise.then()，可以通过Promise.resolve()将其包装成成功的状态。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\">flag</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">&#x27;success&#x27;</span>); <span class=\"comment\">// 直接返回字符串</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;fail&#x27;</span>); <span class=\"comment\">//直接返回字符串</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"literal\">true</span>).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">foo(<span class=\"literal\">false</span>).then(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h3><p>并发处理多个异步任务，所有任务都执行成功，才算成功，这时才会调用then()；如果有一个任务失败，就会调用catch()，整体任务视为失败。</p>\n<p>Promise.all()参数传入的时多个Promise实例对象的数组。</p>\n<p><strong>案例：多张图片上传</strong></p>\n<p>如现在有一个上传九张图的需求，每次请求接口时只能上传一张图片。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> imgArr = [<span class=\"string\">&#x27;1.jpg&#x27;</span>, <span class=\"string\">&#x27;2.jpg&#x27;</span>, <span class=\"string\">&#x27;3.jpg&#x27;</span>, <span class=\"string\">&#x27;4.jpg&#x27;</span>, <span class=\"string\">&#x27;5.jpg&#x27;</span>, <span class=\"string\">&#x27;6.jpg&#x27;</span>, <span class=\"string\">&#x27;7.jpg&#x27;</span>, <span class=\"string\">&#x27;8.jpg&#x27;</span>, <span class=\"string\">&#x27;9.jpg&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseArr = [];</span><br><span class=\"line\"></span><br><span class=\"line\">imgArr.forEach(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 上传图片伪代码</span></span><br><span class=\"line\">    <span class=\"comment\">// imgUrl = Upload item;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (imgUrl) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 单张图片上传成功</span></span><br><span class=\"line\">      resolve(imgUrl);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      reject(item + <span class=\"string\">&#x27;上传失败&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  promiseArr.push(p);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promiseArr)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;全部上传成功&#x27;</span> + res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;上传失败&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如果某张图上传失败，则表现为：</p>\n<ul>\n<li>前端九张图都会reject，整体catch</li>\n<li>后端除了上传失败的图片，其余的都会正常请求接口并写入数据库</li>\n</ul>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h3><p>并发处理多个异步任务，返回的是第一个执行完成的promise，且状态和第一个完成的任务状态保持一致。</p>\n<p>多个同时执行的异步任务中，哪个异步任务最先执行完成（无论resolv还是reject），整体的状态就和这个任务的状态保持一致。</p>\n<p><strong>应用场景：</strong>在众多Promise实例中，最终结果只取一个Promise，谁返回得最快就用谁的Promise</p>\n<p><strong>举例：timeout手动实现</strong></p>\n<p>一个Promise用于请求接口，另一个Promise用于执行setTimeout()。把两个Promise用Promise.race()方法组装</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">query</span>(<span class=\"params\">url, delay = <span class=\"number\">4000</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promsiseArr = [</span><br><span class=\"line\">    myAjax(url),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"string\">&#x27;timeout!&#x27;</span>)</span><br><span class=\"line\">      &#125;, delay);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.race(promsiseArr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">query(<span class=\"string\">&#x27;https://localhost:8888/someurl&#x27;</span>, <span class=\"number\">3000</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled()\"></a>Promise.allSettled()</h3><p>该方法返回一个在所有给定的promise都fulfilled或reject后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p>\n<p>当有多个彼此不依赖的异步任务成功完成时，或者想知道每个promise的结果时，通常使用该方法。</p>\n<h3 id=\"Promise-any\"><a href=\"#Promise-any\" class=\"headerlink\" title=\"Promise.any()\"></a>Promise.any()</h3><p>该方法处理多个promise任务，只要其中任何一个promise成功，就返回那个成功的promise。若没有一个promise成功，就返回一个失败的promise和AggregError类型的实例。</p>"},{"title":"31天JavaScript学习-第18天","reprint":false,"date":"2022-03-16T12:00:22.000Z","updated":"2022-03-16T12:00:22.000Z","conver":null,"_content":"\n# Promise（一）\n\n<!--more-->\n\nJS是一门单线程语言，早期我们解决异步场景时，大部分情况都是通过回调函数来进行。\n\n## 回调函数\n\n把函数A传给另一个函数B调用，那么函数A就是回调函数。\n\n例如浏览器中发送Ajax请求，就是一个常见的异步场景，发送请求后，需要等待服务端响应之后我们才能拿到结果。如果希望在异步结束之后执行某个操作，就需要通过回调函数进行操作。\n\n```js\nmyAjax('a.php', (res1) => {\n  console.log(res1);\n  myAjax('b.php', (res2) => {\n    console.log(res2);\n    myAjax('c.php', (res3) => {\n      console.log(res3);\n    });\n  });\n});\n```\n\n回调的写法比较直观，但层层嵌套也会出现两个问题：\n\n- 嵌套过深会出现回调地狱的问题\n- 不同的函数，回调的参数，写法上不一致导致写法复杂\n\n因此ES6引入Promise以解决以上问题。\n\n## Promise\n\nPromise是一个对象，它可以获取异步操作的消息，可以用同步的表现形式来书写异步代码。\n\n使用Promise的基本步骤：\n\n1. 构建一个Promise实例，在其构造函数中传入一个参数，这个参数是一个函数，该函数用于处理异步任务。\n2. 函数中传入两个参数：resolve和reject，分别代表异步执行成功和失败后的回调函数\n3. 通过`promise.then()`和`promise.catch()`处理返回结果\n\n**Promise对象的三个状态**\n\n- 初始化（等待中）：pending\n- 成功：fulfilled\n- 失败：rejected\n\n```js\nlet promise = new Promise((resolve, reject) => {\n  // 此时new的操作是同步的，promise的状态被初始化为pending\n  setTimeout(function(){ \n    // 模拟异步操作，成功则调用resolve()，此时promise状态会修改为fulfilled\n    resolve('成功');\n  }, 200);\n});\n\npromise.then(\n  (response) => { console.log(response); }, // 如果promise的状态为fulfilled，则执行该行语句，函数的参数为resolve()中传递的参数\n  (err) => { console.log(err); } // 如果promise的状态为rejected，则执行该行语句，函数的参数为reject()中传递的参数\n);\n```\n\n**注：Promise的状态一旦改变，就不能再变了**\n\n**举例一**\n\n```js\nfunction delayfunc (callback) {\n  setTimeout(function () {\n    console.log('等待一秒执行callback');\n    callback();\n  }, 1000);\n}\n\nfunction myCallback() {\n  console.log('被延迟的函数');\n}\n\ndelayfunc(myCallback);\n```\n\n或\n\n```js\nfunction delayfunc (callback) {\n  setTimeout(callback, 1000);\n}\n\ndelayfunc(function() {\n  console.log('被延迟的函数');\n})\n```\n\n用Promise改写\n\n```js\nfunction myPromise() {\n  return new Promise((resolve) => {\n    setTimeout(resolve, 10000);\n  });\n}\n\nmyPromise().then(() => {\n  console.log('被延迟的函数');\n});\n```\n\n**举例二**\n\n```js\nfunction ajax(url, success, fail) {\n  let xmlhttp = new XMLHttpRequest();\n  xmlhttp.open('GET', url);\n  xmlhttp.send();\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {\n      success && success(xmlhttp.responseText);\n    } else {\n      fail && fail(new Error('err'));\n    }\n  };\n}\n\nfunction promiseA() {\n  return new Promise((resolve, reject) => {\n    ajax('test.php', (res) => {\n      if (res.retCode == 0) {\n        resolve('request success' + res);\n      } else {\n        reject({ retCode: -1, msg: 'error' });\n      }\n    });\n  });\n}\n\npromiseA()\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n\n// 或promise实例定义成变量\nconst promiseB = Promise((resolve, reject) => {\n  ajax('test.php', (res) => {\n    if (res.retCode == 0) {\n      resolve('request success' + res);\n    } else {\n      reject({ retCode: -1, msg: 'error' });\n    }\n  });\n});\n\npromiseB()\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n```\n\n**Promise处理失败的写法**\n\n1. 通过catch方法捕获状态变为reject的promise\n2. then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行\n\n## Promise的链式调用\n\n使用Promise优化回调地狱的写法。也就是将多层嵌套调用按照线性的方式进行书写。\n\n```js\nfunction ajax(url, success, fail) {\n  let xmlhttp = new XMLHttpRequest();\n  xmlhttp.open('GET', url);\n  xmlhttp.send();\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {\n      success && success(xmlhttp.responseText);\n    } else {\n      fail && fail(new Error('err'));\n    }\n  };\n}\n\nnew Promise((resolve, reject) => {\n  ajax('a.php', (res_a) => {\n    resolve(res_a); // 状态改为fulfilled,then()方法接收\n  });\n}).then((res_a) => {\n  return new Promise((resolve, reject) => {\n    ajax('b.php', (res_b) => {\n      resolve(res_b);\n    });\n  });\n}).then((res_b) => {\n  console.log(res_b);\n});\n```\n\n可以对promise的链式调用进行封装\n\n```js\n// 定义ajax请求\nfunction ajax(url, success, fail) {\n  let xmlhttp = new XMLHttpRequest();\n  xmlhttp.open('GET', url);\n  xmlhttp.send();\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {\n      success && success(xmlhttp.responseText);\n    } else {\n      fail && fail(new Error('err'));\n    }\n  };\n}\n\n// model层，接口封装\nfunction getPromise(url) {\n  return new Promise((resolve, reject) => {\n    ajax(url, (res) => {\n      //res是接口的返回结果\n      if (res.retCode == 0) {\n        resolve('success' + res);\n      } else {\n        reject({ retCode: -1, msg: 'error'});\n      }\n    });\n  });\n}\n\n// 业务层的接口调用\ngetPromise('a.php')\n  .then((res) => {\n    // a请求成功，res是从resolve获取的结果\n    return getPromise('b.php');\n  })\n  .then((res) => {\n    return getPromise('c.php');\n  })\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n```\n\n## reject状态的处理\n\n**不处理reject**\n\n```js\ngetPromise('a.php')\n  .then(\n    (res) => {\n      // a请求成功，res是从resolve获取的结果\n      console.log('a:' + res)\n      return getPromise('b.php');\n    }\n  .then((res) => {\n    console.log('b:' + res)\n    return getPromise('c.php');\n  })\n  .then((res) => {\n    console.log('c:' + res);\n  });\n```\n\na请求失败，在a的then()方法里只打印err。打印结果\n\n```\na:err\nundefined\nc:success\n```\n\n虽然a请求失败，但后续请求依然会执行\n\n**单独处理reject**\n\n```js\ngetPromise('a.php')\n  .then(\n    (res) => {\n      // a请求成功，res是从resolve获取的结果\n      console.log('a:' + res)\n      return getPromise('b.php');\n    },\n    (err) => {\n      console.log('a:' + err);\n      return getPromise('b.php'); // 即使a请求失败，也继续执行b请求\n    })\n  .then((res) => {\n    console.log('b:' + res)\n    return getPromise('c.php');\n  })\n  .then((res) => {\n    console.log('c:' + res);\n  });\n```\n\n**统一处理reject**\n\n```js\ngetPromise('a.php')\n  .then((res) => {\n    // a请求成功，res是从resolve获取的结果\n    return getPromise('b.php');\n  })\n  .then((res) => {\n    return getPromise('c.php');\n  })\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n```\n\n上面这种写法只要有一个请求失败了，就直接执行catch，剩下的请求就不会继续执行了。\n\n## return的返回值\n\nthen()方法里的返回值，有两种情况：\n\n1. 返回Promise实例对象。返回的该实例对象会调用下一个then\n2. 返回普通值。返回的值会直接传递给下一个then，通过then参数中函数的参数接收该值。返回普通值时，由于并没有返回promise实例对象，那它的then是谁来调用的呢？是产生的一个新的默认的promise实例以确保可以继续链式操作。\n\n","source":"_posts/31天JavaScript学习-第18天.md","raw":"---\ntitle: 31天JavaScript学习-第18天\nreprint: false\ndate: 2022-03-16 20:00:22\nupdated: 2022-03-16 20:00:22\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# Promise（一）\n\n<!--more-->\n\nJS是一门单线程语言，早期我们解决异步场景时，大部分情况都是通过回调函数来进行。\n\n## 回调函数\n\n把函数A传给另一个函数B调用，那么函数A就是回调函数。\n\n例如浏览器中发送Ajax请求，就是一个常见的异步场景，发送请求后，需要等待服务端响应之后我们才能拿到结果。如果希望在异步结束之后执行某个操作，就需要通过回调函数进行操作。\n\n```js\nmyAjax('a.php', (res1) => {\n  console.log(res1);\n  myAjax('b.php', (res2) => {\n    console.log(res2);\n    myAjax('c.php', (res3) => {\n      console.log(res3);\n    });\n  });\n});\n```\n\n回调的写法比较直观，但层层嵌套也会出现两个问题：\n\n- 嵌套过深会出现回调地狱的问题\n- 不同的函数，回调的参数，写法上不一致导致写法复杂\n\n因此ES6引入Promise以解决以上问题。\n\n## Promise\n\nPromise是一个对象，它可以获取异步操作的消息，可以用同步的表现形式来书写异步代码。\n\n使用Promise的基本步骤：\n\n1. 构建一个Promise实例，在其构造函数中传入一个参数，这个参数是一个函数，该函数用于处理异步任务。\n2. 函数中传入两个参数：resolve和reject，分别代表异步执行成功和失败后的回调函数\n3. 通过`promise.then()`和`promise.catch()`处理返回结果\n\n**Promise对象的三个状态**\n\n- 初始化（等待中）：pending\n- 成功：fulfilled\n- 失败：rejected\n\n```js\nlet promise = new Promise((resolve, reject) => {\n  // 此时new的操作是同步的，promise的状态被初始化为pending\n  setTimeout(function(){ \n    // 模拟异步操作，成功则调用resolve()，此时promise状态会修改为fulfilled\n    resolve('成功');\n  }, 200);\n});\n\npromise.then(\n  (response) => { console.log(response); }, // 如果promise的状态为fulfilled，则执行该行语句，函数的参数为resolve()中传递的参数\n  (err) => { console.log(err); } // 如果promise的状态为rejected，则执行该行语句，函数的参数为reject()中传递的参数\n);\n```\n\n**注：Promise的状态一旦改变，就不能再变了**\n\n**举例一**\n\n```js\nfunction delayfunc (callback) {\n  setTimeout(function () {\n    console.log('等待一秒执行callback');\n    callback();\n  }, 1000);\n}\n\nfunction myCallback() {\n  console.log('被延迟的函数');\n}\n\ndelayfunc(myCallback);\n```\n\n或\n\n```js\nfunction delayfunc (callback) {\n  setTimeout(callback, 1000);\n}\n\ndelayfunc(function() {\n  console.log('被延迟的函数');\n})\n```\n\n用Promise改写\n\n```js\nfunction myPromise() {\n  return new Promise((resolve) => {\n    setTimeout(resolve, 10000);\n  });\n}\n\nmyPromise().then(() => {\n  console.log('被延迟的函数');\n});\n```\n\n**举例二**\n\n```js\nfunction ajax(url, success, fail) {\n  let xmlhttp = new XMLHttpRequest();\n  xmlhttp.open('GET', url);\n  xmlhttp.send();\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {\n      success && success(xmlhttp.responseText);\n    } else {\n      fail && fail(new Error('err'));\n    }\n  };\n}\n\nfunction promiseA() {\n  return new Promise((resolve, reject) => {\n    ajax('test.php', (res) => {\n      if (res.retCode == 0) {\n        resolve('request success' + res);\n      } else {\n        reject({ retCode: -1, msg: 'error' });\n      }\n    });\n  });\n}\n\npromiseA()\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n\n// 或promise实例定义成变量\nconst promiseB = Promise((resolve, reject) => {\n  ajax('test.php', (res) => {\n    if (res.retCode == 0) {\n      resolve('request success' + res);\n    } else {\n      reject({ retCode: -1, msg: 'error' });\n    }\n  });\n});\n\npromiseB()\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n```\n\n**Promise处理失败的写法**\n\n1. 通过catch方法捕获状态变为reject的promise\n2. then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行\n\n## Promise的链式调用\n\n使用Promise优化回调地狱的写法。也就是将多层嵌套调用按照线性的方式进行书写。\n\n```js\nfunction ajax(url, success, fail) {\n  let xmlhttp = new XMLHttpRequest();\n  xmlhttp.open('GET', url);\n  xmlhttp.send();\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {\n      success && success(xmlhttp.responseText);\n    } else {\n      fail && fail(new Error('err'));\n    }\n  };\n}\n\nnew Promise((resolve, reject) => {\n  ajax('a.php', (res_a) => {\n    resolve(res_a); // 状态改为fulfilled,then()方法接收\n  });\n}).then((res_a) => {\n  return new Promise((resolve, reject) => {\n    ajax('b.php', (res_b) => {\n      resolve(res_b);\n    });\n  });\n}).then((res_b) => {\n  console.log(res_b);\n});\n```\n\n可以对promise的链式调用进行封装\n\n```js\n// 定义ajax请求\nfunction ajax(url, success, fail) {\n  let xmlhttp = new XMLHttpRequest();\n  xmlhttp.open('GET', url);\n  xmlhttp.send();\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {\n      success && success(xmlhttp.responseText);\n    } else {\n      fail && fail(new Error('err'));\n    }\n  };\n}\n\n// model层，接口封装\nfunction getPromise(url) {\n  return new Promise((resolve, reject) => {\n    ajax(url, (res) => {\n      //res是接口的返回结果\n      if (res.retCode == 0) {\n        resolve('success' + res);\n      } else {\n        reject({ retCode: -1, msg: 'error'});\n      }\n    });\n  });\n}\n\n// 业务层的接口调用\ngetPromise('a.php')\n  .then((res) => {\n    // a请求成功，res是从resolve获取的结果\n    return getPromise('b.php');\n  })\n  .then((res) => {\n    return getPromise('c.php');\n  })\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n```\n\n## reject状态的处理\n\n**不处理reject**\n\n```js\ngetPromise('a.php')\n  .then(\n    (res) => {\n      // a请求成功，res是从resolve获取的结果\n      console.log('a:' + res)\n      return getPromise('b.php');\n    }\n  .then((res) => {\n    console.log('b:' + res)\n    return getPromise('c.php');\n  })\n  .then((res) => {\n    console.log('c:' + res);\n  });\n```\n\na请求失败，在a的then()方法里只打印err。打印结果\n\n```\na:err\nundefined\nc:success\n```\n\n虽然a请求失败，但后续请求依然会执行\n\n**单独处理reject**\n\n```js\ngetPromise('a.php')\n  .then(\n    (res) => {\n      // a请求成功，res是从resolve获取的结果\n      console.log('a:' + res)\n      return getPromise('b.php');\n    },\n    (err) => {\n      console.log('a:' + err);\n      return getPromise('b.php'); // 即使a请求失败，也继续执行b请求\n    })\n  .then((res) => {\n    console.log('b:' + res)\n    return getPromise('c.php');\n  })\n  .then((res) => {\n    console.log('c:' + res);\n  });\n```\n\n**统一处理reject**\n\n```js\ngetPromise('a.php')\n  .then((res) => {\n    // a请求成功，res是从resolve获取的结果\n    return getPromise('b.php');\n  })\n  .then((res) => {\n    return getPromise('c.php');\n  })\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n```\n\n上面这种写法只要有一个请求失败了，就直接执行catch，剩下的请求就不会继续执行了。\n\n## return的返回值\n\nthen()方法里的返回值，有两种情况：\n\n1. 返回Promise实例对象。返回的该实例对象会调用下一个then\n2. 返回普通值。返回的值会直接传递给下一个then，通过then参数中函数的参数接收该值。返回普通值时，由于并没有返回promise实例对象，那它的then是谁来调用的呢？是产生的一个新的默认的promise实例以确保可以继续链式操作。\n\n","slug":"31天JavaScript学习-第18天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a4000n7owz6u540xqf","content":"<h1 id=\"Promise（一）\"><a href=\"#Promise（一）\" class=\"headerlink\" title=\"Promise（一）\"></a>Promise（一）</h1><span id=\"more\"></span>\n\n<p>JS是一门单线程语言，早期我们解决异步场景时，大部分情况都是通过回调函数来进行。</p>\n<h2 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h2><p>把函数A传给另一个函数B调用，那么函数A就是回调函数。</p>\n<p>例如浏览器中发送Ajax请求，就是一个常见的异步场景，发送请求后，需要等待服务端响应之后我们才能拿到结果。如果希望在异步结束之后执行某个操作，就需要通过回调函数进行操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myAjax(<span class=\"string\">&#x27;a.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res1</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1);</span><br><span class=\"line\">  myAjax(<span class=\"string\">&#x27;b.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res2);</span><br><span class=\"line\">    myAjax(<span class=\"string\">&#x27;c.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res3</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(res3);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>回调的写法比较直观，但层层嵌套也会出现两个问题：</p>\n<ul>\n<li>嵌套过深会出现回调地狱的问题</li>\n<li>不同的函数，回调的参数，写法上不一致导致写法复杂</li>\n</ul>\n<p>因此ES6引入Promise以解决以上问题。</p>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>Promise是一个对象，它可以获取异步操作的消息，可以用同步的表现形式来书写异步代码。</p>\n<p>使用Promise的基本步骤：</p>\n<ol>\n<li>构建一个Promise实例，在其构造函数中传入一个参数，这个参数是一个函数，该函数用于处理异步任务。</li>\n<li>函数中传入两个参数：resolve和reject，分别代表异步执行成功和失败后的回调函数</li>\n<li>通过<code>promise.then()</code>和<code>promise.catch()</code>处理返回结果</li>\n</ol>\n<p><strong>Promise对象的三个状态</strong></p>\n<ul>\n<li>初始化（等待中）：pending</li>\n<li>成功：fulfilled</li>\n<li>失败：rejected</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此时new的操作是同步的，promise的状态被初始化为pending</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 模拟异步操作，成功则调用resolve()，此时promise状态会修改为fulfilled</span></span><br><span class=\"line\">    resolve(<span class=\"string\">&#x27;成功&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(response); &#125;, <span class=\"comment\">// 如果promise的状态为fulfilled，则执行该行语句，函数的参数为resolve()中传递的参数</span></span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(err); &#125; <span class=\"comment\">// 如果promise的状态为rejected，则执行该行语句，函数的参数为reject()中传递的参数</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：Promise的状态一旦改变，就不能再变了</strong></p>\n<p><strong>举例一</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delayfunc</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;等待一秒执行callback&#x27;</span>);</span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myCallback</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;被延迟的函数&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delayfunc(myCallback);</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delayfunc</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(callback, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delayfunc(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;被延迟的函数&#x27;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>用Promise改写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myPromise</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, <span class=\"number\">10000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise().then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;被延迟的函数&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>举例二</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, success, fail</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  xmlhttp.open(<span class=\"string\">&#x27;GET&#x27;</span>, url);</span><br><span class=\"line\">  xmlhttp.send();</span><br><span class=\"line\">  xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp.readyState === <span class=\"number\">4</span> &amp;&amp; xmlhttp.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      success &amp;&amp; success(xmlhttp.responseText);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      fail &amp;&amp; fail(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;err&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promiseA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ajax(<span class=\"string\">&#x27;test.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.retCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&#x27;request success&#x27;</span> + res);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(&#123; <span class=\"attr\">retCode</span>: -<span class=\"number\">1</span>, <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;error&#x27;</span> &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promiseA()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或promise实例定义成变量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseB = <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  ajax(<span class=\"string\">&#x27;test.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.retCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      resolve(<span class=\"string\">&#x27;request success&#x27;</span> + res);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      reject(&#123; <span class=\"attr\">retCode</span>: -<span class=\"number\">1</span>, <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;error&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promiseB()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Promise处理失败的写法</strong></p>\n<ol>\n<li>通过catch方法捕获状态变为reject的promise</li>\n<li>then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行</li>\n</ol>\n<h2 id=\"Promise的链式调用\"><a href=\"#Promise的链式调用\" class=\"headerlink\" title=\"Promise的链式调用\"></a>Promise的链式调用</h2><p>使用Promise优化回调地狱的写法。也就是将多层嵌套调用按照线性的方式进行书写。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, success, fail</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  xmlhttp.open(<span class=\"string\">&#x27;GET&#x27;</span>, url);</span><br><span class=\"line\">  xmlhttp.send();</span><br><span class=\"line\">  xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp.readyState === <span class=\"number\">4</span> &amp;&amp; xmlhttp.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      success &amp;&amp; success(xmlhttp.responseText);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      fail &amp;&amp; fail(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;err&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  ajax(<span class=\"string\">&#x27;a.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res_a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(res_a); <span class=\"comment\">// 状态改为fulfilled,then()方法接收</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">res_a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ajax(<span class=\"string\">&#x27;b.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res_b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(res_b);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">res_b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res_b);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>可以对promise的链式调用进行封装</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义ajax请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, success, fail</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  xmlhttp.open(<span class=\"string\">&#x27;GET&#x27;</span>, url);</span><br><span class=\"line\">  xmlhttp.send();</span><br><span class=\"line\">  xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp.readyState === <span class=\"number\">4</span> &amp;&amp; xmlhttp.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      success &amp;&amp; success(xmlhttp.responseText);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      fail &amp;&amp; fail(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;err&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// model层，接口封装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPromise</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ajax(url, <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//res是接口的返回结果</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.retCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&#x27;success&#x27;</span> + res);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(&#123; <span class=\"attr\">retCode</span>: -<span class=\"number\">1</span>, <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;error&#x27;</span>&#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 业务层的接口调用</span></span><br><span class=\"line\">getPromise(<span class=\"string\">&#x27;a.php&#x27;</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// a请求成功，res是从resolve获取的结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;c.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"reject状态的处理\"><a href=\"#reject状态的处理\" class=\"headerlink\" title=\"reject状态的处理\"></a>reject状态的处理</h2><p><strong>不处理reject</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getPromise(<span class=\"string\">&#x27;a.php&#x27;</span>)</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// a请求成功，res是从resolve获取的结果</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a:&#x27;</span> + res)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;b:&#x27;</span> + res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;c.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;c:&#x27;</span> + res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>a请求失败，在a的then()方法里只打印err。打印结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:err</span><br><span class=\"line\">undefined</span><br><span class=\"line\">c:success</span><br></pre></td></tr></table></figure>\n\n<p>虽然a请求失败，但后续请求依然会执行</p>\n<p><strong>单独处理reject</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getPromise(<span class=\"string\">&#x27;a.php&#x27;</span>)</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// a请求成功，res是从resolve获取的结果</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a:&#x27;</span> + res)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a:&#x27;</span> + err);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>); <span class=\"comment\">// 即使a请求失败，也继续执行b请求</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;b:&#x27;</span> + res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;c.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;c:&#x27;</span> + res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>统一处理reject</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getPromise(<span class=\"string\">&#x27;a.php&#x27;</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// a请求成功，res是从resolve获取的结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;c.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面这种写法只要有一个请求失败了，就直接执行catch，剩下的请求就不会继续执行了。</p>\n<h2 id=\"return的返回值\"><a href=\"#return的返回值\" class=\"headerlink\" title=\"return的返回值\"></a>return的返回值</h2><p>then()方法里的返回值，有两种情况：</p>\n<ol>\n<li>返回Promise实例对象。返回的该实例对象会调用下一个then</li>\n<li>返回普通值。返回的值会直接传递给下一个then，通过then参数中函数的参数接收该值。返回普通值时，由于并没有返回promise实例对象，那它的then是谁来调用的呢？是产生的一个新的默认的promise实例以确保可以继续链式操作。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"Promise（一）\"><a href=\"#Promise（一）\" class=\"headerlink\" title=\"Promise（一）\"></a>Promise（一）</h1>","more":"<p>JS是一门单线程语言，早期我们解决异步场景时，大部分情况都是通过回调函数来进行。</p>\n<h2 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h2><p>把函数A传给另一个函数B调用，那么函数A就是回调函数。</p>\n<p>例如浏览器中发送Ajax请求，就是一个常见的异步场景，发送请求后，需要等待服务端响应之后我们才能拿到结果。如果希望在异步结束之后执行某个操作，就需要通过回调函数进行操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myAjax(<span class=\"string\">&#x27;a.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res1</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1);</span><br><span class=\"line\">  myAjax(<span class=\"string\">&#x27;b.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res2);</span><br><span class=\"line\">    myAjax(<span class=\"string\">&#x27;c.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res3</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(res3);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>回调的写法比较直观，但层层嵌套也会出现两个问题：</p>\n<ul>\n<li>嵌套过深会出现回调地狱的问题</li>\n<li>不同的函数，回调的参数，写法上不一致导致写法复杂</li>\n</ul>\n<p>因此ES6引入Promise以解决以上问题。</p>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><p>Promise是一个对象，它可以获取异步操作的消息，可以用同步的表现形式来书写异步代码。</p>\n<p>使用Promise的基本步骤：</p>\n<ol>\n<li>构建一个Promise实例，在其构造函数中传入一个参数，这个参数是一个函数，该函数用于处理异步任务。</li>\n<li>函数中传入两个参数：resolve和reject，分别代表异步执行成功和失败后的回调函数</li>\n<li>通过<code>promise.then()</code>和<code>promise.catch()</code>处理返回结果</li>\n</ol>\n<p><strong>Promise对象的三个状态</strong></p>\n<ul>\n<li>初始化（等待中）：pending</li>\n<li>成功：fulfilled</li>\n<li>失败：rejected</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此时new的操作是同步的，promise的状态被初始化为pending</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 模拟异步操作，成功则调用resolve()，此时promise状态会修改为fulfilled</span></span><br><span class=\"line\">    resolve(<span class=\"string\">&#x27;成功&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(response); &#125;, <span class=\"comment\">// 如果promise的状态为fulfilled，则执行该行语句，函数的参数为resolve()中传递的参数</span></span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(err); &#125; <span class=\"comment\">// 如果promise的状态为rejected，则执行该行语句，函数的参数为reject()中传递的参数</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：Promise的状态一旦改变，就不能再变了</strong></p>\n<p><strong>举例一</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delayfunc</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;等待一秒执行callback&#x27;</span>);</span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myCallback</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;被延迟的函数&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delayfunc(myCallback);</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delayfunc</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(callback, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delayfunc(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;被延迟的函数&#x27;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>用Promise改写</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myPromise</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, <span class=\"number\">10000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise().then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;被延迟的函数&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>举例二</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, success, fail</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  xmlhttp.open(<span class=\"string\">&#x27;GET&#x27;</span>, url);</span><br><span class=\"line\">  xmlhttp.send();</span><br><span class=\"line\">  xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp.readyState === <span class=\"number\">4</span> &amp;&amp; xmlhttp.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      success &amp;&amp; success(xmlhttp.responseText);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      fail &amp;&amp; fail(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;err&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promiseA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ajax(<span class=\"string\">&#x27;test.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.retCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&#x27;request success&#x27;</span> + res);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(&#123; <span class=\"attr\">retCode</span>: -<span class=\"number\">1</span>, <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;error&#x27;</span> &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promiseA()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或promise实例定义成变量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseB = <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  ajax(<span class=\"string\">&#x27;test.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.retCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      resolve(<span class=\"string\">&#x27;request success&#x27;</span> + res);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      reject(&#123; <span class=\"attr\">retCode</span>: -<span class=\"number\">1</span>, <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;error&#x27;</span> &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promiseB()</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Promise处理失败的写法</strong></p>\n<ol>\n<li>通过catch方法捕获状态变为reject的promise</li>\n<li>then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行</li>\n</ol>\n<h2 id=\"Promise的链式调用\"><a href=\"#Promise的链式调用\" class=\"headerlink\" title=\"Promise的链式调用\"></a>Promise的链式调用</h2><p>使用Promise优化回调地狱的写法。也就是将多层嵌套调用按照线性的方式进行书写。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, success, fail</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  xmlhttp.open(<span class=\"string\">&#x27;GET&#x27;</span>, url);</span><br><span class=\"line\">  xmlhttp.send();</span><br><span class=\"line\">  xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp.readyState === <span class=\"number\">4</span> &amp;&amp; xmlhttp.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      success &amp;&amp; success(xmlhttp.responseText);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      fail &amp;&amp; fail(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;err&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  ajax(<span class=\"string\">&#x27;a.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res_a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(res_a); <span class=\"comment\">// 状态改为fulfilled,then()方法接收</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">res_a</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ajax(<span class=\"string\">&#x27;b.php&#x27;</span>, <span class=\"function\">(<span class=\"params\">res_b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(res_b);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">res_b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res_b);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>可以对promise的链式调用进行封装</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义ajax请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, success, fail</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  xmlhttp.open(<span class=\"string\">&#x27;GET&#x27;</span>, url);</span><br><span class=\"line\">  xmlhttp.send();</span><br><span class=\"line\">  xmlhttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xmlhttp.readyState === <span class=\"number\">4</span> &amp;&amp; xmlhttp.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      success &amp;&amp; success(xmlhttp.responseText);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      fail &amp;&amp; fail(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;err&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// model层，接口封装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPromise</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ajax(url, <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//res是接口的返回结果</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.retCode == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&#x27;success&#x27;</span> + res);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(&#123; <span class=\"attr\">retCode</span>: -<span class=\"number\">1</span>, <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;error&#x27;</span>&#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 业务层的接口调用</span></span><br><span class=\"line\">getPromise(<span class=\"string\">&#x27;a.php&#x27;</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// a请求成功，res是从resolve获取的结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;c.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"reject状态的处理\"><a href=\"#reject状态的处理\" class=\"headerlink\" title=\"reject状态的处理\"></a>reject状态的处理</h2><p><strong>不处理reject</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getPromise(<span class=\"string\">&#x27;a.php&#x27;</span>)</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// a请求成功，res是从resolve获取的结果</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a:&#x27;</span> + res)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;b:&#x27;</span> + res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;c.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;c:&#x27;</span> + res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>a请求失败，在a的then()方法里只打印err。打印结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a:err</span><br><span class=\"line\">undefined</span><br><span class=\"line\">c:success</span><br></pre></td></tr></table></figure>\n\n<p>虽然a请求失败，但后续请求依然会执行</p>\n<p><strong>单独处理reject</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getPromise(<span class=\"string\">&#x27;a.php&#x27;</span>)</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// a请求成功，res是从resolve获取的结果</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a:&#x27;</span> + res)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a:&#x27;</span> + err);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>); <span class=\"comment\">// 即使a请求失败，也继续执行b请求</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;b:&#x27;</span> + res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;c.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;c:&#x27;</span> + res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>统一处理reject</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getPromise(<span class=\"string\">&#x27;a.php&#x27;</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// a请求成功，res是从resolve获取的结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;b.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPromise(<span class=\"string\">&#x27;c.php&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面这种写法只要有一个请求失败了，就直接执行catch，剩下的请求就不会继续执行了。</p>\n<h2 id=\"return的返回值\"><a href=\"#return的返回值\" class=\"headerlink\" title=\"return的返回值\"></a>return的返回值</h2><p>then()方法里的返回值，有两种情况：</p>\n<ol>\n<li>返回Promise实例对象。返回的该实例对象会调用下一个then</li>\n<li>返回普通值。返回的值会直接传递给下一个then，通过then参数中函数的参数接收该值。返回普通值时，由于并没有返回promise实例对象，那它的then是谁来调用的呢？是产生的一个新的默认的promise实例以确保可以继续链式操作。</li>\n</ol>"},{"title":"31天JavaScript学习-第20天","reprint":false,"date":"2022-03-20T12:03:44.000Z","updated":"2022-03-20T12:03:44.000Z","conver":null,"_content":"\n# Async/Await\n\n<!--more-->\n\nasync/await是ES8引入的新语法，是另外一种异步编程解决方案。\n\n其本质是Generator的语法糖\n\nasync返回Promise实例对象，await可以得到异步结果。\n\n## async\n\n先查看一下async返回的结果\n\n```js\nasync function testAsync() {\n  return 'okk';\n}\n\nconst result = testAsync();\nconsole.log(result); // Promise { 'okk' }\n```\n\n可以看到，async函数返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通过`Promise.resolve()`封装成一个Promise对象。因此，我们可以用`then()`来处理这个Promise对象\n\n```js\ntestAsync().then(res => {\n  console.log(res);\n}); // okk\n```\n\n由上一节可以知道，Promise对象的生成是同步代码，在Promise对象中调用的`resolve()`和`reject()`才是异步任务。因此，在没有await的情况下执行async函数，它会按照同步顺序执行，返回一个Promise对象。\n\n## await\n\nawait等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。\n\n```js\nfunction func1() {\n  return 'func1';\n}\n\nasync function func2() {\n  return 'func2';\n  // return Promise.resolve('func2');\n}\n\nasync function test() {\n  let v1 = func1(); \n  let v2 = func2();\n  console.log(v1); // func1\n  console.log(v2); // Promise { 'func2' }\n \n  const res1 = await func1();\n  const res2 = await func2();\n  console.log(res1); // func1\n  console.log(res2); // func2\n}\n\ntest();\n\n```\n\n如果等到的不是一个Promise对象，await运算结果就是它等到的量。\n\n如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。）\n\n## 组合使用\n\n首先看一下Promise与async/await的写法区别\n\n```js\nfunction waitForAwhile() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('long_time_step'), 2000);\n  });\n}\n\nwaitForAwhile().then(v => {\n  console.log('got', v);\n}); // got long_time_step\n```\n\n```js\nfunction waitForAwhile() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('long_time_step'), 2000);\n  });\n}\n\nasync function test () {\n  const v = await waitForAwhile();\n  console.log(v);\n}\n\ntest();\n```\n\nasync/await的优势是在处理多个Promise的then链\n\n```js\nfunction waitForAwhile(n) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(n + 200), n);\n  });\n}\n\nfunction step1(n) {\n  console.log(`step1 with ${n}`);\n  return waitForAwhile(n);\n}\n\nfunction step2(n) {\n  console.log(`step2 with ${n}`);\n  return waitForAwhile(n);\n}\n\nfunction step3(n) {\n  console.log(`step3 with ${n}`);\n  return waitForAwhile(n);\n}\n```\n\n如果使用Promise来处理该步骤\n\n```js\nfunction doIt() {\n  console.log('doIt');\n  const time1 = 300;\n  step1(time1)\n    .then(time2 => step2(time2))\n    .then(time3 => step3(time3))\n    .then(result => {\n      console.log(`result is ${result}`);\n      console.log(\"finish\");\n    });\n}\ndoIt();\n```\n\n如果用async/await来处理该步骤\n\n```js\nasync function doIt() {\n  console.log('doIt');\n  const time1 = 300;\n  const time2 = await step1(time1);\n  const time3 = await step2(time2);\n  const result = await step3(time3);\n  console.log(`result is ${result}`);\n  console.log('finish');\n}\n\ndoIt();\n```\n\nasync/await主要解决了Promise传递参数太麻烦的痛点。\n\n## 处理reject状态\n\nawait处理的Promise对象，其状态可能是reject，因此最好把await命令放在try...catch代码块中。\n\n```js\nasync function myFunction() {\n  try {\n    await returnSomePromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 第二种写法\nasync function myFunction() {\n  await returnSomePromise().catch(function (err) {\n    console.log(err);\n  });\n}\n```\n\n","source":"_posts/31天JavaScript学习-第20天.md","raw":"---\ntitle: 31天JavaScript学习-第20天\nreprint: false\ndate: 2022-03-20 20:03:44\nupdated: 2022-03-20 20:03:44\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# Async/Await\n\n<!--more-->\n\nasync/await是ES8引入的新语法，是另外一种异步编程解决方案。\n\n其本质是Generator的语法糖\n\nasync返回Promise实例对象，await可以得到异步结果。\n\n## async\n\n先查看一下async返回的结果\n\n```js\nasync function testAsync() {\n  return 'okk';\n}\n\nconst result = testAsync();\nconsole.log(result); // Promise { 'okk' }\n```\n\n可以看到，async函数返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通过`Promise.resolve()`封装成一个Promise对象。因此，我们可以用`then()`来处理这个Promise对象\n\n```js\ntestAsync().then(res => {\n  console.log(res);\n}); // okk\n```\n\n由上一节可以知道，Promise对象的生成是同步代码，在Promise对象中调用的`resolve()`和`reject()`才是异步任务。因此，在没有await的情况下执行async函数，它会按照同步顺序执行，返回一个Promise对象。\n\n## await\n\nawait等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。\n\n```js\nfunction func1() {\n  return 'func1';\n}\n\nasync function func2() {\n  return 'func2';\n  // return Promise.resolve('func2');\n}\n\nasync function test() {\n  let v1 = func1(); \n  let v2 = func2();\n  console.log(v1); // func1\n  console.log(v2); // Promise { 'func2' }\n \n  const res1 = await func1();\n  const res2 = await func2();\n  console.log(res1); // func1\n  console.log(res2); // func2\n}\n\ntest();\n\n```\n\n如果等到的不是一个Promise对象，await运算结果就是它等到的量。\n\n如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。）\n\n## 组合使用\n\n首先看一下Promise与async/await的写法区别\n\n```js\nfunction waitForAwhile() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('long_time_step'), 2000);\n  });\n}\n\nwaitForAwhile().then(v => {\n  console.log('got', v);\n}); // got long_time_step\n```\n\n```js\nfunction waitForAwhile() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve('long_time_step'), 2000);\n  });\n}\n\nasync function test () {\n  const v = await waitForAwhile();\n  console.log(v);\n}\n\ntest();\n```\n\nasync/await的优势是在处理多个Promise的then链\n\n```js\nfunction waitForAwhile(n) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(n + 200), n);\n  });\n}\n\nfunction step1(n) {\n  console.log(`step1 with ${n}`);\n  return waitForAwhile(n);\n}\n\nfunction step2(n) {\n  console.log(`step2 with ${n}`);\n  return waitForAwhile(n);\n}\n\nfunction step3(n) {\n  console.log(`step3 with ${n}`);\n  return waitForAwhile(n);\n}\n```\n\n如果使用Promise来处理该步骤\n\n```js\nfunction doIt() {\n  console.log('doIt');\n  const time1 = 300;\n  step1(time1)\n    .then(time2 => step2(time2))\n    .then(time3 => step3(time3))\n    .then(result => {\n      console.log(`result is ${result}`);\n      console.log(\"finish\");\n    });\n}\ndoIt();\n```\n\n如果用async/await来处理该步骤\n\n```js\nasync function doIt() {\n  console.log('doIt');\n  const time1 = 300;\n  const time2 = await step1(time1);\n  const time3 = await step2(time2);\n  const result = await step3(time3);\n  console.log(`result is ${result}`);\n  console.log('finish');\n}\n\ndoIt();\n```\n\nasync/await主要解决了Promise传递参数太麻烦的痛点。\n\n## 处理reject状态\n\nawait处理的Promise对象，其状态可能是reject，因此最好把await命令放在try...catch代码块中。\n\n```js\nasync function myFunction() {\n  try {\n    await returnSomePromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 第二种写法\nasync function myFunction() {\n  await returnSomePromise().catch(function (err) {\n    console.log(err);\n  });\n}\n```\n\n","slug":"31天JavaScript学习-第20天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a4000q7owz3lfz1flg","content":"<h1 id=\"Async-Await\"><a href=\"#Async-Await\" class=\"headerlink\" title=\"Async/Await\"></a>Async/Await</h1><span id=\"more\"></span>\n\n<p>async/await是ES8引入的新语法，是另外一种异步编程解决方案。</p>\n<p>其本质是Generator的语法糖</p>\n<p>async返回Promise实例对象，await可以得到异步结果。</p>\n<h2 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h2><p>先查看一下async返回的结果</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;okk&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = testAsync();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// Promise &#123; &#x27;okk&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，async函数返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通过<code>Promise.resolve()</code>封装成一个Promise对象。因此，我们可以用<code>then()</code>来处理这个Promise对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testAsync().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;); <span class=\"comment\">// okk</span></span><br></pre></td></tr></table></figure>\n\n<p>由上一节可以知道，Promise对象的生成是同步代码，在Promise对象中调用的<code>resolve()</code>和<code>reject()</code>才是异步任务。因此，在没有await的情况下执行async函数，它会按照同步顺序执行，返回一个Promise对象。</p>\n<h2 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h2><p>await等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;func1&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;func2&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// return Promise.resolve(&#x27;func2&#x27;);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> v1 = func1(); </span><br><span class=\"line\">  <span class=\"keyword\">let</span> v2 = func2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v1); <span class=\"comment\">// func1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v2); <span class=\"comment\">// Promise &#123; &#x27;func2&#x27; &#125;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">const</span> res1 = <span class=\"keyword\">await</span> func1();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">await</span> func2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// func1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res2); <span class=\"comment\">// func2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果等到的不是一个Promise对象，await运算结果就是它等到的量。</p>\n<p>如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。）</p>\n<h2 id=\"组合使用\"><a href=\"#组合使用\" class=\"headerlink\" title=\"组合使用\"></a>组合使用</h2><p>首先看一下Promise与async/await的写法区别</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitForAwhile</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> resolve(<span class=\"string\">&#x27;long_time_step&#x27;</span>), <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">waitForAwhile().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;got&#x27;</span>, v);</span><br><span class=\"line\">&#125;); <span class=\"comment\">// got long_time_step</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitForAwhile</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> resolve(<span class=\"string\">&#x27;long_time_step&#x27;</span>), <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> v = <span class=\"keyword\">await</span> waitForAwhile();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n\n<p>async/await的优势是在处理多个Promise的then链</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitForAwhile</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> resolve(n + <span class=\"number\">200</span>), n);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> waitForAwhile(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> waitForAwhile(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> waitForAwhile(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用Promise来处理该步骤</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;doIt&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">  step1(time1)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> step2(time2))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> step3(time3))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;finish&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure>\n\n<p>如果用async/await来处理该步骤</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;doIt&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> step1(time1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> step2(time2);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(time3);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;finish&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure>\n\n<p>async/await主要解决了Promise传递参数太麻烦的痛点。</p>\n<h2 id=\"处理reject状态\"><a href=\"#处理reject状态\" class=\"headerlink\" title=\"处理reject状态\"></a>处理reject状态</h2><p>await处理的Promise对象，其状态可能是reject，因此最好把await命令放在try…catch代码块中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> returnSomePromise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> returnSomePromise().catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"Async-Await\"><a href=\"#Async-Await\" class=\"headerlink\" title=\"Async/Await\"></a>Async/Await</h1>","more":"<p>async/await是ES8引入的新语法，是另外一种异步编程解决方案。</p>\n<p>其本质是Generator的语法糖</p>\n<p>async返回Promise实例对象，await可以得到异步结果。</p>\n<h2 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h2><p>先查看一下async返回的结果</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;okk&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = testAsync();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// Promise &#123; &#x27;okk&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，async函数返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通过<code>Promise.resolve()</code>封装成一个Promise对象。因此，我们可以用<code>then()</code>来处理这个Promise对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testAsync().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;); <span class=\"comment\">// okk</span></span><br></pre></td></tr></table></figure>\n\n<p>由上一节可以知道，Promise对象的生成是同步代码，在Promise对象中调用的<code>resolve()</code>和<code>reject()</code>才是异步任务。因此，在没有await的情况下执行async函数，它会按照同步顺序执行，返回一个Promise对象。</p>\n<h2 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h2><p>await等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;func1&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;func2&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// return Promise.resolve(&#x27;func2&#x27;);</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> v1 = func1(); </span><br><span class=\"line\">  <span class=\"keyword\">let</span> v2 = func2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v1); <span class=\"comment\">// func1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v2); <span class=\"comment\">// Promise &#123; &#x27;func2&#x27; &#125;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">const</span> res1 = <span class=\"keyword\">await</span> func1();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">await</span> func2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1); <span class=\"comment\">// func1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res2); <span class=\"comment\">// func2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果等到的不是一个Promise对象，await运算结果就是它等到的量。</p>\n<p>如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。）</p>\n<h2 id=\"组合使用\"><a href=\"#组合使用\" class=\"headerlink\" title=\"组合使用\"></a>组合使用</h2><p>首先看一下Promise与async/await的写法区别</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitForAwhile</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> resolve(<span class=\"string\">&#x27;long_time_step&#x27;</span>), <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">waitForAwhile().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;got&#x27;</span>, v);</span><br><span class=\"line\">&#125;); <span class=\"comment\">// got long_time_step</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitForAwhile</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> resolve(<span class=\"string\">&#x27;long_time_step&#x27;</span>), <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> v = <span class=\"keyword\">await</span> waitForAwhile();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n\n<p>async/await的优势是在处理多个Promise的then链</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitForAwhile</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> resolve(n + <span class=\"number\">200</span>), n);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> waitForAwhile(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> waitForAwhile(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> waitForAwhile(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用Promise来处理该步骤</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;doIt&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">  step1(time1)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> step2(time2))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> step3(time3))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;finish&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure>\n\n<p>如果用async/await来处理该步骤</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;doIt&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> step1(time1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> step2(time2);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(time3);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;finish&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure>\n\n<p>async/await主要解决了Promise传递参数太麻烦的痛点。</p>\n<h2 id=\"处理reject状态\"><a href=\"#处理reject状态\" class=\"headerlink\" title=\"处理reject状态\"></a>处理reject状态</h2><p>await处理的Promise对象，其状态可能是reject，因此最好把await命令放在try…catch代码块中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> returnSomePromise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> returnSomePromise().catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"31天JavaScript学习-第21天","reprint":false,"date":"2022-03-25T11:48:47.000Z","updated":"2022-03-25T11:48:47.000Z","conver":null,"_content":"\n# CSS\n\n<!--more-->\n\n## CSS的渲染步骤\n\n1. 浏览器载入HTML文件（比如从网络上获取）。\n2. 将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。\n3. 接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。\n4. 浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。\n5. 上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。\n6. 网页展示在屏幕上（这一步被称为着色）。\n\n![img](31天JavaScript学习-第21天/rendering.svg)\n\n## 选择器\n\n### 基本选择器\n\n| 选择器           | 示例      | 描述                                       |\n| ---------------- | --------- | ------------------------------------------ |\n| *                | *         | 选择所有元素                               |\n| element          | div       | 选择所有div类型元素                        |\n| .class           | .footer   | 选择所有class='footer'的元素               |\n| #id              | #username | 选择所有id='username'的元素                |\n| element, element | div, p    | 选择所有div和p类型元素                     |\n| element>element  | div>p     | 选择所有父元素为div的所有p元素，不包括孙子 |\n| element+element  | div+p     | 选择紧接在div后面的p元素                   |\n| element~element  | p~ul      | 选择与p元素同级并在p后面的所有ul元素       |\n\n### 伪类选择器\n\n为元素的不同状态或为不确定存在的元素设置样式规则\n\n| 状态                 | 示例                  | 说明                                       |\n| -------------------- | --------------------- | ------------------------------------------ |\n| :link                | a:link                | 选择所有未被访问的链接                     |\n| :visited             | a:visited             | 选择所有已被访问的链接                     |\n| :hover               | a:hover               | 鼠标移动到元素上时                         |\n| :active              | a:active              | 点击正在发生时                             |\n| :focus               | input::focus          | 选择获得焦点的 input 元素                  |\n| :root                | :root                 | 选择文档的根元素即html。                   |\n| :empty               | p:empty               | 选择没有子元素的每个元素（包括文本节点）。 |\n| :first-child         | p:first-child         | 选择属于父元素的第一个子元素的每个元素     |\n| :last-child          | p:last-child          | 选择属于其父元素最后一个子元素每个元素。   |\n| :first-of-type       | p:first-of-type       | 选择属于其父元素的首个元素的每个元素       |\n| :last-of-type        | p:last-of-type        | 选择属于其父元素的最后元素的每个元素。     |\n| :only-of-type        | p:only-of-type        | 选择属于其父元素唯一的元素的每个元素。     |\n| :only-child          | p:only-child          | 选择属于其父元素的唯一子元素的每个元素。   |\n| :nth-child(n)        | p:nth-child(2)        | 选择属于其父元素的第二个子元素的每个元素。 |\n| :nth-child(odd)      | p:nth-child(odd)      | 选择属于其父元素的奇数元素。               |\n| :nth-child(even)     | p:nth-child(even)     | 选择属于其父元素的偶数元素。               |\n| :nth-of-type(n)      | p:nth-of-type(2)      | 选择属于其父元素第二个元素的每个元素。     |\n| :nth-last-child(n)   | p:nth-last-child(2)   | 同上，从最后一个子元素开始计数。           |\n| :nth-last-of-type(n) | p:nth-last-of-type(2) | 同上，但是从最后一个子元素开始计数。       |\n| :not(selector)       | :not(p)               | 选择非元素的每个元素                       |\n\ncss引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说：伪类和伪元素是用来修饰不在文档树中的部分。\n\n伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的。例如：当用户悬停在指定元素时，可以通过:hover来描述这个元素的状态，虽然它和一般css相似，可以为已有元素添加样式，但是它只有处于DOM树无法描述的状态下才能为元素添加样式，所以称为伪类。\n\n伪元素：用于创建一些不在DOM树中的元素，并为其添加样式。例如，我们可以通过:before来在一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看见这些文本，但是它实际上并不在DOM文档中。\n\n**css3规范中要求使用双冒号（::）表示伪元素，以此来区分伪类和伪元素**，比如::before和::after等伪元素使用双冒号（::），:hover和:active伪类使用单冒号（:）。\n\n## 盒子模型\n\n\n\n## 浮动布局\n\n## 定位布局\n\n## 弹性布局\n\n## 栅格系统\n","source":"_posts/31天JavaScript学习-第21天.md","raw":"---\ntitle: 31天JavaScript学习-第21天\nreprint: false\ndate: 2022-03-25 19:48:47\nupdated: 2022-03-25 19:48:47\nconver:\ncategories: 前端\ntags:\n  - CSS\n---\n\n# CSS\n\n<!--more-->\n\n## CSS的渲染步骤\n\n1. 浏览器载入HTML文件（比如从网络上获取）。\n2. 将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。\n3. 接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。\n4. 浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。\n5. 上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。\n6. 网页展示在屏幕上（这一步被称为着色）。\n\n![img](31天JavaScript学习-第21天/rendering.svg)\n\n## 选择器\n\n### 基本选择器\n\n| 选择器           | 示例      | 描述                                       |\n| ---------------- | --------- | ------------------------------------------ |\n| *                | *         | 选择所有元素                               |\n| element          | div       | 选择所有div类型元素                        |\n| .class           | .footer   | 选择所有class='footer'的元素               |\n| #id              | #username | 选择所有id='username'的元素                |\n| element, element | div, p    | 选择所有div和p类型元素                     |\n| element>element  | div>p     | 选择所有父元素为div的所有p元素，不包括孙子 |\n| element+element  | div+p     | 选择紧接在div后面的p元素                   |\n| element~element  | p~ul      | 选择与p元素同级并在p后面的所有ul元素       |\n\n### 伪类选择器\n\n为元素的不同状态或为不确定存在的元素设置样式规则\n\n| 状态                 | 示例                  | 说明                                       |\n| -------------------- | --------------------- | ------------------------------------------ |\n| :link                | a:link                | 选择所有未被访问的链接                     |\n| :visited             | a:visited             | 选择所有已被访问的链接                     |\n| :hover               | a:hover               | 鼠标移动到元素上时                         |\n| :active              | a:active              | 点击正在发生时                             |\n| :focus               | input::focus          | 选择获得焦点的 input 元素                  |\n| :root                | :root                 | 选择文档的根元素即html。                   |\n| :empty               | p:empty               | 选择没有子元素的每个元素（包括文本节点）。 |\n| :first-child         | p:first-child         | 选择属于父元素的第一个子元素的每个元素     |\n| :last-child          | p:last-child          | 选择属于其父元素最后一个子元素每个元素。   |\n| :first-of-type       | p:first-of-type       | 选择属于其父元素的首个元素的每个元素       |\n| :last-of-type        | p:last-of-type        | 选择属于其父元素的最后元素的每个元素。     |\n| :only-of-type        | p:only-of-type        | 选择属于其父元素唯一的元素的每个元素。     |\n| :only-child          | p:only-child          | 选择属于其父元素的唯一子元素的每个元素。   |\n| :nth-child(n)        | p:nth-child(2)        | 选择属于其父元素的第二个子元素的每个元素。 |\n| :nth-child(odd)      | p:nth-child(odd)      | 选择属于其父元素的奇数元素。               |\n| :nth-child(even)     | p:nth-child(even)     | 选择属于其父元素的偶数元素。               |\n| :nth-of-type(n)      | p:nth-of-type(2)      | 选择属于其父元素第二个元素的每个元素。     |\n| :nth-last-child(n)   | p:nth-last-child(2)   | 同上，从最后一个子元素开始计数。           |\n| :nth-last-of-type(n) | p:nth-last-of-type(2) | 同上，但是从最后一个子元素开始计数。       |\n| :not(selector)       | :not(p)               | 选择非元素的每个元素                       |\n\ncss引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说：伪类和伪元素是用来修饰不在文档树中的部分。\n\n伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的。例如：当用户悬停在指定元素时，可以通过:hover来描述这个元素的状态，虽然它和一般css相似，可以为已有元素添加样式，但是它只有处于DOM树无法描述的状态下才能为元素添加样式，所以称为伪类。\n\n伪元素：用于创建一些不在DOM树中的元素，并为其添加样式。例如，我们可以通过:before来在一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看见这些文本，但是它实际上并不在DOM文档中。\n\n**css3规范中要求使用双冒号（::）表示伪元素，以此来区分伪类和伪元素**，比如::before和::after等伪元素使用双冒号（::），:hover和:active伪类使用单冒号（:）。\n\n## 盒子模型\n\n\n\n## 浮动布局\n\n## 定位布局\n\n## 弹性布局\n\n## 栅格系统\n","slug":"31天JavaScript学习-第21天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a5000t7owzaruz9m04","content":"<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1><span id=\"more\"></span>\n\n<h2 id=\"CSS的渲染步骤\"><a href=\"#CSS的渲染步骤\" class=\"headerlink\" title=\"CSS的渲染步骤\"></a>CSS的渲染步骤</h2><ol>\n<li>浏览器载入HTML文件（比如从网络上获取）。</li>\n<li>将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。</li>\n<li>接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。</li>\n<li>浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。</li>\n<li>上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。</li>\n<li>网页展示在屏幕上（这一步被称为着色）。</li>\n</ol>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/03/25/a475fcf4753b/rendering.svg\" alt=\"img\" class=\"lazyload\"></p>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><h3 id=\"基本选择器\"><a href=\"#基本选择器\" class=\"headerlink\" title=\"基本选择器\"></a>基本选择器</h3><table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>示例</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>*</td>\n<td>选择所有元素</td>\n</tr>\n<tr>\n<td>element</td>\n<td>div</td>\n<td>选择所有div类型元素</td>\n</tr>\n<tr>\n<td>.class</td>\n<td>.footer</td>\n<td>选择所有class=’footer’的元素</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>#username</td>\n<td>选择所有id=’username’的元素</td>\n</tr>\n<tr>\n<td>element, element</td>\n<td>div, p</td>\n<td>选择所有div和p类型元素</td>\n</tr>\n<tr>\n<td>element&gt;element</td>\n<td>div&gt;p</td>\n<td>选择所有父元素为div的所有p元素，不包括孙子</td>\n</tr>\n<tr>\n<td>element+element</td>\n<td>div+p</td>\n<td>选择紧接在div后面的p元素</td>\n</tr>\n<tr>\n<td>element~element</td>\n<td>p~ul</td>\n<td>选择与p元素同级并在p后面的所有ul元素</td>\n</tr>\n</tbody></table>\n<h3 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h3><p>为元素的不同状态或为不确定存在的元素设置样式规则</p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>:link</td>\n<td>a:link</td>\n<td>选择所有未被访问的链接</td>\n</tr>\n<tr>\n<td>:visited</td>\n<td>a:visited</td>\n<td>选择所有已被访问的链接</td>\n</tr>\n<tr>\n<td>:hover</td>\n<td>a:hover</td>\n<td>鼠标移动到元素上时</td>\n</tr>\n<tr>\n<td>:active</td>\n<td>a:active</td>\n<td>点击正在发生时</td>\n</tr>\n<tr>\n<td>:focus</td>\n<td>input::focus</td>\n<td>选择获得焦点的 input 元素</td>\n</tr>\n<tr>\n<td>:root</td>\n<td>:root</td>\n<td>选择文档的根元素即html。</td>\n</tr>\n<tr>\n<td>:empty</td>\n<td>p:empty</td>\n<td>选择没有子元素的每个元素（包括文本节点）。</td>\n</tr>\n<tr>\n<td>:first-child</td>\n<td>p:first-child</td>\n<td>选择属于父元素的第一个子元素的每个元素</td>\n</tr>\n<tr>\n<td>:last-child</td>\n<td>p:last-child</td>\n<td>选择属于其父元素最后一个子元素每个元素。</td>\n</tr>\n<tr>\n<td>:first-of-type</td>\n<td>p:first-of-type</td>\n<td>选择属于其父元素的首个元素的每个元素</td>\n</tr>\n<tr>\n<td>:last-of-type</td>\n<td>p:last-of-type</td>\n<td>选择属于其父元素的最后元素的每个元素。</td>\n</tr>\n<tr>\n<td>:only-of-type</td>\n<td>p:only-of-type</td>\n<td>选择属于其父元素唯一的元素的每个元素。</td>\n</tr>\n<tr>\n<td>:only-child</td>\n<td>p:only-child</td>\n<td>选择属于其父元素的唯一子元素的每个元素。</td>\n</tr>\n<tr>\n<td>:nth-child(n)</td>\n<td>p:nth-child(2)</td>\n<td>选择属于其父元素的第二个子元素的每个元素。</td>\n</tr>\n<tr>\n<td>:nth-child(odd)</td>\n<td>p:nth-child(odd)</td>\n<td>选择属于其父元素的奇数元素。</td>\n</tr>\n<tr>\n<td>:nth-child(even)</td>\n<td>p:nth-child(even)</td>\n<td>选择属于其父元素的偶数元素。</td>\n</tr>\n<tr>\n<td>:nth-of-type(n)</td>\n<td>p:nth-of-type(2)</td>\n<td>选择属于其父元素第二个元素的每个元素。</td>\n</tr>\n<tr>\n<td>:nth-last-child(n)</td>\n<td>p:nth-last-child(2)</td>\n<td>同上，从最后一个子元素开始计数。</td>\n</tr>\n<tr>\n<td>:nth-last-of-type(n)</td>\n<td>p:nth-last-of-type(2)</td>\n<td>同上，但是从最后一个子元素开始计数。</td>\n</tr>\n<tr>\n<td>:not(selector)</td>\n<td>:not(p)</td>\n<td>选择非元素的每个元素</td>\n</tr>\n</tbody></table>\n<p>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说：伪类和伪元素是用来修饰不在文档树中的部分。</p>\n<p>伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的。例如：当用户悬停在指定元素时，可以通过:hover来描述这个元素的状态，虽然它和一般css相似，可以为已有元素添加样式，但是它只有处于DOM树无法描述的状态下才能为元素添加样式，所以称为伪类。</p>\n<p>伪元素：用于创建一些不在DOM树中的元素，并为其添加样式。例如，我们可以通过:before来在一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看见这些文本，但是它实际上并不在DOM文档中。</p>\n<p><strong>css3规范中要求使用双冒号（::）表示伪元素，以此来区分伪类和伪元素</strong>，比如::before和::after等伪元素使用双冒号（::），:hover和:active伪类使用单冒号（:）。</p>\n<h2 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h2><h2 id=\"浮动布局\"><a href=\"#浮动布局\" class=\"headerlink\" title=\"浮动布局\"></a>浮动布局</h2><h2 id=\"定位布局\"><a href=\"#定位布局\" class=\"headerlink\" title=\"定位布局\"></a>定位布局</h2><h2 id=\"弹性布局\"><a href=\"#弹性布局\" class=\"headerlink\" title=\"弹性布局\"></a>弹性布局</h2><h2 id=\"栅格系统\"><a href=\"#栅格系统\" class=\"headerlink\" title=\"栅格系统\"></a>栅格系统</h2>","site":{"data":{}},"excerpt":"<h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1>","more":"<h2 id=\"CSS的渲染步骤\"><a href=\"#CSS的渲染步骤\" class=\"headerlink\" title=\"CSS的渲染步骤\"></a>CSS的渲染步骤</h2><ol>\n<li>浏览器载入HTML文件（比如从网络上获取）。</li>\n<li>将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。</li>\n<li>接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。</li>\n<li>浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。</li>\n<li>上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。</li>\n<li>网页展示在屏幕上（这一步被称为着色）。</li>\n</ol>\n<p><img src=\"/2022/03/25/a475fcf4753b/rendering.svg\" alt=\"img\"></p>\n<h2 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h2><h3 id=\"基本选择器\"><a href=\"#基本选择器\" class=\"headerlink\" title=\"基本选择器\"></a>基本选择器</h3><table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>示例</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>*</td>\n<td>选择所有元素</td>\n</tr>\n<tr>\n<td>element</td>\n<td>div</td>\n<td>选择所有div类型元素</td>\n</tr>\n<tr>\n<td>.class</td>\n<td>.footer</td>\n<td>选择所有class=’footer’的元素</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>#username</td>\n<td>选择所有id=’username’的元素</td>\n</tr>\n<tr>\n<td>element, element</td>\n<td>div, p</td>\n<td>选择所有div和p类型元素</td>\n</tr>\n<tr>\n<td>element&gt;element</td>\n<td>div&gt;p</td>\n<td>选择所有父元素为div的所有p元素，不包括孙子</td>\n</tr>\n<tr>\n<td>element+element</td>\n<td>div+p</td>\n<td>选择紧接在div后面的p元素</td>\n</tr>\n<tr>\n<td>element~element</td>\n<td>p~ul</td>\n<td>选择与p元素同级并在p后面的所有ul元素</td>\n</tr>\n</tbody></table>\n<h3 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h3><p>为元素的不同状态或为不确定存在的元素设置样式规则</p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>:link</td>\n<td>a:link</td>\n<td>选择所有未被访问的链接</td>\n</tr>\n<tr>\n<td>:visited</td>\n<td>a:visited</td>\n<td>选择所有已被访问的链接</td>\n</tr>\n<tr>\n<td>:hover</td>\n<td>a:hover</td>\n<td>鼠标移动到元素上时</td>\n</tr>\n<tr>\n<td>:active</td>\n<td>a:active</td>\n<td>点击正在发生时</td>\n</tr>\n<tr>\n<td>:focus</td>\n<td>input::focus</td>\n<td>选择获得焦点的 input 元素</td>\n</tr>\n<tr>\n<td>:root</td>\n<td>:root</td>\n<td>选择文档的根元素即html。</td>\n</tr>\n<tr>\n<td>:empty</td>\n<td>p:empty</td>\n<td>选择没有子元素的每个元素（包括文本节点）。</td>\n</tr>\n<tr>\n<td>:first-child</td>\n<td>p:first-child</td>\n<td>选择属于父元素的第一个子元素的每个元素</td>\n</tr>\n<tr>\n<td>:last-child</td>\n<td>p:last-child</td>\n<td>选择属于其父元素最后一个子元素每个元素。</td>\n</tr>\n<tr>\n<td>:first-of-type</td>\n<td>p:first-of-type</td>\n<td>选择属于其父元素的首个元素的每个元素</td>\n</tr>\n<tr>\n<td>:last-of-type</td>\n<td>p:last-of-type</td>\n<td>选择属于其父元素的最后元素的每个元素。</td>\n</tr>\n<tr>\n<td>:only-of-type</td>\n<td>p:only-of-type</td>\n<td>选择属于其父元素唯一的元素的每个元素。</td>\n</tr>\n<tr>\n<td>:only-child</td>\n<td>p:only-child</td>\n<td>选择属于其父元素的唯一子元素的每个元素。</td>\n</tr>\n<tr>\n<td>:nth-child(n)</td>\n<td>p:nth-child(2)</td>\n<td>选择属于其父元素的第二个子元素的每个元素。</td>\n</tr>\n<tr>\n<td>:nth-child(odd)</td>\n<td>p:nth-child(odd)</td>\n<td>选择属于其父元素的奇数元素。</td>\n</tr>\n<tr>\n<td>:nth-child(even)</td>\n<td>p:nth-child(even)</td>\n<td>选择属于其父元素的偶数元素。</td>\n</tr>\n<tr>\n<td>:nth-of-type(n)</td>\n<td>p:nth-of-type(2)</td>\n<td>选择属于其父元素第二个元素的每个元素。</td>\n</tr>\n<tr>\n<td>:nth-last-child(n)</td>\n<td>p:nth-last-child(2)</td>\n<td>同上，从最后一个子元素开始计数。</td>\n</tr>\n<tr>\n<td>:nth-last-of-type(n)</td>\n<td>p:nth-last-of-type(2)</td>\n<td>同上，但是从最后一个子元素开始计数。</td>\n</tr>\n<tr>\n<td>:not(selector)</td>\n<td>:not(p)</td>\n<td>选择非元素的每个元素</td>\n</tr>\n</tbody></table>\n<p>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说：伪类和伪元素是用来修饰不在文档树中的部分。</p>\n<p>伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的。例如：当用户悬停在指定元素时，可以通过:hover来描述这个元素的状态，虽然它和一般css相似，可以为已有元素添加样式，但是它只有处于DOM树无法描述的状态下才能为元素添加样式，所以称为伪类。</p>\n<p>伪元素：用于创建一些不在DOM树中的元素，并为其添加样式。例如，我们可以通过:before来在一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看见这些文本，但是它实际上并不在DOM文档中。</p>\n<p><strong>css3规范中要求使用双冒号（::）表示伪元素，以此来区分伪类和伪元素</strong>，比如::before和::after等伪元素使用双冒号（::），:hover和:active伪类使用单冒号（:）。</p>\n<h2 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h2><h2 id=\"浮动布局\"><a href=\"#浮动布局\" class=\"headerlink\" title=\"浮动布局\"></a>浮动布局</h2><h2 id=\"定位布局\"><a href=\"#定位布局\" class=\"headerlink\" title=\"定位布局\"></a>定位布局</h2><h2 id=\"弹性布局\"><a href=\"#弹性布局\" class=\"headerlink\" title=\"弹性布局\"></a>弹性布局</h2><h2 id=\"栅格系统\"><a href=\"#栅格系统\" class=\"headerlink\" title=\"栅格系统\"></a>栅格系统</h2>"},{"title":"31天JavaScript学习-第22天","reprint":false,"date":"2022-03-26T07:56:07.000Z","updated":"2022-03-26T07:56:07.000Z","conver":null,"_content":"\n# 模块化（一）：CommonJS\n\n<!--more-->\n\n## 模块化规范\n\n- **服务器端规范：**CommonJS，Node.js使用的模块化规范\n- **浏览器端规范：**\n  - AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。\n  - CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。\n\n## CommonJS基本语法\n\nCommonJS规定：每个文件都可以当作一个模块，每个模块内部内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口对象。加载某个模块，其实是加载该模块的module.exports对象。\n\n在服务器端，模块的加载时运行时同步加载的；在浏览器端，模块需要提前编译打包。\n\n### 模块的暴露与引入\n\nNode.js中，每个模块都有一个exports接口对象，我们可以把公共的变量、方法挂载到这个接口对象中，其他模块通过引入该接口对象以实现引入。\n\n**暴露模块方式一：exports**\n\nexports对象用来导出当前模块的公共方法或属性。其他模块通过require函数调用时，得到的就是当前模块的exports对象。\n\n> 注意关键字是`exports`，并非ES6中的`export/import`导出导入模块规范。\n\n```js\nconst name = 'zrtty';\nconst foo = function (value) {\n  return value * 2;\n};\n\nexports.name = name;\nexports.foo = foo;\n```\n\n**注意：**导出模块时优先使用module.exports。因为Node为每个模块提供一个exports变量，该变量指向module.exports。等同于每个模块头部有一句`const exports = module.exports;`。\n\n**暴露模块方式二：module.exports**\n\nmodule.exports用来导出一个默认对象，没有指定对象名。\n\n```js\nconst name = 'zrtty';\nconst foo = function (value) {\n  return value * 2;\n};\n\nmodule.exports = name;\nmodule.exports.foo = foo;\n```\n\n**注：**Node中每个模块的最后，都会执行`return module.exports`\n\n**引入模块：require**\n\nrequire用来在一个模块中引入另外一个模块。传入模块名，返回模块导出的对象。\n\n```js\nconst module1 = require('module name');\n```\n\n其中引入的模块名的写法：\n\n- 内置模块则引入**包名**\n- 下载的第三方模块则引入**包名**\n- 自定义模块则引入**文件路径**，后缀.js可以省略\n\n**注：**一个模块中的JS代码仅在模块第一次使用时执行一次，并在使用过程中初始化，然后被缓存起来，便于后续继续使用。\n\n```js\n// array.js\nvar a = 1;\n\nfunction add() {\n  return ++a;\n}\n\nexports.add = add;\n```\n\n```js\n// main.js\nconst myModule1 = require('./array');\nconst myModule2 = require('./array');\n\nconsole.log(myModule1.add()); // 2\nconsole.log(myModule2.add()); // 3\n```\n\n可以看到，array.js被引用两次，但只初始化了一次。\n\n","source":"_posts/31天JavaScript学习-第22天.md","raw":"---\ntitle: 31天JavaScript学习-第22天\nreprint: false\ndate: 2022-03-26 15:56:07\nupdated: 2022-03-26 15:56:07\nconver:\ncategories: 前端\ntags:\n  - nodejs\n---\n\n# 模块化（一）：CommonJS\n\n<!--more-->\n\n## 模块化规范\n\n- **服务器端规范：**CommonJS，Node.js使用的模块化规范\n- **浏览器端规范：**\n  - AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。\n  - CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。\n\n## CommonJS基本语法\n\nCommonJS规定：每个文件都可以当作一个模块，每个模块内部内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口对象。加载某个模块，其实是加载该模块的module.exports对象。\n\n在服务器端，模块的加载时运行时同步加载的；在浏览器端，模块需要提前编译打包。\n\n### 模块的暴露与引入\n\nNode.js中，每个模块都有一个exports接口对象，我们可以把公共的变量、方法挂载到这个接口对象中，其他模块通过引入该接口对象以实现引入。\n\n**暴露模块方式一：exports**\n\nexports对象用来导出当前模块的公共方法或属性。其他模块通过require函数调用时，得到的就是当前模块的exports对象。\n\n> 注意关键字是`exports`，并非ES6中的`export/import`导出导入模块规范。\n\n```js\nconst name = 'zrtty';\nconst foo = function (value) {\n  return value * 2;\n};\n\nexports.name = name;\nexports.foo = foo;\n```\n\n**注意：**导出模块时优先使用module.exports。因为Node为每个模块提供一个exports变量，该变量指向module.exports。等同于每个模块头部有一句`const exports = module.exports;`。\n\n**暴露模块方式二：module.exports**\n\nmodule.exports用来导出一个默认对象，没有指定对象名。\n\n```js\nconst name = 'zrtty';\nconst foo = function (value) {\n  return value * 2;\n};\n\nmodule.exports = name;\nmodule.exports.foo = foo;\n```\n\n**注：**Node中每个模块的最后，都会执行`return module.exports`\n\n**引入模块：require**\n\nrequire用来在一个模块中引入另外一个模块。传入模块名，返回模块导出的对象。\n\n```js\nconst module1 = require('module name');\n```\n\n其中引入的模块名的写法：\n\n- 内置模块则引入**包名**\n- 下载的第三方模块则引入**包名**\n- 自定义模块则引入**文件路径**，后缀.js可以省略\n\n**注：**一个模块中的JS代码仅在模块第一次使用时执行一次，并在使用过程中初始化，然后被缓存起来，便于后续继续使用。\n\n```js\n// array.js\nvar a = 1;\n\nfunction add() {\n  return ++a;\n}\n\nexports.add = add;\n```\n\n```js\n// main.js\nconst myModule1 = require('./array');\nconst myModule2 = require('./array');\n\nconsole.log(myModule1.add()); // 2\nconsole.log(myModule2.add()); // 3\n```\n\n可以看到，array.js被引用两次，但只初始化了一次。\n\n","slug":"31天JavaScript学习-第22天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a6000w7owzd2qobqyx","content":"<h1 id=\"模块化（一）：CommonJS\"><a href=\"#模块化（一）：CommonJS\" class=\"headerlink\" title=\"模块化（一）：CommonJS\"></a>模块化（一）：CommonJS</h1><span id=\"more\"></span>\n\n<h2 id=\"模块化规范\"><a href=\"#模块化规范\" class=\"headerlink\" title=\"模块化规范\"></a>模块化规范</h2><ul>\n<li><strong>服务器端规范：</strong>CommonJS，Node.js使用的模块化规范</li>\n<li><strong>浏览器端规范：</strong><ul>\n<li>AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。</li>\n<li>CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CommonJS基本语法\"><a href=\"#CommonJS基本语法\" class=\"headerlink\" title=\"CommonJS基本语法\"></a>CommonJS基本语法</h2><p>CommonJS规定：每个文件都可以当作一个模块，每个模块内部内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口对象。加载某个模块，其实是加载该模块的module.exports对象。</p>\n<p>在服务器端，模块的加载时运行时同步加载的；在浏览器端，模块需要提前编译打包。</p>\n<h3 id=\"模块的暴露与引入\"><a href=\"#模块的暴露与引入\" class=\"headerlink\" title=\"模块的暴露与引入\"></a>模块的暴露与引入</h3><p>Node.js中，每个模块都有一个exports接口对象，我们可以把公共的变量、方法挂载到这个接口对象中，其他模块通过引入该接口对象以实现引入。</p>\n<p><strong>暴露模块方式一：exports</strong></p>\n<p>exports对象用来导出当前模块的公共方法或属性。其他模块通过require函数调用时，得到的就是当前模块的exports对象。</p>\n<blockquote>\n<p>注意关键字是<code>exports</code>，并非ES6中的<code>export/import</code>导出导入模块规范。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;zrtty&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exports</span>.name = name;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.foo = foo;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>导出模块时优先使用module.exports。因为Node为每个模块提供一个exports变量，该变量指向module.exports。等同于每个模块头部有一句<code>const exports = module.exports;</code>。</p>\n<p><strong>暴露模块方式二：module.exports</strong></p>\n<p>module.exports用来导出一个默认对象，没有指定对象名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;zrtty&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = name;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.foo = foo;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：</strong>Node中每个模块的最后，都会执行<code>return module.exports</code></p>\n<p><strong>引入模块：require</strong></p>\n<p>require用来在一个模块中引入另外一个模块。传入模块名，返回模块导出的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> module1 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;module name&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>其中引入的模块名的写法：</p>\n<ul>\n<li>内置模块则引入<strong>包名</strong></li>\n<li>下载的第三方模块则引入<strong>包名</strong></li>\n<li>自定义模块则引入<strong>文件路径</strong>，后缀.js可以省略</li>\n</ul>\n<p><strong>注：</strong>一个模块中的JS代码仅在模块第一次使用时执行一次，并在使用过程中初始化，然后被缓存起来，便于后续继续使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// array.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exports</span>.add = add;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myModule1 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./array&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> myModule2 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./array&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myModule1.add()); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myModule2.add()); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，array.js被引用两次，但只初始化了一次。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"模块化（一）：CommonJS\"><a href=\"#模块化（一）：CommonJS\" class=\"headerlink\" title=\"模块化（一）：CommonJS\"></a>模块化（一）：CommonJS</h1>","more":"<h2 id=\"模块化规范\"><a href=\"#模块化规范\" class=\"headerlink\" title=\"模块化规范\"></a>模块化规范</h2><ul>\n<li><strong>服务器端规范：</strong>CommonJS，Node.js使用的模块化规范</li>\n<li><strong>浏览器端规范：</strong><ul>\n<li>AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。</li>\n<li>CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CommonJS基本语法\"><a href=\"#CommonJS基本语法\" class=\"headerlink\" title=\"CommonJS基本语法\"></a>CommonJS基本语法</h2><p>CommonJS规定：每个文件都可以当作一个模块，每个模块内部内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口对象。加载某个模块，其实是加载该模块的module.exports对象。</p>\n<p>在服务器端，模块的加载时运行时同步加载的；在浏览器端，模块需要提前编译打包。</p>\n<h3 id=\"模块的暴露与引入\"><a href=\"#模块的暴露与引入\" class=\"headerlink\" title=\"模块的暴露与引入\"></a>模块的暴露与引入</h3><p>Node.js中，每个模块都有一个exports接口对象，我们可以把公共的变量、方法挂载到这个接口对象中，其他模块通过引入该接口对象以实现引入。</p>\n<p><strong>暴露模块方式一：exports</strong></p>\n<p>exports对象用来导出当前模块的公共方法或属性。其他模块通过require函数调用时，得到的就是当前模块的exports对象。</p>\n<blockquote>\n<p>注意关键字是<code>exports</code>，并非ES6中的<code>export/import</code>导出导入模块规范。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;zrtty&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exports</span>.name = name;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.foo = foo;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>导出模块时优先使用module.exports。因为Node为每个模块提供一个exports变量，该变量指向module.exports。等同于每个模块头部有一句<code>const exports = module.exports;</code>。</p>\n<p><strong>暴露模块方式二：module.exports</strong></p>\n<p>module.exports用来导出一个默认对象，没有指定对象名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;zrtty&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = name;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.foo = foo;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：</strong>Node中每个模块的最后，都会执行<code>return module.exports</code></p>\n<p><strong>引入模块：require</strong></p>\n<p>require用来在一个模块中引入另外一个模块。传入模块名，返回模块导出的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> module1 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;module name&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>其中引入的模块名的写法：</p>\n<ul>\n<li>内置模块则引入<strong>包名</strong></li>\n<li>下载的第三方模块则引入<strong>包名</strong></li>\n<li>自定义模块则引入<strong>文件路径</strong>，后缀.js可以省略</li>\n</ul>\n<p><strong>注：</strong>一个模块中的JS代码仅在模块第一次使用时执行一次，并在使用过程中初始化，然后被缓存起来，便于后续继续使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// array.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ++a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exports</span>.add = add;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myModule1 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./array&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> myModule2 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./array&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myModule1.add()); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myModule2.add()); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，array.js被引用两次，但只初始化了一次。</p>"},{"title":"31天JavaScript学习-第4天","reprint":false,"date":"2022-02-23T02:28:39.000Z","updated":"2022-02-23T02:28:39.000Z","conver":null,"_content":"\n# 内置引用类型（二）——Function、RegExp\n\n<!--more-->\n\n## Function\n\n函数的特点：\n\n- 函数是一个对象，每个函数都是Function类型的实例\n- 函数名是一个指向函数对象的指针\n\n### 函数的定义/声明\n\n**方式一：函数关键字**\n\n```js\nfunction sum (a, b) {\n\treturn a + b;\n}\n```\n\n在使用函数关键字进行函数声明时，会有**函数声明提升**的过程。\n\n**方式二：函数表达式（匿名函数）**\n\n```js\nvar sum = function(a, b) {\n\treturn a + b;\n};\n```\n\n**方式三：构造函数**\n\n```js\nvar sum = new Function('a', 'b', 'return a + b;');\n```\n\n注意，Function里的参数都必须是**字符串**形式。\n\n### 函数内部属性\n\n#### 内部对象\n\n函数内部有两个特殊的对象：**arguments**和**this**。\n\n##### arguments\n\narguments是一个类数组对象（伪数组），包含传入函数中的所有参数，可以通过索引来操作数据，也可以获取长度。**arguments代表的是实参，arguments只在函数中使用。**\n\n**1、arguments.length**\n\narguments.length可以用来获取**实参的长度**。\n\n**2、arguments.callee**\n\narguments有一个名为callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。\n\n在使用函数**递归**调用时，推荐使用 arguments.callee 代替函数名本身。如阶乘函数：\n\n```js\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * factorial(num - 1);\n  }\n}\n```\n\n该函数的执行与函数名factorial紧紧耦合在了一起，为了消除耦合可以使用下面的写法：\n\n```js\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * arguments.callee(num - 1);\n  }\n}\n```\n\n##### this\n\n根据函数的调用方式的不同，this 会指向不同的对象：\n\n- 以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window。比如`fun();`相当于`window.fun();`\n- 以方法的形式调用时，this 指向调用方法的那个对象\n- 以构造函数的形式调用时，this 指向实例对象\n- 以事件绑定函数的形式调用时，this 指向**绑定事件的对象**\n- 使用 call 和 apply 调用时，this 指向指定的那个对象\n\nES6的箭头函数并不遵守上面的准则，而是会继承外层函数调用的this绑定。\n\nJS专门提供了一些方法来改变函数内部的this指向，`call()、apply()、bind()`。\n\n#### 内部属性\n\n##### caller\n\ncaller保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，则它的值为null。\n\n### 函数的属性和方法\n\nES中的函数时对象，因此函数也有属性和方法。\n\n- 属性：length、prototype\n- 方法：apply()、call()、bind()\n\n#### 属性\n\n##### length\n\nlength属性表示函数希望接收的命名参数的个数。\n\n##### prototype\n\n对于ES的引用类型，prototype是保存它们所有实例方法的真正所在。诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。详细见。\n\n#### 方法\n\n##### call()方法\n\n可以调用一个函数，实际上等于设置函数体内this对象的值。\n\n`fn1.call(this指向的作用域, 函数实参1, 函数实参2……);`\n\n第一个参数中，如果不需要改变 this 指向，则传 null。\n\ncall() 方法的另一个应用：**可以实现继承**。之所以能实现继承，其实是利用了上面的作用。\n\n```js\nfunction Father(myName, myAge) {\n  this.name = myName;\n  this.age = myAge;\n}\n\nfunction Son(myName, myAge) {\n    // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 \tSon 自动拥有 Father 里的属性。最终实现继承\n  Father.call(this, myName, myAge);\n}\n\nconst son1 = new Son('jack', 16);\nconsole.log(JSON.stringify(son1)); // {\"name\":\"jack\",\"age\":16}\n```\n\n##### apply()方法\n\n可以调用一个函数，实际上等于设置函数体内this对象的值。\n\napply()接收两个参数：\n\n`fn1.apply(this指向的作用域, [参数数组]);`\n\n其中第二个参数可以是Array的实例，也可以是arguments对象。\n\n**apply() 方法的巧妙应用：求数组的最大值**\n\n我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？\n\n虽然数组里没有获取最大值的方法，但是数值里面有 `Math.max(数字1，数字2，数字3)` 方法，可以获取**多个数值中的最大值**。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。\n\n```js\nconst arr1 = [3, 7, 10, 8];\n\n// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。\nconst maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值\nconsole.log(maxValue);\n\nconst minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值\nconsole.log(minValue);\n```\n\n##### bind()方法\n\nbind()会创建一个函数的实例，其this值会被绑定到传给bind()函数的值，\n\n`new_func = fn1.bind(this指向的作用域, 函数实参1, 函数实参2……);`\n\n如：\n\n```js\nwindow.color = 'red';\nvar o = { color: 'blue' };\n\nfunction sayColor(){\n  console.log(this.color);\n}\n\nvar objectSayColor = sayColor.bind(o);\nobjectSayColor(); // blue\n```\n\n## RegExp\n\nES通过RegExp类型来支持正则表达式。\n\n`var expression = / pattern / flags;`\n\n其中模式（pattern）可以是任意正则表达式。每个正则表达式都可以带有一个或多个标志（flags），匹配模式支持下列三种模式：\n\n- **g：**全局（global）模式。模式应用于所有字符串，发现第一个匹配项停止。\n- **i：**不区分大小写。\n- **m：**多行模式，到达一行文本末尾还会继续查找下一行。\n\n### 实例属性\n\nRegExp的每个实例都具有下列属性。\n\n| 属性       | 数据类型 | 解释                                    |\n| ---------- | -------- | --------------------------------------- |\n| global     | boolean  | 是否设置g标志                           |\n| ignoreCase | boolean  | 是否设置i标志                           |\n| lastIndex  | 整数     | 开始搜索下一个匹配项的字符位置，从0开始 |\n| multiline  | boolean  | 是否设置m标志                           |\n| source     | String   | 正则表达式的字符串形式                  |\n","source":"_posts/31天JavaScript学习-第4天.md","raw":"---\ntitle: 31天JavaScript学习-第4天\nreprint: false\ndate: 2022-02-23 10:28:39\nupdated: 2022-02-23 10:28:39\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# 内置引用类型（二）——Function、RegExp\n\n<!--more-->\n\n## Function\n\n函数的特点：\n\n- 函数是一个对象，每个函数都是Function类型的实例\n- 函数名是一个指向函数对象的指针\n\n### 函数的定义/声明\n\n**方式一：函数关键字**\n\n```js\nfunction sum (a, b) {\n\treturn a + b;\n}\n```\n\n在使用函数关键字进行函数声明时，会有**函数声明提升**的过程。\n\n**方式二：函数表达式（匿名函数）**\n\n```js\nvar sum = function(a, b) {\n\treturn a + b;\n};\n```\n\n**方式三：构造函数**\n\n```js\nvar sum = new Function('a', 'b', 'return a + b;');\n```\n\n注意，Function里的参数都必须是**字符串**形式。\n\n### 函数内部属性\n\n#### 内部对象\n\n函数内部有两个特殊的对象：**arguments**和**this**。\n\n##### arguments\n\narguments是一个类数组对象（伪数组），包含传入函数中的所有参数，可以通过索引来操作数据，也可以获取长度。**arguments代表的是实参，arguments只在函数中使用。**\n\n**1、arguments.length**\n\narguments.length可以用来获取**实参的长度**。\n\n**2、arguments.callee**\n\narguments有一个名为callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。\n\n在使用函数**递归**调用时，推荐使用 arguments.callee 代替函数名本身。如阶乘函数：\n\n```js\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * factorial(num - 1);\n  }\n}\n```\n\n该函数的执行与函数名factorial紧紧耦合在了一起，为了消除耦合可以使用下面的写法：\n\n```js\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    return num * arguments.callee(num - 1);\n  }\n}\n```\n\n##### this\n\n根据函数的调用方式的不同，this 会指向不同的对象：\n\n- 以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window。比如`fun();`相当于`window.fun();`\n- 以方法的形式调用时，this 指向调用方法的那个对象\n- 以构造函数的形式调用时，this 指向实例对象\n- 以事件绑定函数的形式调用时，this 指向**绑定事件的对象**\n- 使用 call 和 apply 调用时，this 指向指定的那个对象\n\nES6的箭头函数并不遵守上面的准则，而是会继承外层函数调用的this绑定。\n\nJS专门提供了一些方法来改变函数内部的this指向，`call()、apply()、bind()`。\n\n#### 内部属性\n\n##### caller\n\ncaller保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，则它的值为null。\n\n### 函数的属性和方法\n\nES中的函数时对象，因此函数也有属性和方法。\n\n- 属性：length、prototype\n- 方法：apply()、call()、bind()\n\n#### 属性\n\n##### length\n\nlength属性表示函数希望接收的命名参数的个数。\n\n##### prototype\n\n对于ES的引用类型，prototype是保存它们所有实例方法的真正所在。诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。详细见。\n\n#### 方法\n\n##### call()方法\n\n可以调用一个函数，实际上等于设置函数体内this对象的值。\n\n`fn1.call(this指向的作用域, 函数实参1, 函数实参2……);`\n\n第一个参数中，如果不需要改变 this 指向，则传 null。\n\ncall() 方法的另一个应用：**可以实现继承**。之所以能实现继承，其实是利用了上面的作用。\n\n```js\nfunction Father(myName, myAge) {\n  this.name = myName;\n  this.age = myAge;\n}\n\nfunction Son(myName, myAge) {\n    // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 \tSon 自动拥有 Father 里的属性。最终实现继承\n  Father.call(this, myName, myAge);\n}\n\nconst son1 = new Son('jack', 16);\nconsole.log(JSON.stringify(son1)); // {\"name\":\"jack\",\"age\":16}\n```\n\n##### apply()方法\n\n可以调用一个函数，实际上等于设置函数体内this对象的值。\n\napply()接收两个参数：\n\n`fn1.apply(this指向的作用域, [参数数组]);`\n\n其中第二个参数可以是Array的实例，也可以是arguments对象。\n\n**apply() 方法的巧妙应用：求数组的最大值**\n\n我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？\n\n虽然数组里没有获取最大值的方法，但是数值里面有 `Math.max(数字1，数字2，数字3)` 方法，可以获取**多个数值中的最大值**。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。\n\n```js\nconst arr1 = [3, 7, 10, 8];\n\n// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。\nconst maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值\nconsole.log(maxValue);\n\nconst minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值\nconsole.log(minValue);\n```\n\n##### bind()方法\n\nbind()会创建一个函数的实例，其this值会被绑定到传给bind()函数的值，\n\n`new_func = fn1.bind(this指向的作用域, 函数实参1, 函数实参2……);`\n\n如：\n\n```js\nwindow.color = 'red';\nvar o = { color: 'blue' };\n\nfunction sayColor(){\n  console.log(this.color);\n}\n\nvar objectSayColor = sayColor.bind(o);\nobjectSayColor(); // blue\n```\n\n## RegExp\n\nES通过RegExp类型来支持正则表达式。\n\n`var expression = / pattern / flags;`\n\n其中模式（pattern）可以是任意正则表达式。每个正则表达式都可以带有一个或多个标志（flags），匹配模式支持下列三种模式：\n\n- **g：**全局（global）模式。模式应用于所有字符串，发现第一个匹配项停止。\n- **i：**不区分大小写。\n- **m：**多行模式，到达一行文本末尾还会继续查找下一行。\n\n### 实例属性\n\nRegExp的每个实例都具有下列属性。\n\n| 属性       | 数据类型 | 解释                                    |\n| ---------- | -------- | --------------------------------------- |\n| global     | boolean  | 是否设置g标志                           |\n| ignoreCase | boolean  | 是否设置i标志                           |\n| lastIndex  | 整数     | 开始搜索下一个匹配项的字符位置，从0开始 |\n| multiline  | boolean  | 是否设置m标志                           |\n| source     | String   | 正则表达式的字符串形式                  |\n","slug":"31天JavaScript学习-第4天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a700107owz1kwnb20a","content":"<h1 id=\"内置引用类型（二）——Function、RegExp\"><a href=\"#内置引用类型（二）——Function、RegExp\" class=\"headerlink\" title=\"内置引用类型（二）——Function、RegExp\"></a>内置引用类型（二）——Function、RegExp</h1><span id=\"more\"></span>\n\n<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><p>函数的特点：</p>\n<ul>\n<li>函数是一个对象，每个函数都是Function类型的实例</li>\n<li>函数名是一个指向函数对象的指针</li>\n</ul>\n<h3 id=\"函数的定义-声明\"><a href=\"#函数的定义-声明\" class=\"headerlink\" title=\"函数的定义/声明\"></a>函数的定义/声明</h3><p><strong>方式一：函数关键字</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在使用函数关键字进行函数声明时，会有<strong>函数声明提升</strong>的过程。</p>\n<p><strong>方式二：函数表达式（匿名函数）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>方式三：构造函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;return a + b;&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意，Function里的参数都必须是<strong>字符串</strong>形式。</p>\n<h3 id=\"函数内部属性\"><a href=\"#函数内部属性\" class=\"headerlink\" title=\"函数内部属性\"></a>函数内部属性</h3><h4 id=\"内部对象\"><a href=\"#内部对象\" class=\"headerlink\" title=\"内部对象\"></a>内部对象</h4><p>函数内部有两个特殊的对象：<strong>arguments</strong>和<strong>this</strong>。</p>\n<h5 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h5><p>arguments是一个类数组对象（伪数组），包含传入函数中的所有参数，可以通过索引来操作数据，也可以获取长度。<strong>arguments代表的是实参，arguments只在函数中使用。</strong></p>\n<p><strong>1、arguments.length</strong></p>\n<p>arguments.length可以用来获取<strong>实参的长度</strong>。</p>\n<p><strong>2、arguments.callee</strong></p>\n<p>arguments有一个名为callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p>\n<p>在使用函数<strong>递归</strong>调用时，推荐使用 arguments.callee 代替函数名本身。如阶乘函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * factorial(num - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该函数的执行与函数名factorial紧紧耦合在了一起，为了消除耦合可以使用下面的写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * <span class=\"built_in\">arguments</span>.callee(num - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h5><p>根据函数的调用方式的不同，this 会指向不同的对象：</p>\n<ul>\n<li>以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window。比如<code>fun();</code>相当于<code>window.fun();</code></li>\n<li>以方法的形式调用时，this 指向调用方法的那个对象</li>\n<li>以构造函数的形式调用时，this 指向实例对象</li>\n<li>以事件绑定函数的形式调用时，this 指向<strong>绑定事件的对象</strong></li>\n<li>使用 call 和 apply 调用时，this 指向指定的那个对象</li>\n</ul>\n<p>ES6的箭头函数并不遵守上面的准则，而是会继承外层函数调用的this绑定。</p>\n<p>JS专门提供了一些方法来改变函数内部的this指向，<code>call()、apply()、bind()</code>。</p>\n<h4 id=\"内部属性\"><a href=\"#内部属性\" class=\"headerlink\" title=\"内部属性\"></a>内部属性</h4><h5 id=\"caller\"><a href=\"#caller\" class=\"headerlink\" title=\"caller\"></a>caller</h5><p>caller保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，则它的值为null。</p>\n<h3 id=\"函数的属性和方法\"><a href=\"#函数的属性和方法\" class=\"headerlink\" title=\"函数的属性和方法\"></a>函数的属性和方法</h3><p>ES中的函数时对象，因此函数也有属性和方法。</p>\n<ul>\n<li>属性：length、prototype</li>\n<li>方法：apply()、call()、bind()</li>\n</ul>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><h5 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length\"></a>length</h5><p>length属性表示函数希望接收的命名参数的个数。</p>\n<h5 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h5><p>对于ES的引用类型，prototype是保存它们所有实例方法的真正所在。诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。详细见。</p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"call-方法\"><a href=\"#call-方法\" class=\"headerlink\" title=\"call()方法\"></a>call()方法</h5><p>可以调用一个函数，实际上等于设置函数体内this对象的值。</p>\n<p><code>fn1.call(this指向的作用域, 函数实参1, 函数实参2……);</code></p>\n<p>第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<p>call() 方法的另一个应用：<strong>可以实现继承</strong>。之所以能实现继承，其实是利用了上面的作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\">myName, myAge</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = myName;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = myAge;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\">myName, myAge</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 \tSon 自动拥有 Father 里的属性。最终实现继承</span></span><br><span class=\"line\">  Father.call(<span class=\"built_in\">this</span>, myName, myAge);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(son1)); <span class=\"comment\">// &#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:16&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"apply-方法\"><a href=\"#apply-方法\" class=\"headerlink\" title=\"apply()方法\"></a>apply()方法</h5><p>可以调用一个函数，实际上等于设置函数体内this对象的值。</p>\n<p>apply()接收两个参数：</p>\n<p><code>fn1.apply(this指向的作用域, [参数数组]);</code></p>\n<p>其中第二个参数可以是Array的实例，也可以是arguments对象。</p>\n<p><strong>apply() 方法的巧妙应用：求数组的最大值</strong></p>\n<p>我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？</p>\n<p>虽然数组里没有获取最大值的方法，但是数值里面有 <code>Math.max(数字1，数字2，数字3)</code> 方法，可以获取<strong>多个数值中的最大值</strong>。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxValue = <span class=\"built_in\">Math</span>.max.apply(<span class=\"built_in\">Math</span>, arr1); <span class=\"comment\">// 求数组 arr1 中元素的最大值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(maxValue);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minValue = <span class=\"built_in\">Math</span>.min.apply(<span class=\"built_in\">Math</span>, arr1); <span class=\"comment\">// 求数组 arr1 中元素的最小值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(minValue);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind()方法\"></a>bind()方法</h5><p>bind()会创建一个函数的实例，其this值会被绑定到传给bind()函数的值，</p>\n<p><code>new_func = fn1.bind(this指向的作用域, 函数实参1, 函数实参2……);</code></p>\n<p>如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.color = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">color</span>: <span class=\"string\">&#x27;blue&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> objectSayColor = sayColor.bind(o);</span><br><span class=\"line\">objectSayColor(); <span class=\"comment\">// blue</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RegExp\"><a href=\"#RegExp\" class=\"headerlink\" title=\"RegExp\"></a>RegExp</h2><p>ES通过RegExp类型来支持正则表达式。</p>\n<p><code>var expression = / pattern / flags;</code></p>\n<p>其中模式（pattern）可以是任意正则表达式。每个正则表达式都可以带有一个或多个标志（flags），匹配模式支持下列三种模式：</p>\n<ul>\n<li><strong>g：</strong>全局（global）模式。模式应用于所有字符串，发现第一个匹配项停止。</li>\n<li><strong>i：</strong>不区分大小写。</li>\n<li><strong>m：</strong>多行模式，到达一行文本末尾还会继续查找下一行。</li>\n</ul>\n<h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><p>RegExp的每个实例都具有下列属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>数据类型</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>global</td>\n<td>boolean</td>\n<td>是否设置g标志</td>\n</tr>\n<tr>\n<td>ignoreCase</td>\n<td>boolean</td>\n<td>是否设置i标志</td>\n</tr>\n<tr>\n<td>lastIndex</td>\n<td>整数</td>\n<td>开始搜索下一个匹配项的字符位置，从0开始</td>\n</tr>\n<tr>\n<td>multiline</td>\n<td>boolean</td>\n<td>是否设置m标志</td>\n</tr>\n<tr>\n<td>source</td>\n<td>String</td>\n<td>正则表达式的字符串形式</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<h1 id=\"内置引用类型（二）——Function、RegExp\"><a href=\"#内置引用类型（二）——Function、RegExp\" class=\"headerlink\" title=\"内置引用类型（二）——Function、RegExp\"></a>内置引用类型（二）——Function、RegExp</h1>","more":"<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><p>函数的特点：</p>\n<ul>\n<li>函数是一个对象，每个函数都是Function类型的实例</li>\n<li>函数名是一个指向函数对象的指针</li>\n</ul>\n<h3 id=\"函数的定义-声明\"><a href=\"#函数的定义-声明\" class=\"headerlink\" title=\"函数的定义/声明\"></a>函数的定义/声明</h3><p><strong>方式一：函数关键字</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在使用函数关键字进行函数声明时，会有<strong>函数声明提升</strong>的过程。</p>\n<p><strong>方式二：函数表达式（匿名函数）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>方式三：构造函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;return a + b;&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意，Function里的参数都必须是<strong>字符串</strong>形式。</p>\n<h3 id=\"函数内部属性\"><a href=\"#函数内部属性\" class=\"headerlink\" title=\"函数内部属性\"></a>函数内部属性</h3><h4 id=\"内部对象\"><a href=\"#内部对象\" class=\"headerlink\" title=\"内部对象\"></a>内部对象</h4><p>函数内部有两个特殊的对象：<strong>arguments</strong>和<strong>this</strong>。</p>\n<h5 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h5><p>arguments是一个类数组对象（伪数组），包含传入函数中的所有参数，可以通过索引来操作数据，也可以获取长度。<strong>arguments代表的是实参，arguments只在函数中使用。</strong></p>\n<p><strong>1、arguments.length</strong></p>\n<p>arguments.length可以用来获取<strong>实参的长度</strong>。</p>\n<p><strong>2、arguments.callee</strong></p>\n<p>arguments有一个名为callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p>\n<p>在使用函数<strong>递归</strong>调用时，推荐使用 arguments.callee 代替函数名本身。如阶乘函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * factorial(num - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该函数的执行与函数名factorial紧紧耦合在了一起，为了消除耦合可以使用下面的写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * <span class=\"built_in\">arguments</span>.callee(num - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h5><p>根据函数的调用方式的不同，this 会指向不同的对象：</p>\n<ul>\n<li>以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window。比如<code>fun();</code>相当于<code>window.fun();</code></li>\n<li>以方法的形式调用时，this 指向调用方法的那个对象</li>\n<li>以构造函数的形式调用时，this 指向实例对象</li>\n<li>以事件绑定函数的形式调用时，this 指向<strong>绑定事件的对象</strong></li>\n<li>使用 call 和 apply 调用时，this 指向指定的那个对象</li>\n</ul>\n<p>ES6的箭头函数并不遵守上面的准则，而是会继承外层函数调用的this绑定。</p>\n<p>JS专门提供了一些方法来改变函数内部的this指向，<code>call()、apply()、bind()</code>。</p>\n<h4 id=\"内部属性\"><a href=\"#内部属性\" class=\"headerlink\" title=\"内部属性\"></a>内部属性</h4><h5 id=\"caller\"><a href=\"#caller\" class=\"headerlink\" title=\"caller\"></a>caller</h5><p>caller保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，则它的值为null。</p>\n<h3 id=\"函数的属性和方法\"><a href=\"#函数的属性和方法\" class=\"headerlink\" title=\"函数的属性和方法\"></a>函数的属性和方法</h3><p>ES中的函数时对象，因此函数也有属性和方法。</p>\n<ul>\n<li>属性：length、prototype</li>\n<li>方法：apply()、call()、bind()</li>\n</ul>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><h5 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length\"></a>length</h5><p>length属性表示函数希望接收的命名参数的个数。</p>\n<h5 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h5><p>对于ES的引用类型，prototype是保存它们所有实例方法的真正所在。诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。详细见。</p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><h5 id=\"call-方法\"><a href=\"#call-方法\" class=\"headerlink\" title=\"call()方法\"></a>call()方法</h5><p>可以调用一个函数，实际上等于设置函数体内this对象的值。</p>\n<p><code>fn1.call(this指向的作用域, 函数实参1, 函数实参2……);</code></p>\n<p>第一个参数中，如果不需要改变 this 指向，则传 null。</p>\n<p>call() 方法的另一个应用：<strong>可以实现继承</strong>。之所以能实现继承，其实是利用了上面的作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\">myName, myAge</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = myName;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = myAge;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\">myName, myAge</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 \tSon 自动拥有 Father 里的属性。最终实现继承</span></span><br><span class=\"line\">  Father.call(<span class=\"built_in\">this</span>, myName, myAge);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> son1 = <span class=\"keyword\">new</span> Son(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(son1)); <span class=\"comment\">// &#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:16&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"apply-方法\"><a href=\"#apply-方法\" class=\"headerlink\" title=\"apply()方法\"></a>apply()方法</h5><p>可以调用一个函数，实际上等于设置函数体内this对象的值。</p>\n<p>apply()接收两个参数：</p>\n<p><code>fn1.apply(this指向的作用域, [参数数组]);</code></p>\n<p>其中第二个参数可以是Array的实例，也可以是arguments对象。</p>\n<p><strong>apply() 方法的巧妙应用：求数组的最大值</strong></p>\n<p>我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？</p>\n<p>虽然数组里没有获取最大值的方法，但是数值里面有 <code>Math.max(数字1，数字2，数字3)</code> 方法，可以获取<strong>多个数值中的最大值</strong>。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> maxValue = <span class=\"built_in\">Math</span>.max.apply(<span class=\"built_in\">Math</span>, arr1); <span class=\"comment\">// 求数组 arr1 中元素的最大值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(maxValue);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> minValue = <span class=\"built_in\">Math</span>.min.apply(<span class=\"built_in\">Math</span>, arr1); <span class=\"comment\">// 求数组 arr1 中元素的最小值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(minValue);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind()方法\"></a>bind()方法</h5><p>bind()会创建一个函数的实例，其this值会被绑定到传给bind()函数的值，</p>\n<p><code>new_func = fn1.bind(this指向的作用域, 函数实参1, 函数实参2……);</code></p>\n<p>如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.color = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = &#123; <span class=\"attr\">color</span>: <span class=\"string\">&#x27;blue&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> objectSayColor = sayColor.bind(o);</span><br><span class=\"line\">objectSayColor(); <span class=\"comment\">// blue</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RegExp\"><a href=\"#RegExp\" class=\"headerlink\" title=\"RegExp\"></a>RegExp</h2><p>ES通过RegExp类型来支持正则表达式。</p>\n<p><code>var expression = / pattern / flags;</code></p>\n<p>其中模式（pattern）可以是任意正则表达式。每个正则表达式都可以带有一个或多个标志（flags），匹配模式支持下列三种模式：</p>\n<ul>\n<li><strong>g：</strong>全局（global）模式。模式应用于所有字符串，发现第一个匹配项停止。</li>\n<li><strong>i：</strong>不区分大小写。</li>\n<li><strong>m：</strong>多行模式，到达一行文本末尾还会继续查找下一行。</li>\n</ul>\n<h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><p>RegExp的每个实例都具有下列属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>数据类型</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>global</td>\n<td>boolean</td>\n<td>是否设置g标志</td>\n</tr>\n<tr>\n<td>ignoreCase</td>\n<td>boolean</td>\n<td>是否设置i标志</td>\n</tr>\n<tr>\n<td>lastIndex</td>\n<td>整数</td>\n<td>开始搜索下一个匹配项的字符位置，从0开始</td>\n</tr>\n<tr>\n<td>multiline</td>\n<td>boolean</td>\n<td>是否设置m标志</td>\n</tr>\n<tr>\n<td>source</td>\n<td>String</td>\n<td>正则表达式的字符串形式</td>\n</tr>\n</tbody></table>"},{"title":"31天JavaScript学习-第5天","reprint":false,"date":"2022-02-24T02:29:47.000Z","updated":"2022-02-24T02:29:47.000Z","conver":null,"_content":"\n# 内置引用类型（三）——基本包装类型和单体内置对象\n\n<!--more-->\n\n## 基本包装类型\n\n我们都知道，js 中的数据类型包括以下几种。\n\n- 基本数据类型：String、Number、Boolean、Null、Undefined\n- 引用数据类型：Object\n\n为了便于操作基本类型值，ES提供了三个特殊的引用类型。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象。\n\n- String()：将基本数据类型字符串，转换为 String 对象。\n- Number()：将基本数据类型的数字，转换为 Number 对象。\n- Boolean()：将基本数据类型的布尔值，转换为 Boolean 对象。\n\n通过上面这这三个包装类，我们可以**将基本数据类型的数据转换为对象**。\n\n**基本包装类型的作用**\n\n当我们对一些基本数据类型的值去调用属性和方法时，浏览器会**临时使用包装类将基本数据类型转换为引用数据类型**，这样的话，基本数据类型就有了属性和方法，然后再调用对象的属性和方法；调用完以后，再将其转换为基本数据类型。\n\n```js\nvar s1 = 'some text';\nvar s2 = s1.substring(2);\n```\n\ns1包含一个字符串，字符串是基本类型值，但第二行调用了s1的substring()方法。基本类型值不是对象，理应没有方法。其实该操作包含以下三个步骤：\n\n1. 创建String类型的一个实例；`var s1 = new String('some text');`\n2. 在实例上调用指定的方法；`var s2 = s1.substring(2);`\n3. 销毁这个实例；`s1 = null;`\n\n## 单体内置对象\n\n### Global\n\nGlobal（全局）对象不属于任何其他对象的属性和方法，所有的对象都是它的属性和方法。事实上，没有全局变量和全局函数，所有在全局作用域定义的属性和函数，都是Global对象的属性；某些函数如isNan()、parseInt()以及parseFloat()，实际上都是Global对象的方法。\n\n### Math\n\nMath 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是直接使用里面的属性和方法即可。\n\nMath属于一个工具类，里面封装了数学运算相关的属性和方法。如下：\n\n| 属性         | 描述                        | 备注 |\n| ------------ | --------------------------- | ---- |\n| Math.E       | 自然对数的底数，即常量e的值 |      |\n| Math.LN10    | 10的自然对数                |      |\n| Math.LN2     | 2的自然对数                 |      |\n| Math.LOG2E   | 以2为底e的对数              |      |\n| Math.LOG10E  | 以10为底e的对数             |      |\n| Math.PI      | π的值                       |      |\n| Math.SQRT1_2 | 1/2的平方根                 |      |\n| Math.SQRT2   | 2的平方根                   |      |\n\n\n\n| 方法              | 描述                                       | 备注              |\n| ----------------- | ------------------------------------------ | ----------------- |\n| Math.PI           | 圆周率                                     | Math对象的属性    |\n| Math.abs()        | **返回绝对值**                             |                   |\n| Math.random()     | 生成0-1之间的**随机浮点数**                | 取值范围是 [0，1) |\n| Math.floor()      | **向下取整**（往小取值）                   |                   |\n| Math.ceil()       | **向上取整**（往大取值）                   |                   |\n| Math.round()      | 四舍五入取整（正数四舍五入，负数五舍六入） |                   |\n| Math.max(x, y, z) | 返回多个数中的最大值                       |                   |\n| Math.min(x, y, z) | 返回多个数中的最小值                       |                   |\n| Math.pow(x,y)     | 乘方：返回 x 的 y 次幂                     |                   |\n| Math.sqrt()       | 开方：对一个数进行开方运算                 |                   |\n","source":"_posts/31天JavaScript学习-第5天.md","raw":"---\n\ntitle: 31天JavaScript学习-第5天\nreprint: false\ndate: 2022-02-24 10:29:47\nupdated: 2022-02-24 10:29:47\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# 内置引用类型（三）——基本包装类型和单体内置对象\n\n<!--more-->\n\n## 基本包装类型\n\n我们都知道，js 中的数据类型包括以下几种。\n\n- 基本数据类型：String、Number、Boolean、Null、Undefined\n- 引用数据类型：Object\n\n为了便于操作基本类型值，ES提供了三个特殊的引用类型。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象。\n\n- String()：将基本数据类型字符串，转换为 String 对象。\n- Number()：将基本数据类型的数字，转换为 Number 对象。\n- Boolean()：将基本数据类型的布尔值，转换为 Boolean 对象。\n\n通过上面这这三个包装类，我们可以**将基本数据类型的数据转换为对象**。\n\n**基本包装类型的作用**\n\n当我们对一些基本数据类型的值去调用属性和方法时，浏览器会**临时使用包装类将基本数据类型转换为引用数据类型**，这样的话，基本数据类型就有了属性和方法，然后再调用对象的属性和方法；调用完以后，再将其转换为基本数据类型。\n\n```js\nvar s1 = 'some text';\nvar s2 = s1.substring(2);\n```\n\ns1包含一个字符串，字符串是基本类型值，但第二行调用了s1的substring()方法。基本类型值不是对象，理应没有方法。其实该操作包含以下三个步骤：\n\n1. 创建String类型的一个实例；`var s1 = new String('some text');`\n2. 在实例上调用指定的方法；`var s2 = s1.substring(2);`\n3. 销毁这个实例；`s1 = null;`\n\n## 单体内置对象\n\n### Global\n\nGlobal（全局）对象不属于任何其他对象的属性和方法，所有的对象都是它的属性和方法。事实上，没有全局变量和全局函数，所有在全局作用域定义的属性和函数，都是Global对象的属性；某些函数如isNan()、parseInt()以及parseFloat()，实际上都是Global对象的方法。\n\n### Math\n\nMath 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是直接使用里面的属性和方法即可。\n\nMath属于一个工具类，里面封装了数学运算相关的属性和方法。如下：\n\n| 属性         | 描述                        | 备注 |\n| ------------ | --------------------------- | ---- |\n| Math.E       | 自然对数的底数，即常量e的值 |      |\n| Math.LN10    | 10的自然对数                |      |\n| Math.LN2     | 2的自然对数                 |      |\n| Math.LOG2E   | 以2为底e的对数              |      |\n| Math.LOG10E  | 以10为底e的对数             |      |\n| Math.PI      | π的值                       |      |\n| Math.SQRT1_2 | 1/2的平方根                 |      |\n| Math.SQRT2   | 2的平方根                   |      |\n\n\n\n| 方法              | 描述                                       | 备注              |\n| ----------------- | ------------------------------------------ | ----------------- |\n| Math.PI           | 圆周率                                     | Math对象的属性    |\n| Math.abs()        | **返回绝对值**                             |                   |\n| Math.random()     | 生成0-1之间的**随机浮点数**                | 取值范围是 [0，1) |\n| Math.floor()      | **向下取整**（往小取值）                   |                   |\n| Math.ceil()       | **向上取整**（往大取值）                   |                   |\n| Math.round()      | 四舍五入取整（正数四舍五入，负数五舍六入） |                   |\n| Math.max(x, y, z) | 返回多个数中的最大值                       |                   |\n| Math.min(x, y, z) | 返回多个数中的最小值                       |                   |\n| Math.pow(x,y)     | 乘方：返回 x 的 y 次幂                     |                   |\n| Math.sqrt()       | 开方：对一个数进行开方运算                 |                   |\n","slug":"31天JavaScript学习-第5天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a800137owz2ebwhar8","content":"<h1 id=\"内置引用类型（三）——基本包装类型和单体内置对象\"><a href=\"#内置引用类型（三）——基本包装类型和单体内置对象\" class=\"headerlink\" title=\"内置引用类型（三）——基本包装类型和单体内置对象\"></a>内置引用类型（三）——基本包装类型和单体内置对象</h1><span id=\"more\"></span>\n\n<h2 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h2><p>我们都知道，js 中的数据类型包括以下几种。</p>\n<ul>\n<li>基本数据类型：String、Number、Boolean、Null、Undefined</li>\n<li>引用数据类型：Object</li>\n</ul>\n<p>为了便于操作基本类型值，ES提供了三个特殊的引用类型。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象。</p>\n<ul>\n<li>String()：将基本数据类型字符串，转换为 String 对象。</li>\n<li>Number()：将基本数据类型的数字，转换为 Number 对象。</li>\n<li>Boolean()：将基本数据类型的布尔值，转换为 Boolean 对象。</li>\n</ul>\n<p>通过上面这这三个包装类，我们可以<strong>将基本数据类型的数据转换为对象</strong>。</p>\n<p><strong>基本包装类型的作用</strong></p>\n<p>当我们对一些基本数据类型的值去调用属性和方法时，浏览器会<strong>临时使用包装类将基本数据类型转换为引用数据类型</strong>，这样的话，基本数据类型就有了属性和方法，然后再调用对象的属性和方法；调用完以后，再将其转换为基本数据类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">&#x27;some text&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>s1包含一个字符串，字符串是基本类型值，但第二行调用了s1的substring()方法。基本类型值不是对象，理应没有方法。其实该操作包含以下三个步骤：</p>\n<ol>\n<li>创建String类型的一个实例；<code>var s1 = new String(&#39;some text&#39;);</code></li>\n<li>在实例上调用指定的方法；<code>var s2 = s1.substring(2);</code></li>\n<li>销毁这个实例；<code>s1 = null;</code></li>\n</ol>\n<h2 id=\"单体内置对象\"><a href=\"#单体内置对象\" class=\"headerlink\" title=\"单体内置对象\"></a>单体内置对象</h2><h3 id=\"Global\"><a href=\"#Global\" class=\"headerlink\" title=\"Global\"></a>Global</h3><p>Global（全局）对象不属于任何其他对象的属性和方法，所有的对象都是它的属性和方法。事实上，没有全局变量和全局函数，所有在全局作用域定义的属性和函数，都是Global对象的属性；某些函数如isNan()、parseInt()以及parseFloat()，实际上都是Global对象的方法。</p>\n<h3 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h3><p>Math 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是直接使用里面的属性和方法即可。</p>\n<p>Math属于一个工具类，里面封装了数学运算相关的属性和方法。如下：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.E</td>\n<td>自然对数的底数，即常量e的值</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.LN10</td>\n<td>10的自然对数</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.LN2</td>\n<td>2的自然对数</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.LOG2E</td>\n<td>以2为底e的对数</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.LOG10E</td>\n<td>以10为底e的对数</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.PI</td>\n<td>π的值</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.SQRT1_2</td>\n<td>1/2的平方根</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.SQRT2</td>\n<td>2的平方根</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.PI</td>\n<td>圆周率</td>\n<td>Math对象的属性</td>\n</tr>\n<tr>\n<td>Math.abs()</td>\n<td><strong>返回绝对值</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Math.random()</td>\n<td>生成0-1之间的<strong>随机浮点数</strong></td>\n<td>取值范围是 [0，1)</td>\n</tr>\n<tr>\n<td>Math.floor()</td>\n<td><strong>向下取整</strong>（往小取值）</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.ceil()</td>\n<td><strong>向上取整</strong>（往大取值）</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.round()</td>\n<td>四舍五入取整（正数四舍五入，负数五舍六入）</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.max(x, y, z)</td>\n<td>返回多个数中的最大值</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.min(x, y, z)</td>\n<td>返回多个数中的最小值</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.pow(x,y)</td>\n<td>乘方：返回 x 的 y 次幂</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.sqrt()</td>\n<td>开方：对一个数进行开方运算</td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<h1 id=\"内置引用类型（三）——基本包装类型和单体内置对象\"><a href=\"#内置引用类型（三）——基本包装类型和单体内置对象\" class=\"headerlink\" title=\"内置引用类型（三）——基本包装类型和单体内置对象\"></a>内置引用类型（三）——基本包装类型和单体内置对象</h1>","more":"<h2 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h2><p>我们都知道，js 中的数据类型包括以下几种。</p>\n<ul>\n<li>基本数据类型：String、Number、Boolean、Null、Undefined</li>\n<li>引用数据类型：Object</li>\n</ul>\n<p>为了便于操作基本类型值，ES提供了三个特殊的引用类型。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象。</p>\n<ul>\n<li>String()：将基本数据类型字符串，转换为 String 对象。</li>\n<li>Number()：将基本数据类型的数字，转换为 Number 对象。</li>\n<li>Boolean()：将基本数据类型的布尔值，转换为 Boolean 对象。</li>\n</ul>\n<p>通过上面这这三个包装类，我们可以<strong>将基本数据类型的数据转换为对象</strong>。</p>\n<p><strong>基本包装类型的作用</strong></p>\n<p>当我们对一些基本数据类型的值去调用属性和方法时，浏览器会<strong>临时使用包装类将基本数据类型转换为引用数据类型</strong>，这样的话，基本数据类型就有了属性和方法，然后再调用对象的属性和方法；调用完以后，再将其转换为基本数据类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s1 = <span class=\"string\">&#x27;some text&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s2 = s1.substring(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>s1包含一个字符串，字符串是基本类型值，但第二行调用了s1的substring()方法。基本类型值不是对象，理应没有方法。其实该操作包含以下三个步骤：</p>\n<ol>\n<li>创建String类型的一个实例；<code>var s1 = new String(&#39;some text&#39;);</code></li>\n<li>在实例上调用指定的方法；<code>var s2 = s1.substring(2);</code></li>\n<li>销毁这个实例；<code>s1 = null;</code></li>\n</ol>\n<h2 id=\"单体内置对象\"><a href=\"#单体内置对象\" class=\"headerlink\" title=\"单体内置对象\"></a>单体内置对象</h2><h3 id=\"Global\"><a href=\"#Global\" class=\"headerlink\" title=\"Global\"></a>Global</h3><p>Global（全局）对象不属于任何其他对象的属性和方法，所有的对象都是它的属性和方法。事实上，没有全局变量和全局函数，所有在全局作用域定义的属性和函数，都是Global对象的属性；某些函数如isNan()、parseInt()以及parseFloat()，实际上都是Global对象的方法。</p>\n<h3 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h3><p>Math 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是直接使用里面的属性和方法即可。</p>\n<p>Math属于一个工具类，里面封装了数学运算相关的属性和方法。如下：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.E</td>\n<td>自然对数的底数，即常量e的值</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.LN10</td>\n<td>10的自然对数</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.LN2</td>\n<td>2的自然对数</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.LOG2E</td>\n<td>以2为底e的对数</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.LOG10E</td>\n<td>以10为底e的对数</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.PI</td>\n<td>π的值</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.SQRT1_2</td>\n<td>1/2的平方根</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.SQRT2</td>\n<td>2的平方根</td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.PI</td>\n<td>圆周率</td>\n<td>Math对象的属性</td>\n</tr>\n<tr>\n<td>Math.abs()</td>\n<td><strong>返回绝对值</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>Math.random()</td>\n<td>生成0-1之间的<strong>随机浮点数</strong></td>\n<td>取值范围是 [0，1)</td>\n</tr>\n<tr>\n<td>Math.floor()</td>\n<td><strong>向下取整</strong>（往小取值）</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.ceil()</td>\n<td><strong>向上取整</strong>（往大取值）</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.round()</td>\n<td>四舍五入取整（正数四舍五入，负数五舍六入）</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.max(x, y, z)</td>\n<td>返回多个数中的最大值</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.min(x, y, z)</td>\n<td>返回多个数中的最小值</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.pow(x,y)</td>\n<td>乘方：返回 x 的 y 次幂</td>\n<td></td>\n</tr>\n<tr>\n<td>Math.sqrt()</td>\n<td>开方：对一个数进行开方运算</td>\n<td></td>\n</tr>\n</tbody></table>"},{"title":"31天JavaScript学习-第6天","reprint":false,"date":"2022-02-25T11:57:15.000Z","updated":"2022-02-25T11:57:15.000Z","conver":null,"_content":"\n# day06-浅拷贝与深拷贝\n\n<!--more-->\n\n由于引用类型变量名存在栈内存中，值存在堆内存中，因此深拷贝只针对较为复杂的object类型数据。\n\n- **浅拷贝：**只拷贝最外面一层的数据；更深层次的对象，只拷贝引用\n- **深拷贝：**拷贝多层数据，每一层级的数据都会拷贝\n\n## 浅拷贝的实现方法\n\n### for in（繁琐）\n\n```js\nvar obj1 = {\n  name: 'jack',\n  age: 28,\n  info: {\n    desc: 'nice'\n  }\n};\n\nconst obj2 = {};\nfor (let key in obj1) {\n  obj2[key] = obj1[key];\n}\nconsole.log('obj2:' + JSON.stringify(obj2));\n\nobj1.age = 30;\nconsole.log('obj2:' + JSON.stringify(obj2.age)); // obj2:28 修改了obj1的第一层属性，obj2没有随之更改\n\nobj1.info.desc = 'good';\nconsole.log('obj2:' + JSON.stringify(obj2.info.desc)); // obj2:\"good\" 修改了obj1的info.desc属性，obj2也随之更改，说明obj2对obj1的info复制是复制了其引用地址\n```\n\n上方代码中，用 for in 做拷贝时，只能做到浅拷贝。也就是说，在 obj2 中， name 和 age 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系。但是，`obj2.info` 属性，跟 `obj1.info`属性，**它俩指向的是同一个堆内存地址**。所以，当我修改 `obj1.info` 里的值之后，`obj2.info`的值也会被修改。\n\n### Object.assgin()（推荐）\n\nES6提供了新的语法糖，通过`Object.assgin()`可以快速实现**浅拷贝**。将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被**覆盖**。\n\n```js\n// 语法1\nobj2 = Object.assgin(obj2, obj1);\n\n// 语法2\nObject.assign(目标对象, 源对象1, 源对象2...);\n```\n\n如\n\n```js\nvar myObj = {\n  name: 'jack',\n  age: 28,\n  info: {\n    desc: 'nice'\n  }\n};\n\n// 写法1\nconst obj1 = {};\nObject.assign(obj1, myObj);\n\n// 写法2\nconst obj2 = Object.assign({}, myObj);\n\n// 写法3\nconst obj31 = {};\nconst obj32 = Object.assign(obj31, myObj);\n\n// 将myObj、myObj2内容赋值给obj4\nlet myObj2 = {\n  city: 'xiamen',\n  age: 32\n}\n\nconst obj4 = Object.assign({}, myObj, myObj2);\n```\n\n## 深拷贝的实现方式\n\n### for in递归实现\n\n```js\nvar obj1 = {\n  name: 'jack',\n  age: 28,\n  info: {\n    desc: 'nice'\n  }\n};\n\nvar obj2 = {};\n\nfunction deepCopy(newObj, oldObj) {\n  for (let key in oldObj) {\n    // 获取属性值\n    let item = oldObj[key]\n    // 判断这个属性值是否是数组\n    if (item instanceof Array) {\n      newObj[key] = [];\n      deepCopy(newObj[key], item);\n    } else if (item instanceof Object) { // 判断这个属性值是否为对象\n      newObj[key] = {};\n      deepCopy(newObj[key], item);\n    } else { // 简单数据类型，直接赋值\n      newObj[key] = item;\n    }\n  }\n}\n\ndeepCopy(obj2, obj1);\nconsole.log(obj2);\nobj1.info.desc = 'github';\nconsole.log(obj2);\n\n```\n\n","source":"_posts/31天JavaScript学习-第6天.md","raw":"---\ntitle: 31天JavaScript学习-第6天\nreprint: false\ndate: 2022-02-25 19:57:15\nupdated: 2022-02-25 19:57:15\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# day06-浅拷贝与深拷贝\n\n<!--more-->\n\n由于引用类型变量名存在栈内存中，值存在堆内存中，因此深拷贝只针对较为复杂的object类型数据。\n\n- **浅拷贝：**只拷贝最外面一层的数据；更深层次的对象，只拷贝引用\n- **深拷贝：**拷贝多层数据，每一层级的数据都会拷贝\n\n## 浅拷贝的实现方法\n\n### for in（繁琐）\n\n```js\nvar obj1 = {\n  name: 'jack',\n  age: 28,\n  info: {\n    desc: 'nice'\n  }\n};\n\nconst obj2 = {};\nfor (let key in obj1) {\n  obj2[key] = obj1[key];\n}\nconsole.log('obj2:' + JSON.stringify(obj2));\n\nobj1.age = 30;\nconsole.log('obj2:' + JSON.stringify(obj2.age)); // obj2:28 修改了obj1的第一层属性，obj2没有随之更改\n\nobj1.info.desc = 'good';\nconsole.log('obj2:' + JSON.stringify(obj2.info.desc)); // obj2:\"good\" 修改了obj1的info.desc属性，obj2也随之更改，说明obj2对obj1的info复制是复制了其引用地址\n```\n\n上方代码中，用 for in 做拷贝时，只能做到浅拷贝。也就是说，在 obj2 中， name 和 age 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系。但是，`obj2.info` 属性，跟 `obj1.info`属性，**它俩指向的是同一个堆内存地址**。所以，当我修改 `obj1.info` 里的值之后，`obj2.info`的值也会被修改。\n\n### Object.assgin()（推荐）\n\nES6提供了新的语法糖，通过`Object.assgin()`可以快速实现**浅拷贝**。将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被**覆盖**。\n\n```js\n// 语法1\nobj2 = Object.assgin(obj2, obj1);\n\n// 语法2\nObject.assign(目标对象, 源对象1, 源对象2...);\n```\n\n如\n\n```js\nvar myObj = {\n  name: 'jack',\n  age: 28,\n  info: {\n    desc: 'nice'\n  }\n};\n\n// 写法1\nconst obj1 = {};\nObject.assign(obj1, myObj);\n\n// 写法2\nconst obj2 = Object.assign({}, myObj);\n\n// 写法3\nconst obj31 = {};\nconst obj32 = Object.assign(obj31, myObj);\n\n// 将myObj、myObj2内容赋值给obj4\nlet myObj2 = {\n  city: 'xiamen',\n  age: 32\n}\n\nconst obj4 = Object.assign({}, myObj, myObj2);\n```\n\n## 深拷贝的实现方式\n\n### for in递归实现\n\n```js\nvar obj1 = {\n  name: 'jack',\n  age: 28,\n  info: {\n    desc: 'nice'\n  }\n};\n\nvar obj2 = {};\n\nfunction deepCopy(newObj, oldObj) {\n  for (let key in oldObj) {\n    // 获取属性值\n    let item = oldObj[key]\n    // 判断这个属性值是否是数组\n    if (item instanceof Array) {\n      newObj[key] = [];\n      deepCopy(newObj[key], item);\n    } else if (item instanceof Object) { // 判断这个属性值是否为对象\n      newObj[key] = {};\n      deepCopy(newObj[key], item);\n    } else { // 简单数据类型，直接赋值\n      newObj[key] = item;\n    }\n  }\n}\n\ndeepCopy(obj2, obj1);\nconsole.log(obj2);\nobj1.info.desc = 'github';\nconsole.log(obj2);\n\n```\n\n","slug":"31天JavaScript学习-第6天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2a900167owzcgwz9fkg","content":"<h1 id=\"day06-浅拷贝与深拷贝\"><a href=\"#day06-浅拷贝与深拷贝\" class=\"headerlink\" title=\"day06-浅拷贝与深拷贝\"></a>day06-浅拷贝与深拷贝</h1><span id=\"more\"></span>\n\n<p>由于引用类型变量名存在栈内存中，值存在堆内存中，因此深拷贝只针对较为复杂的object类型数据。</p>\n<ul>\n<li><strong>浅拷贝：</strong>只拷贝最外面一层的数据；更深层次的对象，只拷贝引用</li>\n<li><strong>深拷贝：</strong>拷贝多层数据，每一层级的数据都会拷贝</li>\n</ul>\n<h2 id=\"浅拷贝的实现方法\"><a href=\"#浅拷贝的实现方法\" class=\"headerlink\" title=\"浅拷贝的实现方法\"></a>浅拷贝的实现方法</h2><h3 id=\"for-in（繁琐）\"><a href=\"#for-in（繁琐）\" class=\"headerlink\" title=\"for in（繁琐）\"></a>for in（繁琐）</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</span><br><span class=\"line\">  <span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">desc</span>: <span class=\"string\">&#x27;nice&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj1) &#123;</span><br><span class=\"line\">  obj2[key] = obj1[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;obj2:&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(obj2));</span><br><span class=\"line\"></span><br><span class=\"line\">obj1.age = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;obj2:&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(obj2.age)); <span class=\"comment\">// obj2:28 修改了obj1的第一层属性，obj2没有随之更改</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj1.info.desc = <span class=\"string\">&#x27;good&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;obj2:&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(obj2.info.desc)); <span class=\"comment\">// obj2:&quot;good&quot; 修改了obj1的info.desc属性，obj2也随之更改，说明obj2对obj1的info复制是复制了其引用地址</span></span><br></pre></td></tr></table></figure>\n\n<p>上方代码中，用 for in 做拷贝时，只能做到浅拷贝。也就是说，在 obj2 中， name 和 age 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系。但是，<code>obj2.info</code> 属性，跟 <code>obj1.info</code>属性，<strong>它俩指向的是同一个堆内存地址</strong>。所以，当我修改 <code>obj1.info</code> 里的值之后，<code>obj2.info</code>的值也会被修改。</p>\n<h3 id=\"Object-assgin-（推荐）\"><a href=\"#Object-assgin-（推荐）\" class=\"headerlink\" title=\"Object.assgin()（推荐）\"></a>Object.assgin()（推荐）</h3><p>ES6提供了新的语法糖，通过<code>Object.assgin()</code>可以快速实现<strong>浅拷贝</strong>。将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被<strong>覆盖</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法1</span></span><br><span class=\"line\">obj2 = <span class=\"built_in\">Object</span>.assgin(obj2, obj1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 语法2</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(目标对象, 源对象<span class=\"number\">1</span>, 源对象<span class=\"number\">2.</span>..);</span><br></pre></td></tr></table></figure>\n\n<p>如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</span><br><span class=\"line\">  <span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">desc</span>: <span class=\"string\">&#x27;nice&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj1, myObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法2</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, myObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法3</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj31 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj32 = <span class=\"built_in\">Object</span>.assign(obj31, myObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将myObj、myObj2内容赋值给obj4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj2 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">&#x27;xiamen&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">32</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj4 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, myObj, myObj2);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"深拷贝的实现方式\"><a href=\"#深拷贝的实现方式\" class=\"headerlink\" title=\"深拷贝的实现方式\"></a>深拷贝的实现方式</h2><h3 id=\"for-in递归实现\"><a href=\"#for-in递归实现\" class=\"headerlink\" title=\"for in递归实现\"></a>for in递归实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</span><br><span class=\"line\">  <span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">desc</span>: <span class=\"string\">&#x27;nice&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span>(<span class=\"params\">newObj, oldObj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> oldObj) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取属性值</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = oldObj[key]</span><br><span class=\"line\">    <span class=\"comment\">// 判断这个属性值是否是数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">      newObj[key] = [];</span><br><span class=\"line\">      deepCopy(newObj[key], item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (item <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) &#123; <span class=\"comment\">// 判断这个属性值是否为对象</span></span><br><span class=\"line\">      newObj[key] = &#123;&#125;;</span><br><span class=\"line\">      deepCopy(newObj[key], item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 简单数据类型，直接赋值</span></span><br><span class=\"line\">      newObj[key] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">deepCopy(obj2, obj1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2);</span><br><span class=\"line\">obj1.info.desc = <span class=\"string\">&#x27;github&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h1 id=\"day06-浅拷贝与深拷贝\"><a href=\"#day06-浅拷贝与深拷贝\" class=\"headerlink\" title=\"day06-浅拷贝与深拷贝\"></a>day06-浅拷贝与深拷贝</h1>","more":"<p>由于引用类型变量名存在栈内存中，值存在堆内存中，因此深拷贝只针对较为复杂的object类型数据。</p>\n<ul>\n<li><strong>浅拷贝：</strong>只拷贝最外面一层的数据；更深层次的对象，只拷贝引用</li>\n<li><strong>深拷贝：</strong>拷贝多层数据，每一层级的数据都会拷贝</li>\n</ul>\n<h2 id=\"浅拷贝的实现方法\"><a href=\"#浅拷贝的实现方法\" class=\"headerlink\" title=\"浅拷贝的实现方法\"></a>浅拷贝的实现方法</h2><h3 id=\"for-in（繁琐）\"><a href=\"#for-in（繁琐）\" class=\"headerlink\" title=\"for in（繁琐）\"></a>for in（繁琐）</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</span><br><span class=\"line\">  <span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">desc</span>: <span class=\"string\">&#x27;nice&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj1) &#123;</span><br><span class=\"line\">  obj2[key] = obj1[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;obj2:&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(obj2));</span><br><span class=\"line\"></span><br><span class=\"line\">obj1.age = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;obj2:&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(obj2.age)); <span class=\"comment\">// obj2:28 修改了obj1的第一层属性，obj2没有随之更改</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj1.info.desc = <span class=\"string\">&#x27;good&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;obj2:&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(obj2.info.desc)); <span class=\"comment\">// obj2:&quot;good&quot; 修改了obj1的info.desc属性，obj2也随之更改，说明obj2对obj1的info复制是复制了其引用地址</span></span><br></pre></td></tr></table></figure>\n\n<p>上方代码中，用 for in 做拷贝时，只能做到浅拷贝。也就是说，在 obj2 中， name 和 age 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系。但是，<code>obj2.info</code> 属性，跟 <code>obj1.info</code>属性，<strong>它俩指向的是同一个堆内存地址</strong>。所以，当我修改 <code>obj1.info</code> 里的值之后，<code>obj2.info</code>的值也会被修改。</p>\n<h3 id=\"Object-assgin-（推荐）\"><a href=\"#Object-assgin-（推荐）\" class=\"headerlink\" title=\"Object.assgin()（推荐）\"></a>Object.assgin()（推荐）</h3><p>ES6提供了新的语法糖，通过<code>Object.assgin()</code>可以快速实现<strong>浅拷贝</strong>。将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被<strong>覆盖</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法1</span></span><br><span class=\"line\">obj2 = <span class=\"built_in\">Object</span>.assgin(obj2, obj1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 语法2</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(目标对象, 源对象<span class=\"number\">1</span>, 源对象<span class=\"number\">2.</span>..);</span><br></pre></td></tr></table></figure>\n\n<p>如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</span><br><span class=\"line\">  <span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">desc</span>: <span class=\"string\">&#x27;nice&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj1, myObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法2</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, myObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法3</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj31 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj32 = <span class=\"built_in\">Object</span>.assign(obj31, myObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将myObj、myObj2内容赋值给obj4</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj2 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">&#x27;xiamen&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">32</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj4 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, myObj, myObj2);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"深拷贝的实现方式\"><a href=\"#深拷贝的实现方式\" class=\"headerlink\" title=\"深拷贝的实现方式\"></a>深拷贝的实现方式</h2><h3 id=\"for-in递归实现\"><a href=\"#for-in递归实现\" class=\"headerlink\" title=\"for in递归实现\"></a>for in递归实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</span><br><span class=\"line\">  <span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">desc</span>: <span class=\"string\">&#x27;nice&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepCopy</span>(<span class=\"params\">newObj, oldObj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> oldObj) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取属性值</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = oldObj[key]</span><br><span class=\"line\">    <span class=\"comment\">// 判断这个属性值是否是数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">      newObj[key] = [];</span><br><span class=\"line\">      deepCopy(newObj[key], item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (item <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) &#123; <span class=\"comment\">// 判断这个属性值是否为对象</span></span><br><span class=\"line\">      newObj[key] = &#123;&#125;;</span><br><span class=\"line\">      deepCopy(newObj[key], item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 简单数据类型，直接赋值</span></span><br><span class=\"line\">      newObj[key] = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">deepCopy(obj2, obj1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2);</span><br><span class=\"line\">obj1.info.desc = <span class=\"string\">&#x27;github&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"31天JavaScript学习-第7天","reprint":false,"date":"2022-02-26T12:27:01.000Z","updated":"2022-02-26T12:27:01.000Z","conver":null,"_content":"\n# 面向对象（一）——对象简介与创建\n\n<!--more-->\n\nJS中的面向对象，是基于**原型**的面向对象，依靠构造器（constructor）和原型（prototype）。\n\nES6中，引入了类（Class）和继承（Extend）来实现面向对象。\n\n## 对象字面量\n\n```js\nconst obj1 = {\n    name: 'zr',\n    age: 28\n};\n```\n\n## 工厂模式\n\n```js\nfunction createPerson (name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function () {\n        alert(this.name);\n    };\n    return o;\n}\n\nvar person1 = createPerson('jack', 20, 'doctor');\n```\n\n使用工厂模式创建的对象，使用的构造函数都是Object，所以创建的对象都是Object类型，无法区分多种不同类型的对象。\n\n## 构造函数模式\n\n**构造函数：**是用来创建和初始化对象的特殊的函数，它与new一起使用才有意义。\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function () {\n        alert(this.name);\n    };// 不需要return对象\n}\n\nvar person1 = new Person('zr', 20, 'student');\nvar person2 = new Person('jack', 30, 'doctor');\n\n// 所有对象均继承自Object\nalert(person1 instanceof Object); // true\nalert(person1 instanceof Person); // true\n```\n\n**不同函数this的指向：**\n\n- 以函数的形式调用时，this永远指向window。\n- 以方法的形式调用时，this指向调用方法的对象。\n- 以构造函数形式调用时，this指向新创建的实例对象。\n\n**构造函数的问题：**\n\n每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数时不相等的。按照上面这种写法，假设创建10000个对象实例，就会创建10000个 sayName 方法。这种写法肯定是不合适的。我们为何不让所有的对象共享同一个方法呢？\n\n还有一种方式是，将sayName方法在全局作用域中定义：（不建议。原因看注释）\n\n```js\nfunction Person(name, age, gender) {\n    this.name = name;\n    this.age = age;\n    this.gender = gender;\n    //向对象中添加一个方法\n    this.sayName = fun;\n}\n\n//将sayName方法在全局作用域中定义\n/*\n * 将函数定义在全局作用域，污染了全局作用域的命名空间\n *  而且定义在全局作用域中也很不安全\n */\nfunction fun() {\n    alert(\"Hello大家好，我是:\" + this.name);\n};\n```\n\n### 原型模式\n\n#### 原型对象\n\n每个创建的函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象包含了通过调用该构造函数所创建的对象共享的属性和方法。运行机制如下：\n\n1. 创建一个自定义的构造函数后，其原型对象默认只有constructor（构造函数）属性（指向prototype属性所在函数的指针）。\n2. 调用构造函数创建一个新实例，实例内部将包含一个指针指向构造函数的原型对象。ES5中称这个指针为`[[prototype]]`，Firefox、Safari和Chrome在每个对象上都支持一个属性`__proto__`。\n\n![image-20220228150429925](31天JavaScript学习-第7天/image-20220228150429925.png)\n\n如上图所示，person1实例不包含属性和方法，但它仍可以调用到它的原型对象的属性和方法，这是通过查找对象属性的过程实现的。\n\n每当代码读取某个对象的某个属性时，都会执行一次搜索，搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象。\n\n虽然可以通过对象实例访问保存在原型中的值，**但不能通过对象实例重写原型中的值。**\n\n即使将实例的同名属性设为null，也只会在实例中设置这个属性。使用delete操作符可以完全删除实例属性，从而重新访问原型中的同名属性。\n\n**一些方法：**\n\n- isPrototypeOf()  确定是否是实例对象的原型对象\n- Object.getPrototypeOf()  返回对象的原型对象\n- hasOwnProperty()  检测一个属性是存在于实例中，还是存在原型中。存在对象实例中返回true。\n\n#### in操作符\n\n**单独使用：**检查对象中是否含有某个属性，无论是在实例对象还是在其原型对象。\n\n**for-in：**返回所有能通过对象访问的、可枚举的（enumerated）属性。\n\n#### 更简单的原型语法\n\n前面的例子中每添加一个属性和方法都要用`Person.prototype`。为简化操作，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。\n\n```js\nfunction Person() {\n}\nPerson.prototype = {\n\tname: 'jack',\n\tage: 20,\n\tjob: 'doctor',\n\tsayName: function() {\n\t\talert(this.name);\n\t}\n};\n```\n\n#### 原型的动态性\n\n#### 原生对象的原型\n\n原型模式不仅体现在创建自定义类型方面，也体现在原生的引用类型。但不建议修改原生对象的原型。\n\n## 组合使用构造函数模式和原型模式\n\n构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.frieds = ['jack', 'zr'];\n}\n\nPerson.prototype = {\n  constructor: Person,\n  sayName: function() {\n    alert(this.name);\n  }\n};\n\nvar person1 = new Person('Nick', 23, 'doctor');\nvar person2 = new Person('Grey', 32, 'Engineer');\n\nperson1.frieds.push('Van');\nconsole.log(person1.frieds); // [ 'jack', 'zr', 'Van' ]\nconsole.log(person2.frieds); // [ 'jack', 'zr' ]\nconsole.log(person1.frieds === person2.frieds); // false\nconsole.log(person1.sayName === person2.sayName); //true\n```\n\n## 动态原型模式\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  if (typeof this.sayName != 'function') {\n    Person.prototype.sayName = function () {\n      console.log(this.name);\n    }\n  }\n}\n\nvar friend = new Person('Nick', 29, 'Engineer');\nfriend.sayName();\n```\n\n这里只会在`sayName()`方法不存在的情况下，才会将它添加到原型中。\n","source":"_posts/31天JavaScript学习-第7天.md","raw":"---\ntitle: 31天JavaScript学习-第7天\nreprint: false\ndate: 2022-02-26 20:27:01\nupdated: 2022-02-26 20:27:01\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# 面向对象（一）——对象简介与创建\n\n<!--more-->\n\nJS中的面向对象，是基于**原型**的面向对象，依靠构造器（constructor）和原型（prototype）。\n\nES6中，引入了类（Class）和继承（Extend）来实现面向对象。\n\n## 对象字面量\n\n```js\nconst obj1 = {\n    name: 'zr',\n    age: 28\n};\n```\n\n## 工厂模式\n\n```js\nfunction createPerson (name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function () {\n        alert(this.name);\n    };\n    return o;\n}\n\nvar person1 = createPerson('jack', 20, 'doctor');\n```\n\n使用工厂模式创建的对象，使用的构造函数都是Object，所以创建的对象都是Object类型，无法区分多种不同类型的对象。\n\n## 构造函数模式\n\n**构造函数：**是用来创建和初始化对象的特殊的函数，它与new一起使用才有意义。\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function () {\n        alert(this.name);\n    };// 不需要return对象\n}\n\nvar person1 = new Person('zr', 20, 'student');\nvar person2 = new Person('jack', 30, 'doctor');\n\n// 所有对象均继承自Object\nalert(person1 instanceof Object); // true\nalert(person1 instanceof Person); // true\n```\n\n**不同函数this的指向：**\n\n- 以函数的形式调用时，this永远指向window。\n- 以方法的形式调用时，this指向调用方法的对象。\n- 以构造函数形式调用时，this指向新创建的实例对象。\n\n**构造函数的问题：**\n\n每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数时不相等的。按照上面这种写法，假设创建10000个对象实例，就会创建10000个 sayName 方法。这种写法肯定是不合适的。我们为何不让所有的对象共享同一个方法呢？\n\n还有一种方式是，将sayName方法在全局作用域中定义：（不建议。原因看注释）\n\n```js\nfunction Person(name, age, gender) {\n    this.name = name;\n    this.age = age;\n    this.gender = gender;\n    //向对象中添加一个方法\n    this.sayName = fun;\n}\n\n//将sayName方法在全局作用域中定义\n/*\n * 将函数定义在全局作用域，污染了全局作用域的命名空间\n *  而且定义在全局作用域中也很不安全\n */\nfunction fun() {\n    alert(\"Hello大家好，我是:\" + this.name);\n};\n```\n\n### 原型模式\n\n#### 原型对象\n\n每个创建的函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象包含了通过调用该构造函数所创建的对象共享的属性和方法。运行机制如下：\n\n1. 创建一个自定义的构造函数后，其原型对象默认只有constructor（构造函数）属性（指向prototype属性所在函数的指针）。\n2. 调用构造函数创建一个新实例，实例内部将包含一个指针指向构造函数的原型对象。ES5中称这个指针为`[[prototype]]`，Firefox、Safari和Chrome在每个对象上都支持一个属性`__proto__`。\n\n![image-20220228150429925](31天JavaScript学习-第7天/image-20220228150429925.png)\n\n如上图所示，person1实例不包含属性和方法，但它仍可以调用到它的原型对象的属性和方法，这是通过查找对象属性的过程实现的。\n\n每当代码读取某个对象的某个属性时，都会执行一次搜索，搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象。\n\n虽然可以通过对象实例访问保存在原型中的值，**但不能通过对象实例重写原型中的值。**\n\n即使将实例的同名属性设为null，也只会在实例中设置这个属性。使用delete操作符可以完全删除实例属性，从而重新访问原型中的同名属性。\n\n**一些方法：**\n\n- isPrototypeOf()  确定是否是实例对象的原型对象\n- Object.getPrototypeOf()  返回对象的原型对象\n- hasOwnProperty()  检测一个属性是存在于实例中，还是存在原型中。存在对象实例中返回true。\n\n#### in操作符\n\n**单独使用：**检查对象中是否含有某个属性，无论是在实例对象还是在其原型对象。\n\n**for-in：**返回所有能通过对象访问的、可枚举的（enumerated）属性。\n\n#### 更简单的原型语法\n\n前面的例子中每添加一个属性和方法都要用`Person.prototype`。为简化操作，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。\n\n```js\nfunction Person() {\n}\nPerson.prototype = {\n\tname: 'jack',\n\tage: 20,\n\tjob: 'doctor',\n\tsayName: function() {\n\t\talert(this.name);\n\t}\n};\n```\n\n#### 原型的动态性\n\n#### 原生对象的原型\n\n原型模式不仅体现在创建自定义类型方面，也体现在原生的引用类型。但不建议修改原生对象的原型。\n\n## 组合使用构造函数模式和原型模式\n\n构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.frieds = ['jack', 'zr'];\n}\n\nPerson.prototype = {\n  constructor: Person,\n  sayName: function() {\n    alert(this.name);\n  }\n};\n\nvar person1 = new Person('Nick', 23, 'doctor');\nvar person2 = new Person('Grey', 32, 'Engineer');\n\nperson1.frieds.push('Van');\nconsole.log(person1.frieds); // [ 'jack', 'zr', 'Van' ]\nconsole.log(person2.frieds); // [ 'jack', 'zr' ]\nconsole.log(person1.frieds === person2.frieds); // false\nconsole.log(person1.sayName === person2.sayName); //true\n```\n\n## 动态原型模式\n\n```js\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  if (typeof this.sayName != 'function') {\n    Person.prototype.sayName = function () {\n      console.log(this.name);\n    }\n  }\n}\n\nvar friend = new Person('Nick', 29, 'Engineer');\nfriend.sayName();\n```\n\n这里只会在`sayName()`方法不存在的情况下，才会将它添加到原型中。\n","slug":"31天JavaScript学习-第7天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2aa001a7owz2thv8317","content":"<h1 id=\"面向对象（一）——对象简介与创建\"><a href=\"#面向对象（一）——对象简介与创建\" class=\"headerlink\" title=\"面向对象（一）——对象简介与创建\"></a>面向对象（一）——对象简介与创建</h1><span id=\"more\"></span>\n\n<p>JS中的面向对象，是基于<strong>原型</strong>的面向对象，依靠构造器（constructor）和原型（prototype）。</p>\n<p>ES6中，引入了类（Class）和继承（Extend）来实现面向对象。</p>\n<h2 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zr&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">28</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span> (<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    o.name = name;</span><br><span class=\"line\">    o.age = age;</span><br><span class=\"line\">    o.job = job;</span><br><span class=\"line\">    o.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"number\">20</span>, <span class=\"string\">&#x27;doctor&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用工厂模式创建的对象，使用的构造函数都是Object，所以创建的对象都是Object类型，无法区分多种不同类型的对象。</p>\n<h2 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h2><p><strong>构造函数：</strong>是用来创建和初始化对象的特殊的函数，它与new一起使用才有意义。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;<span class=\"comment\">// 不需要return对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;zr&#x27;</span>, <span class=\"number\">20</span>, <span class=\"string\">&#x27;student&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"number\">30</span>, <span class=\"string\">&#x27;doctor&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有对象均继承自Object</span></span><br><span class=\"line\">alert(person1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">alert(person1 <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>不同函数this的指向：</strong></p>\n<ul>\n<li>以函数的形式调用时，this永远指向window。</li>\n<li>以方法的形式调用时，this指向调用方法的对象。</li>\n<li>以构造函数形式调用时，this指向新创建的实例对象。</li>\n</ul>\n<p><strong>构造函数的问题：</strong></p>\n<p>每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数时不相等的。按照上面这种写法，假设创建10000个对象实例，就会创建10000个 sayName 方法。这种写法肯定是不合适的。我们为何不让所有的对象共享同一个方法呢？</p>\n<p>还有一种方式是，将sayName方法在全局作用域中定义：（不建议。原因看注释）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, gender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.gender = gender;</span><br><span class=\"line\">    <span class=\"comment\">//向对象中添加一个方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = fun;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将sayName方法在全局作用域中定义</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 将函数定义在全局作用域，污染了全局作用域的命名空间</span></span><br><span class=\"line\"><span class=\"comment\"> *  而且定义在全局作用域中也很不安全</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;Hello大家好，我是:&quot;</span> + <span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><h4 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h4><p>每个创建的函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象包含了通过调用该构造函数所创建的对象共享的属性和方法。运行机制如下：</p>\n<ol>\n<li>创建一个自定义的构造函数后，其原型对象默认只有constructor（构造函数）属性（指向prototype属性所在函数的指针）。</li>\n<li>调用构造函数创建一个新实例，实例内部将包含一个指针指向构造函数的原型对象。ES5中称这个指针为<code>[[prototype]]</code>，Firefox、Safari和Chrome在每个对象上都支持一个属性<code>__proto__</code>。</li>\n</ol>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/02/26/530fde90e882/image-20220228150429925.png\" alt=\"image-20220228150429925\" class=\"lazyload\"></p>\n<p>如上图所示，person1实例不包含属性和方法，但它仍可以调用到它的原型对象的属性和方法，这是通过查找对象属性的过程实现的。</p>\n<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象。</p>\n<p>虽然可以通过对象实例访问保存在原型中的值，<strong>但不能通过对象实例重写原型中的值。</strong></p>\n<p>即使将实例的同名属性设为null，也只会在实例中设置这个属性。使用delete操作符可以完全删除实例属性，从而重新访问原型中的同名属性。</p>\n<p><strong>一些方法：</strong></p>\n<ul>\n<li>isPrototypeOf()  确定是否是实例对象的原型对象</li>\n<li>Object.getPrototypeOf()  返回对象的原型对象</li>\n<li>hasOwnProperty()  检测一个属性是存在于实例中，还是存在原型中。存在对象实例中返回true。</li>\n</ul>\n<h4 id=\"in操作符\"><a href=\"#in操作符\" class=\"headerlink\" title=\"in操作符\"></a>in操作符</h4><p><strong>单独使用：</strong>检查对象中是否含有某个属性，无论是在实例对象还是在其原型对象。</p>\n<p><strong>for-in：</strong>返回所有能通过对象访问的、可枚举的（enumerated）属性。</p>\n<h4 id=\"更简单的原型语法\"><a href=\"#更简单的原型语法\" class=\"headerlink\" title=\"更简单的原型语法\"></a>更简单的原型语法</h4><p>前面的例子中每添加一个属性和方法都要用<code>Person.prototype</code>。为简化操作，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\">\t<span class=\"attr\">job</span>: <span class=\"string\">&#x27;doctor&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">sayName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原型的动态性\"><a href=\"#原型的动态性\" class=\"headerlink\" title=\"原型的动态性\"></a>原型的动态性</h4><h4 id=\"原生对象的原型\"><a href=\"#原生对象的原型\" class=\"headerlink\" title=\"原生对象的原型\"></a>原生对象的原型</h4><p>原型模式不仅体现在创建自定义类型方面，也体现在原生的引用类型。但不建议修改原生对象的原型。</p>\n<h2 id=\"组合使用构造函数模式和原型模式\"><a href=\"#组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"组合使用构造函数模式和原型模式\"></a>组合使用构造函数模式和原型模式</h2><p>构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.frieds = [<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"string\">&#x27;zr&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  <span class=\"attr\">constructor</span>: Person,</span><br><span class=\"line\">  <span class=\"attr\">sayName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Nick&#x27;</span>, <span class=\"number\">23</span>, <span class=\"string\">&#x27;doctor&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Grey&#x27;</span>, <span class=\"number\">32</span>, <span class=\"string\">&#x27;Engineer&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.frieds.push(<span class=\"string\">&#x27;Van&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.frieds); <span class=\"comment\">// [ &#x27;jack&#x27;, &#x27;zr&#x27;, &#x27;Van&#x27; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.frieds); <span class=\"comment\">// [ &#x27;jack&#x27;, &#x27;zr&#x27; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.frieds === person2.frieds); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span>.sayName != <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> friend = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Nick&#x27;</span>, <span class=\"number\">29</span>, <span class=\"string\">&#x27;Engineer&#x27;</span>);</span><br><span class=\"line\">friend.sayName();</span><br></pre></td></tr></table></figure>\n\n<p>这里只会在<code>sayName()</code>方法不存在的情况下，才会将它添加到原型中。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"面向对象（一）——对象简介与创建\"><a href=\"#面向对象（一）——对象简介与创建\" class=\"headerlink\" title=\"面向对象（一）——对象简介与创建\"></a>面向对象（一）——对象简介与创建</h1>","more":"<p>JS中的面向对象，是基于<strong>原型</strong>的面向对象，依靠构造器（constructor）和原型（prototype）。</p>\n<p>ES6中，引入了类（Class）和继承（Extend）来实现面向对象。</p>\n<h2 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zr&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">28</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span> (<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    o.name = name;</span><br><span class=\"line\">    o.age = age;</span><br><span class=\"line\">    o.job = job;</span><br><span class=\"line\">    o.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"number\">20</span>, <span class=\"string\">&#x27;doctor&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用工厂模式创建的对象，使用的构造函数都是Object，所以创建的对象都是Object类型，无法区分多种不同类型的对象。</p>\n<h2 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h2><p><strong>构造函数：</strong>是用来创建和初始化对象的特殊的函数，它与new一起使用才有意义。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;;<span class=\"comment\">// 不需要return对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;zr&#x27;</span>, <span class=\"number\">20</span>, <span class=\"string\">&#x27;student&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"number\">30</span>, <span class=\"string\">&#x27;doctor&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有对象均继承自Object</span></span><br><span class=\"line\">alert(person1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">alert(person1 <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>不同函数this的指向：</strong></p>\n<ul>\n<li>以函数的形式调用时，this永远指向window。</li>\n<li>以方法的形式调用时，this指向调用方法的对象。</li>\n<li>以构造函数形式调用时，this指向新创建的实例对象。</li>\n</ul>\n<p><strong>构造函数的问题：</strong></p>\n<p>每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数时不相等的。按照上面这种写法，假设创建10000个对象实例，就会创建10000个 sayName 方法。这种写法肯定是不合适的。我们为何不让所有的对象共享同一个方法呢？</p>\n<p>还有一种方式是，将sayName方法在全局作用域中定义：（不建议。原因看注释）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, gender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.gender = gender;</span><br><span class=\"line\">    <span class=\"comment\">//向对象中添加一个方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sayName = fun;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将sayName方法在全局作用域中定义</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 将函数定义在全局作用域，污染了全局作用域的命名空间</span></span><br><span class=\"line\"><span class=\"comment\"> *  而且定义在全局作用域中也很不安全</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;Hello大家好，我是:&quot;</span> + <span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><h4 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h4><p>每个创建的函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象包含了通过调用该构造函数所创建的对象共享的属性和方法。运行机制如下：</p>\n<ol>\n<li>创建一个自定义的构造函数后，其原型对象默认只有constructor（构造函数）属性（指向prototype属性所在函数的指针）。</li>\n<li>调用构造函数创建一个新实例，实例内部将包含一个指针指向构造函数的原型对象。ES5中称这个指针为<code>[[prototype]]</code>，Firefox、Safari和Chrome在每个对象上都支持一个属性<code>__proto__</code>。</li>\n</ol>\n<p><img src=\"/2022/02/26/530fde90e882/image-20220228150429925.png\" alt=\"image-20220228150429925\"></p>\n<p>如上图所示，person1实例不包含属性和方法，但它仍可以调用到它的原型对象的属性和方法，这是通过查找对象属性的过程实现的。</p>\n<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象。</p>\n<p>虽然可以通过对象实例访问保存在原型中的值，<strong>但不能通过对象实例重写原型中的值。</strong></p>\n<p>即使将实例的同名属性设为null，也只会在实例中设置这个属性。使用delete操作符可以完全删除实例属性，从而重新访问原型中的同名属性。</p>\n<p><strong>一些方法：</strong></p>\n<ul>\n<li>isPrototypeOf()  确定是否是实例对象的原型对象</li>\n<li>Object.getPrototypeOf()  返回对象的原型对象</li>\n<li>hasOwnProperty()  检测一个属性是存在于实例中，还是存在原型中。存在对象实例中返回true。</li>\n</ul>\n<h4 id=\"in操作符\"><a href=\"#in操作符\" class=\"headerlink\" title=\"in操作符\"></a>in操作符</h4><p><strong>单独使用：</strong>检查对象中是否含有某个属性，无论是在实例对象还是在其原型对象。</p>\n<p><strong>for-in：</strong>返回所有能通过对象访问的、可枚举的（enumerated）属性。</p>\n<h4 id=\"更简单的原型语法\"><a href=\"#更简单的原型语法\" class=\"headerlink\" title=\"更简单的原型语法\"></a>更简单的原型语法</h4><p>前面的例子中每添加一个属性和方法都要用<code>Person.prototype</code>。为简化操作，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\">\t<span class=\"attr\">job</span>: <span class=\"string\">&#x27;doctor&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">sayName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原型的动态性\"><a href=\"#原型的动态性\" class=\"headerlink\" title=\"原型的动态性\"></a>原型的动态性</h4><h4 id=\"原生对象的原型\"><a href=\"#原生对象的原型\" class=\"headerlink\" title=\"原生对象的原型\"></a>原生对象的原型</h4><p>原型模式不仅体现在创建自定义类型方面，也体现在原生的引用类型。但不建议修改原生对象的原型。</p>\n<h2 id=\"组合使用构造函数模式和原型模式\"><a href=\"#组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"组合使用构造函数模式和原型模式\"></a>组合使用构造函数模式和原型模式</h2><p>构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.frieds = [<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"string\">&#x27;zr&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  <span class=\"attr\">constructor</span>: Person,</span><br><span class=\"line\">  <span class=\"attr\">sayName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Nick&#x27;</span>, <span class=\"number\">23</span>, <span class=\"string\">&#x27;doctor&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Grey&#x27;</span>, <span class=\"number\">32</span>, <span class=\"string\">&#x27;Engineer&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.frieds.push(<span class=\"string\">&#x27;Van&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.frieds); <span class=\"comment\">// [ &#x27;jack&#x27;, &#x27;zr&#x27;, &#x27;Van&#x27; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person2.frieds); <span class=\"comment\">// [ &#x27;jack&#x27;, &#x27;zr&#x27; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.frieds === person2.frieds); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.job = job;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span>.sayName != <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">    Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> friend = <span class=\"keyword\">new</span> Person(<span class=\"string\">&#x27;Nick&#x27;</span>, <span class=\"number\">29</span>, <span class=\"string\">&#x27;Engineer&#x27;</span>);</span><br><span class=\"line\">friend.sayName();</span><br></pre></td></tr></table></figure>\n\n<p>这里只会在<code>sayName()</code>方法不存在的情况下，才会将它添加到原型中。</p>"},{"title":"31天JavaScript学习-第8天","reprint":false,"date":"2022-02-28T11:32:32.000Z","updated":"2022-02-28T11:32:32.000Z","conver":null,"_content":"\n# 面向对象（二）——继承\n\n<!--more-->\n\n在众多OO语言中支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于JS函数没有签名，无法实现接口继承，只能支持实现继承。\n\n## 原型链\n\n### 原型链实现继承\n\nES将原型链作为实现继承的主要方法。其基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。\n\n每个构造函数都有一个由prototype属性指向的原型对象，原型对象包含一个指向构造函数的指针constructor，而实例都包含一个指向原型的内部指针[[prototype]]。\n\n实现原型链有一种基本模式，代码如下：\n\n```js\nfunction SuperType() {\n  this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function() {\n  return this.property;\n};\n\nfunction SubType(){\n  this.subproperty = false;\n}\n\nSubType.prototype = new SuperType();\n\nSubType.prototype.getSubValue = function() {\n  return this.subproperty;\n};\n\nvar instance = new SubType();\nconsole.log(instance.getSuperValue());\n```\n\n这段代码的原型链图如下所示：\n\n![image-20220228210259817](31天JavaScript学习-第8天/image-20220228210259817.png)\n\n由于SubType的原型等于了SuperType的实例对象，等价于SubType的原型指向SuperType的原型。SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例附给SubType的原型实现的。换句话说，原来存在SupeType的实例中的属性和方法，现在也存在于SubType的原型中了。\n\n**别忘了默认的原型**\n\n所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。\n\n![image-20220228211923561](31天JavaScript学习-第8天/image-20220228211923561.png)\n\n**确定原型和实例的关系**\n\n- instanceof：实例与原型链中出现过的构造函数，结果就会返回true\n- isPrototypeOf：原型链中出现过的原型，都是该原型链所派生的实例的原型\n\n### 原型链的问题\n\n使用原型链实现继承最大的问题就是包含引用类型值的原型。\n\n```js\nfunction SuperType() {\n  this.color = ['red', 'green'];\n}\n\nfunction SubType() {\n}\n\nSubType.prototype = new SuperType();\n\nvar instance1 = new SubType();\ninstance1.color.push('black');\nconsole.log(instance1.color); // [ 'red', 'green', 'black' ]\n\nvar instance2 = new SubType();\nconsole.log(instance2.color); // [ 'red', 'green', 'black' ]\n```\n\nSubType的所有实例都会共享一个color属性，对instance1的修改能通过instance2反映出来。因此，实践中很少单独使用原型链。\n\n## 借用构造函数\n\n在子类型构造函数的内部调用超类型构造函数。\n\n```js\nfunction SuperType() {\n  this.color = ['red', 'green'];\n}\n\nfunction SubType() {\n  // 继承了SuperType\n  SuperType.call(this);\n}\n\nvar instance1 = new SubType();\ninstance1.color.push('black');\nconsole.log(instance1.color);\n\nvar instance2 = new SubType();\nconsole.log(instance2.color);\n```\n\nSubType的每个实例都会具有自己的color属性的副本。\n\n### 传递参数\n\n借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n}\n\nfunction SubType() {\n  SuperType.call(this, 'jack');\n  this.age = 29;\n}\n\nvar instance = new SubType();\nconsole.log(instance.name); // jack\nconsole.log(instance.age); // 29\n```\n\n但仅仅使用构造函数，也无法避免构造函数模式的问题——方法都在构造函数中定义，无法实现函数复用。\n\n## 组合继承\n\n使用原型链实现对原型属性和方法的继承，使用借用构造函数实现对实例属性的继承。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n  this.color = ['red', 'green'];\n}\n\nSuperType.prototype.sayName = function() {\n  // 继承属性\n  console.log(this.name);\n};\n\nfunction SubType(name, age){\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function() {\n  console.log(this.age);\n}\n\nvar instance1 = new SubType('jack', 20);\ninstance1.color.push('blue');\nconsole.log(instance1.color); // [ 'red', 'green', 'blue' ]\ninstance1.sayName(); // jack\ninstance1.sayAge(); // 20\n\nvar instance2 = new SubType('Greg', 24);\nconsole.log(instance2.color); // [ 'red', 'green' ]\ninstance2.sayName(); // Greg\ninstance2.sayAge(); // 24\n```\n\n组合式继承是JS中最常用的继承模式，而且，`instancof`和`isPrototypeOf()`也能够用于识别基于组合继承创建的对象。\n\n## 原型式继承\n\n该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用new操作符创建实例，并返回这个实例，本质是一个浅拷贝。\n\n```js\nfunction object(obj) {\n\tfunction F() {};\n\tF.prototype = obj;\n\treturn new F();\n}\n```\n\n例子如下：\n\n```js\nfunction object(obj) {\n\tfunction F() {};\n\tF.prototype = obj;\n\treturn new F();\n}\n\nvar person = {\n  name: 'jack',\n  friends: ['a1', 'a2']\n};\n\nvar anotherPerson = object(person);\nanotherPerson.name = 'Greg';\nanotherPerson.friends.push('b1');\n\nvar person3 = object(person);\nperson3.name = 'Linda';\nperson3.friends.push('c1');\n\nconsole.log(person.friends); // [ 'a1', 'a2', 'b1', 'c1' ]\n```\n\n当想让一个对象与另一个对象保持类似的情况下，原型式继承可以胜任，其中包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。\n\nES5使用`Object.create()`方法规范化了原型式继承。该方法接收两个参数：\n\n- 新对象原型的对象\n- （可选）为新对象定义额外属性的对象\n\n``` js\nvar person = {\n  name: 'jack',\n  friends: ['a1', 'a2']\n};\n\nvar anotherPerson = Object.create(person);\nanotherPerson.name = 'Greg';\nanotherPerson.friends.push('b1');\n\nvar person3 = Object.create(person, {\n  name: {\n    value: \"Linda\"\n  }\n});\n\nconsole.log(person.friends); // [ 'a1', 'a2', 'b1' ]\nconsole.log(person3.name); // \"Linda\"\n```\n\n\n\n## 寄生式继承\n\n```js\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n\nfunction createAnother(original) {\n  var clone = object(original);\n  clone.sayHi = function() {\n    console.log('hi');\n  };\n  return clone;\n}\n\nvar person = {\n  name: 'jack',\n  friends: ['Linda', 'Cook']\n};\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi();\n\n```\n\n使用寄生式继承来为对象添加函数，**会由于不能做到函数复用而降低效率**；**这一点与构造函数模式类似**。\n\n","source":"_posts/31天JavaScript学习-第8天.md","raw":"---\ntitle: 31天JavaScript学习-第8天\nreprint: false\ndate: 2022-02-28 19:32:32\nupdated: 2022-02-28 19:32:32\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# 面向对象（二）——继承\n\n<!--more-->\n\n在众多OO语言中支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于JS函数没有签名，无法实现接口继承，只能支持实现继承。\n\n## 原型链\n\n### 原型链实现继承\n\nES将原型链作为实现继承的主要方法。其基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。\n\n每个构造函数都有一个由prototype属性指向的原型对象，原型对象包含一个指向构造函数的指针constructor，而实例都包含一个指向原型的内部指针[[prototype]]。\n\n实现原型链有一种基本模式，代码如下：\n\n```js\nfunction SuperType() {\n  this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function() {\n  return this.property;\n};\n\nfunction SubType(){\n  this.subproperty = false;\n}\n\nSubType.prototype = new SuperType();\n\nSubType.prototype.getSubValue = function() {\n  return this.subproperty;\n};\n\nvar instance = new SubType();\nconsole.log(instance.getSuperValue());\n```\n\n这段代码的原型链图如下所示：\n\n![image-20220228210259817](31天JavaScript学习-第8天/image-20220228210259817.png)\n\n由于SubType的原型等于了SuperType的实例对象，等价于SubType的原型指向SuperType的原型。SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例附给SubType的原型实现的。换句话说，原来存在SupeType的实例中的属性和方法，现在也存在于SubType的原型中了。\n\n**别忘了默认的原型**\n\n所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。\n\n![image-20220228211923561](31天JavaScript学习-第8天/image-20220228211923561.png)\n\n**确定原型和实例的关系**\n\n- instanceof：实例与原型链中出现过的构造函数，结果就会返回true\n- isPrototypeOf：原型链中出现过的原型，都是该原型链所派生的实例的原型\n\n### 原型链的问题\n\n使用原型链实现继承最大的问题就是包含引用类型值的原型。\n\n```js\nfunction SuperType() {\n  this.color = ['red', 'green'];\n}\n\nfunction SubType() {\n}\n\nSubType.prototype = new SuperType();\n\nvar instance1 = new SubType();\ninstance1.color.push('black');\nconsole.log(instance1.color); // [ 'red', 'green', 'black' ]\n\nvar instance2 = new SubType();\nconsole.log(instance2.color); // [ 'red', 'green', 'black' ]\n```\n\nSubType的所有实例都会共享一个color属性，对instance1的修改能通过instance2反映出来。因此，实践中很少单独使用原型链。\n\n## 借用构造函数\n\n在子类型构造函数的内部调用超类型构造函数。\n\n```js\nfunction SuperType() {\n  this.color = ['red', 'green'];\n}\n\nfunction SubType() {\n  // 继承了SuperType\n  SuperType.call(this);\n}\n\nvar instance1 = new SubType();\ninstance1.color.push('black');\nconsole.log(instance1.color);\n\nvar instance2 = new SubType();\nconsole.log(instance2.color);\n```\n\nSubType的每个实例都会具有自己的color属性的副本。\n\n### 传递参数\n\n借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n}\n\nfunction SubType() {\n  SuperType.call(this, 'jack');\n  this.age = 29;\n}\n\nvar instance = new SubType();\nconsole.log(instance.name); // jack\nconsole.log(instance.age); // 29\n```\n\n但仅仅使用构造函数，也无法避免构造函数模式的问题——方法都在构造函数中定义，无法实现函数复用。\n\n## 组合继承\n\n使用原型链实现对原型属性和方法的继承，使用借用构造函数实现对实例属性的继承。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n  this.color = ['red', 'green'];\n}\n\nSuperType.prototype.sayName = function() {\n  // 继承属性\n  console.log(this.name);\n};\n\nfunction SubType(name, age){\n  SuperType.call(this, name);\n  this.age = age;\n}\n\n// 继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function() {\n  console.log(this.age);\n}\n\nvar instance1 = new SubType('jack', 20);\ninstance1.color.push('blue');\nconsole.log(instance1.color); // [ 'red', 'green', 'blue' ]\ninstance1.sayName(); // jack\ninstance1.sayAge(); // 20\n\nvar instance2 = new SubType('Greg', 24);\nconsole.log(instance2.color); // [ 'red', 'green' ]\ninstance2.sayName(); // Greg\ninstance2.sayAge(); // 24\n```\n\n组合式继承是JS中最常用的继承模式，而且，`instancof`和`isPrototypeOf()`也能够用于识别基于组合继承创建的对象。\n\n## 原型式继承\n\n该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用new操作符创建实例，并返回这个实例，本质是一个浅拷贝。\n\n```js\nfunction object(obj) {\n\tfunction F() {};\n\tF.prototype = obj;\n\treturn new F();\n}\n```\n\n例子如下：\n\n```js\nfunction object(obj) {\n\tfunction F() {};\n\tF.prototype = obj;\n\treturn new F();\n}\n\nvar person = {\n  name: 'jack',\n  friends: ['a1', 'a2']\n};\n\nvar anotherPerson = object(person);\nanotherPerson.name = 'Greg';\nanotherPerson.friends.push('b1');\n\nvar person3 = object(person);\nperson3.name = 'Linda';\nperson3.friends.push('c1');\n\nconsole.log(person.friends); // [ 'a1', 'a2', 'b1', 'c1' ]\n```\n\n当想让一个对象与另一个对象保持类似的情况下，原型式继承可以胜任，其中包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。\n\nES5使用`Object.create()`方法规范化了原型式继承。该方法接收两个参数：\n\n- 新对象原型的对象\n- （可选）为新对象定义额外属性的对象\n\n``` js\nvar person = {\n  name: 'jack',\n  friends: ['a1', 'a2']\n};\n\nvar anotherPerson = Object.create(person);\nanotherPerson.name = 'Greg';\nanotherPerson.friends.push('b1');\n\nvar person3 = Object.create(person, {\n  name: {\n    value: \"Linda\"\n  }\n});\n\nconsole.log(person.friends); // [ 'a1', 'a2', 'b1' ]\nconsole.log(person3.name); // \"Linda\"\n```\n\n\n\n## 寄生式继承\n\n```js\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n\nfunction createAnother(original) {\n  var clone = object(original);\n  clone.sayHi = function() {\n    console.log('hi');\n  };\n  return clone;\n}\n\nvar person = {\n  name: 'jack',\n  friends: ['Linda', 'Cook']\n};\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi();\n\n```\n\n使用寄生式继承来为对象添加函数，**会由于不能做到函数复用而降低效率**；**这一点与构造函数模式类似**。\n\n","slug":"31天JavaScript学习-第8天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2ab001d7owz4klrdifm","content":"<h1 id=\"面向对象（二）——继承\"><a href=\"#面向对象（二）——继承\" class=\"headerlink\" title=\"面向对象（二）——继承\"></a>面向对象（二）——继承</h1><span id=\"more\"></span>\n\n<p>在众多OO语言中支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于JS函数没有签名，无法实现接口继承，只能支持实现继承。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><h3 id=\"原型链实现继承\"><a href=\"#原型链实现继承\" class=\"headerlink\" title=\"原型链实现继承\"></a>原型链实现继承</h3><p>ES将原型链作为实现继承的主要方法。其基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p>每个构造函数都有一个由prototype属性指向的原型对象，原型对象包含一个指向构造函数的指针constructor，而实例都包含一个指向原型的内部指针[[prototype]]。</p>\n<p>实现原型链有一种基本模式，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.property;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.subproperty;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.getSuperValue());</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的原型链图如下所示：</p>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/02/28/7bfb6a04e4f3/image-20220228210259817.png\" alt=\"image-20220228210259817\" class=\"lazyload\"></p>\n<p>由于SubType的原型等于了SuperType的实例对象，等价于SubType的原型指向SuperType的原型。SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例附给SubType的原型实现的。换句话说，原来存在SupeType的实例中的属性和方法，现在也存在于SubType的原型中了。</p>\n<p><strong>别忘了默认的原型</strong></p>\n<p>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。</p>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/02/28/7bfb6a04e4f3/image-20220228211923561.png\" alt=\"image-20220228211923561\" class=\"lazyload\"></p>\n<p><strong>确定原型和实例的关系</strong></p>\n<ul>\n<li>instanceof：实例与原型链中出现过的构造函数，结果就会返回true</li>\n<li>isPrototypeOf：原型链中出现过的原型，都是该原型链所派生的实例的原型</li>\n</ul>\n<h3 id=\"原型链的问题\"><a href=\"#原型链的问题\" class=\"headerlink\" title=\"原型链的问题\"></a>原型链的问题</h3><p>使用原型链实现继承最大的问题就是包含引用类型值的原型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.color = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.color.push(<span class=\"string\">&#x27;black&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.color); <span class=\"comment\">// [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.color); <span class=\"comment\">// [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br></pre></td></tr></table></figure>\n\n<p>SubType的所有实例都会共享一个color属性，对instance1的修改能通过instance2反映出来。因此，实践中很少单独使用原型链。</p>\n<h2 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h2><p>在子类型构造函数的内部调用超类型构造函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.color = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 继承了SuperType</span></span><br><span class=\"line\">  SuperType.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.color.push(<span class=\"string\">&#x27;black&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.color);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.color);</span><br></pre></td></tr></table></figure>\n\n<p>SubType的每个实例都会具有自己的color属性的副本。</p>\n<h3 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h3><p>借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"built_in\">this</span>, <span class=\"string\">&#x27;jack&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.name); <span class=\"comment\">// jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.age); <span class=\"comment\">// 29</span></span><br></pre></td></tr></table></figure>\n\n<p>但仅仅使用构造函数，也无法避免构造函数模式的问题——方法都在构造函数中定义，无法实现函数复用。</p>\n<h2 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h2><p>使用原型链实现对原型属性和方法的继承，使用借用构造函数实现对实例属性的继承。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.color = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 继承属性</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承方法</span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\">SubType.prototype.constructor = SubType;</span><br><span class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">instance1.color.push(<span class=\"string\">&#x27;blue&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.color); <span class=\"comment\">// [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27; ]</span></span><br><span class=\"line\">instance1.sayName(); <span class=\"comment\">// jack</span></span><br><span class=\"line\">instance1.sayAge(); <span class=\"comment\">// 20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">&#x27;Greg&#x27;</span>, <span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.color); <span class=\"comment\">// [ &#x27;red&#x27;, &#x27;green&#x27; ]</span></span><br><span class=\"line\">instance2.sayName(); <span class=\"comment\">// Greg</span></span><br><span class=\"line\">instance2.sayAge(); <span class=\"comment\">// 24</span></span><br></pre></td></tr></table></figure>\n\n<p>组合式继承是JS中最常用的继承模式，而且，<code>instancof</code>和<code>isPrototypeOf()</code>也能够用于识别基于组合继承创建的对象。</p>\n<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2><p>该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用new操作符创建实例，并返回这个实例，本质是一个浅拷贝。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\tF.prototype = obj;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例子如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\tF.prototype = obj;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">friends</span>: [<span class=\"string\">&#x27;a1&#x27;</span>, <span class=\"string\">&#x27;a2&#x27;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherPerson = object(person);</span><br><span class=\"line\">anotherPerson.name = <span class=\"string\">&#x27;Greg&#x27;</span>;</span><br><span class=\"line\">anotherPerson.friends.push(<span class=\"string\">&#x27;b1&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person3 = object(person);</span><br><span class=\"line\">person3.name = <span class=\"string\">&#x27;Linda&#x27;</span>;</span><br><span class=\"line\">person3.friends.push(<span class=\"string\">&#x27;c1&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.friends); <span class=\"comment\">// [ &#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;b1&#x27;, &#x27;c1&#x27; ]</span></span><br></pre></td></tr></table></figure>\n\n<p>当想让一个对象与另一个对象保持类似的情况下，原型式继承可以胜任，其中包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>\n<p>ES5使用<code>Object.create()</code>方法规范化了原型式继承。该方法接收两个参数：</p>\n<ul>\n<li>新对象原型的对象</li>\n<li>（可选）为新对象定义额外属性的对象</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">friends</span>: [<span class=\"string\">&#x27;a1&#x27;</span>, <span class=\"string\">&#x27;a2&#x27;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherPerson = <span class=\"built_in\">Object</span>.create(person);</span><br><span class=\"line\">anotherPerson.name = <span class=\"string\">&#x27;Greg&#x27;</span>;</span><br><span class=\"line\">anotherPerson.friends.push(<span class=\"string\">&#x27;b1&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person3 = <span class=\"built_in\">Object</span>.create(person, &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"string\">&quot;Linda&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.friends); <span class=\"comment\">// [ &#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;b1&#x27; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person3.name); <span class=\"comment\">// &quot;Linda&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">original</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone = object(original);</span><br><span class=\"line\">  clone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hi&#x27;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">friends</span>: [<span class=\"string\">&#x27;Linda&#x27;</span>, <span class=\"string\">&#x27;Cook&#x27;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherPerson = createAnother(person);</span><br><span class=\"line\">anotherPerson.sayHi();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用寄生式继承来为对象添加函数，<strong>会由于不能做到函数复用而降低效率</strong>；<strong>这一点与构造函数模式类似</strong>。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"面向对象（二）——继承\"><a href=\"#面向对象（二）——继承\" class=\"headerlink\" title=\"面向对象（二）——继承\"></a>面向对象（二）——继承</h1>","more":"<p>在众多OO语言中支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于JS函数没有签名，无法实现接口继承，只能支持实现继承。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><h3 id=\"原型链实现继承\"><a href=\"#原型链实现继承\" class=\"headerlink\" title=\"原型链实现继承\"></a>原型链实现继承</h3><p>ES将原型链作为实现继承的主要方法。其基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p>每个构造函数都有一个由prototype属性指向的原型对象，原型对象包含一个指向构造函数的指针constructor，而实例都包含一个指向原型的内部指针[[prototype]]。</p>\n<p>实现原型链有一种基本模式，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.property;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.subproperty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.subproperty;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.getSuperValue());</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的原型链图如下所示：</p>\n<p><img src=\"/2022/02/28/7bfb6a04e4f3/image-20220228210259817.png\" alt=\"image-20220228210259817\"></p>\n<p>由于SubType的原型等于了SuperType的实例对象，等价于SubType的原型指向SuperType的原型。SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例附给SubType的原型实现的。换句话说，原来存在SupeType的实例中的属性和方法，现在也存在于SubType的原型中了。</p>\n<p><strong>别忘了默认的原型</strong></p>\n<p>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。</p>\n<p><img src=\"/2022/02/28/7bfb6a04e4f3/image-20220228211923561.png\" alt=\"image-20220228211923561\"></p>\n<p><strong>确定原型和实例的关系</strong></p>\n<ul>\n<li>instanceof：实例与原型链中出现过的构造函数，结果就会返回true</li>\n<li>isPrototypeOf：原型链中出现过的原型，都是该原型链所派生的实例的原型</li>\n</ul>\n<h3 id=\"原型链的问题\"><a href=\"#原型链的问题\" class=\"headerlink\" title=\"原型链的问题\"></a>原型链的问题</h3><p>使用原型链实现继承最大的问题就是包含引用类型值的原型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.color = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.color.push(<span class=\"string\">&#x27;black&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.color); <span class=\"comment\">// [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.color); <span class=\"comment\">// [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span></span><br></pre></td></tr></table></figure>\n\n<p>SubType的所有实例都会共享一个color属性，对instance1的修改能通过instance2反映出来。因此，实践中很少单独使用原型链。</p>\n<h2 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h2><p>在子类型构造函数的内部调用超类型构造函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.color = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 继承了SuperType</span></span><br><span class=\"line\">  SuperType.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.color.push(<span class=\"string\">&#x27;black&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.color);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.color);</span><br></pre></td></tr></table></figure>\n\n<p>SubType的每个实例都会具有自己的color属性的副本。</p>\n<h3 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h3><p>借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"built_in\">this</span>, <span class=\"string\">&#x27;jack&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.name); <span class=\"comment\">// jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance.age); <span class=\"comment\">// 29</span></span><br></pre></td></tr></table></figure>\n\n<p>但仅仅使用构造函数，也无法避免构造函数模式的问题——方法都在构造函数中定义，无法实现函数复用。</p>\n<h2 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h2><p>使用原型链实现对原型属性和方法的继承，使用借用构造函数实现对实例属性的继承。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.color = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 继承属性</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"built_in\">this</span>, name);</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承方法</span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\">SubType.prototype.constructor = SubType;</span><br><span class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">&#x27;jack&#x27;</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">instance1.color.push(<span class=\"string\">&#x27;blue&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.color); <span class=\"comment\">// [ &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27; ]</span></span><br><span class=\"line\">instance1.sayName(); <span class=\"comment\">// jack</span></span><br><span class=\"line\">instance1.sayAge(); <span class=\"comment\">// 20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">&#x27;Greg&#x27;</span>, <span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.color); <span class=\"comment\">// [ &#x27;red&#x27;, &#x27;green&#x27; ]</span></span><br><span class=\"line\">instance2.sayName(); <span class=\"comment\">// Greg</span></span><br><span class=\"line\">instance2.sayAge(); <span class=\"comment\">// 24</span></span><br></pre></td></tr></table></figure>\n\n<p>组合式继承是JS中最常用的继承模式，而且，<code>instancof</code>和<code>isPrototypeOf()</code>也能够用于识别基于组合继承创建的对象。</p>\n<h2 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h2><p>该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用new操作符创建实例，并返回这个实例，本质是一个浅拷贝。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\tF.prototype = obj;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例子如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\tF.prototype = obj;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">friends</span>: [<span class=\"string\">&#x27;a1&#x27;</span>, <span class=\"string\">&#x27;a2&#x27;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherPerson = object(person);</span><br><span class=\"line\">anotherPerson.name = <span class=\"string\">&#x27;Greg&#x27;</span>;</span><br><span class=\"line\">anotherPerson.friends.push(<span class=\"string\">&#x27;b1&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person3 = object(person);</span><br><span class=\"line\">person3.name = <span class=\"string\">&#x27;Linda&#x27;</span>;</span><br><span class=\"line\">person3.friends.push(<span class=\"string\">&#x27;c1&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.friends); <span class=\"comment\">// [ &#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;b1&#x27;, &#x27;c1&#x27; ]</span></span><br></pre></td></tr></table></figure>\n\n<p>当想让一个对象与另一个对象保持类似的情况下，原型式继承可以胜任，其中包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>\n<p>ES5使用<code>Object.create()</code>方法规范化了原型式继承。该方法接收两个参数：</p>\n<ul>\n<li>新对象原型的对象</li>\n<li>（可选）为新对象定义额外属性的对象</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">friends</span>: [<span class=\"string\">&#x27;a1&#x27;</span>, <span class=\"string\">&#x27;a2&#x27;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherPerson = <span class=\"built_in\">Object</span>.create(person);</span><br><span class=\"line\">anotherPerson.name = <span class=\"string\">&#x27;Greg&#x27;</span>;</span><br><span class=\"line\">anotherPerson.friends.push(<span class=\"string\">&#x27;b1&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person3 = <span class=\"built_in\">Object</span>.create(person, &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"string\">&quot;Linda&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.friends); <span class=\"comment\">// [ &#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;b1&#x27; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person3.name); <span class=\"comment\">// &quot;Linda&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = o;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">original</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone = object(original);</span><br><span class=\"line\">  clone.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hi&#x27;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;jack&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">friends</span>: [<span class=\"string\">&#x27;Linda&#x27;</span>, <span class=\"string\">&#x27;Cook&#x27;</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherPerson = createAnother(person);</span><br><span class=\"line\">anotherPerson.sayHi();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用寄生式继承来为对象添加函数，<strong>会由于不能做到函数复用而降低效率</strong>；<strong>这一点与构造函数模式类似</strong>。</p>"},{"title":"31天JavaScript学习-第9天","reprint":false,"date":"2022-03-02T11:39:40.000Z","updated":"2022-03-02T11:39:40.000Z","conver":null,"_content":"\n# 函数表达式（一）——闭包\n\n<!--more-->\n\n## 递归\n\n递归函数是在一个函数通过名字调用自身的情况下构成的，如前篇说过的阶乘函数：\n\n```js\nfunction factorial(num) {\n  if (num < 1) {\n    return 1;\n  } else {\n    return num * factorial(num - 1);\n  }\n}\n```\n\n这里在函数内调用自身函数名可以使用`arguments.callee`，指向正在执行函数的指针代替。\n\n但在严格模式下，不能通过脚本访问`arguments.callee`，可以使用**命名函数表达式**来达成同样效果。\n\n```js\nvar factorial = (function f(num) {\n  if (num < 1) {\n    return 1;\n  } else {\n    return num * f(num - 1);\n  }\n});\n```\n\n## 闭包\n\n闭包是指有权访问另一个函数作用域中的变量的函数。\n\nJS中变量的作用域无非两种，全局变量和局部变量。JS可以在函数内部直接读取全局变量。如何实现在全局作用域中访问到函数内的局部变量呢？就是使用JS作用域链的特性以达到该目的。\n\n个人理解JS的闭包的作用类似JAVA中的封装，数据使用private修饰符修饰类属性被保护在类的内部，尽可能隐藏内部细节，只保留外部接口getter、setter访问。不完全对，较为浅显。\n\n### 作用域链\n\n作用域里面嵌套作用域，就形成了作用域链。\n\n当某个函数被调用时，会创建一个执行环境（执行上下文）以及相应的作用域链。\n\n每个执行环境都有一个表示变量的对象——**变量对象**。一个新的执行环境的声明周期可以分为两个阶段。\n\n- **代码编译阶段**\n\n  在这个阶段中，执行环境会分别创建变量对象，建立作用域，以及确定this的指向。\n\n- **代码执行阶段**\n\n  创建完成之后，就会开始执行代码，这时会完成变量赋值，函数引用，以及执行其他代码。\n\n在函数执行过程中，为读取和写入变量的值，需要在作用域链中查找变量\n\n```js\nfunction compare(value1, value2) {\n  if (value1 > value2) {\n    return -1;\n  } else if (value1 > value2) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nvar result = compare(5, 10);\n```\n\n当调用compare函数时，会将其执行环境中的变量对象转化为活动对象，其作用域链如图\n\n![image-20220303154500631](31天JavaScript学习-第9天/image-20220303154500631.png)\n\n作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。\n\n### 变量对象\n\n变量对象的创建，依次经历以下步骤。\n\n1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n2. 检查当前上下文的函数声明，即用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。\n\n从上面的规则可以看出，function声明会比var声明优先级更高一点。\n\n下面用一个例子来理解变量对象（Variable Object, OV）的创建和活动对象（Activate Object, AO）的转化\n\n```js\nfunction test() {\n  console.log(a);\n  console.log(foo());\n\n  var a = 1;\n  function foo() {\n    return 2;\n  }\n}\n\ntest();\n```\n\n```js\n// 创建阶段\nVO = {\n\targuments: {...},\n \tfoo: <foo reference>, // foo地址引用\n\ta: undefined\n}\n```\n\n未进入执行阶段前，变量对象中的属性都不能访问。但进入执行阶段后，变量对象转变成了活动对象，里面的属性都能被访问了，然后开始进入执行阶段的操作。\n\n> Q：变量对象和活动对象的区别？\n>\n> A：它们都是同一个对象，只是处在执行的不同生命周期。\n\n```js\n// 执行阶段\n// VO -> AO\nAO = {\n  arguments: {...},\n  foo: <foo reference>,\n  a: 1\n}\n```\n\n此时，上面的例子，执行顺序就变成了这样\n\n```js\nfunction test() {\n  function foo() {\n    return 2;\n  }\n  var a;\n  console.log(a);\n  console.log(foo());\n  a = 1;\n}\n```\n\n\n\n#### 执行上下文\n\nJS中可执行的代码类型有三种：\n\n- **全局代码：**外部js文件或者本地标签内的代码，全局代码不包括function体内的代码。\n- **函数代码：**function体内的代码。\n- **eval代码：**eval()函数计算某个字符串，并执行其中的代码。\n\n当JS引擎遇到这三种代码，分为两个阶段，**代码编译阶段**和**代码执行阶段**。编译阶段由编译器完成，将代码编译成为可执行代码，这个阶段**作用域**规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，**执行上下文**在这个阶段创建。\n\n> JS引擎，不是逐条解释js代码，而是按照代码块一段段解释执行。所谓代码块是使用`<script>`标签分隔的代码段。\n>\n> 对于常见编译型语言（Java等），编译步骤为：词法分析->语法分析->语义检查->代码优化和字节生成\n>\n> 对于解释型语言（JavaScript等），通过词法分析和语法分析得到语法树后，就可以开始解释执行了。\n\n### 闭包的实现\n\n一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况有所不同。\n\n```js\nfunction player() {\n  var life = 3;\n  function lose_life() {\n    life--;\n    console.log(life);\n  }\n  return lose_life;\n}\n\nvar mario = player();\nmario(); // 2\n```\n\n这个例子中，函数lose_life被包括在函数player内部，player内部所有局部变量对lose_life都是可见的。既然如此，把lose_life作为返回值，就可以在player外部读取它的内部变量了。\n\n**闭包的用途**\n\n- 可以读取到函数内部的变量\n- 让函数内部的变量始终保持在内存中\n\n```js\nfunction player() {\n  var life = 3;\n  loss_life = function () {\n    life--;\n  }\n  function show_life() {\n    console.log(life);\n  }\n  return show_life;\n}\n\nvar mario = player();\nmario(); // 3\nloss_life();\nmario(); // 2\n```\n\n可以看到，player函数在运行一次后，局部变量life并没有被删除。原因是player是show_life的父函数，而show_life被赋给了一个全局变量mario，这导致show_life始终在内存中，而show_life的存在依赖于player，因此player也是种在内存中，不会在调用结束后，被垃圾回收机制删除。\n\n### 闭包与作用域链\n\n```js\nfunction createComparisonFunc(propertyName) {\n  return function (obj1, obj2) {\n    var value1 = obj1[propertyName];\n    var value2 = obj2[propertyName];\n\n    if (value1 > value2) {\n      return -1;\n    } else if (value1 < value2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\n\nvar compare = createComparisonFunc('name');\nvar result = compare({name: 'Nick'}, {name: 'Jack'});\ncompare = null; // 解除对匿名函数的引用（释放内存）\n```\n\n当`createComparisonFunc()`函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，`createComparisonFunc()`的活动对象才会被销毁。\n\n### 使用闭包的注意点\n\n由于闭包会使得函数中的变量始终被保存在内存中，所以不能滥用闭包，否则会出现性能问题。解决方法是，在推出函数之前，将不使用的局部变量全部删除。\n\n闭包会在父函数外部，改变父函数内部变量的值。如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便更改父函数内部变量的值。\n","source":"_posts/31天JavaScript学习-第9天.md","raw":"---\ntitle: 31天JavaScript学习-第9天\nreprint: false\ndate: 2022-03-02 19:39:40\nupdated: 2022-03-02 19:39:40\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# 函数表达式（一）——闭包\n\n<!--more-->\n\n## 递归\n\n递归函数是在一个函数通过名字调用自身的情况下构成的，如前篇说过的阶乘函数：\n\n```js\nfunction factorial(num) {\n  if (num < 1) {\n    return 1;\n  } else {\n    return num * factorial(num - 1);\n  }\n}\n```\n\n这里在函数内调用自身函数名可以使用`arguments.callee`，指向正在执行函数的指针代替。\n\n但在严格模式下，不能通过脚本访问`arguments.callee`，可以使用**命名函数表达式**来达成同样效果。\n\n```js\nvar factorial = (function f(num) {\n  if (num < 1) {\n    return 1;\n  } else {\n    return num * f(num - 1);\n  }\n});\n```\n\n## 闭包\n\n闭包是指有权访问另一个函数作用域中的变量的函数。\n\nJS中变量的作用域无非两种，全局变量和局部变量。JS可以在函数内部直接读取全局变量。如何实现在全局作用域中访问到函数内的局部变量呢？就是使用JS作用域链的特性以达到该目的。\n\n个人理解JS的闭包的作用类似JAVA中的封装，数据使用private修饰符修饰类属性被保护在类的内部，尽可能隐藏内部细节，只保留外部接口getter、setter访问。不完全对，较为浅显。\n\n### 作用域链\n\n作用域里面嵌套作用域，就形成了作用域链。\n\n当某个函数被调用时，会创建一个执行环境（执行上下文）以及相应的作用域链。\n\n每个执行环境都有一个表示变量的对象——**变量对象**。一个新的执行环境的声明周期可以分为两个阶段。\n\n- **代码编译阶段**\n\n  在这个阶段中，执行环境会分别创建变量对象，建立作用域，以及确定this的指向。\n\n- **代码执行阶段**\n\n  创建完成之后，就会开始执行代码，这时会完成变量赋值，函数引用，以及执行其他代码。\n\n在函数执行过程中，为读取和写入变量的值，需要在作用域链中查找变量\n\n```js\nfunction compare(value1, value2) {\n  if (value1 > value2) {\n    return -1;\n  } else if (value1 > value2) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nvar result = compare(5, 10);\n```\n\n当调用compare函数时，会将其执行环境中的变量对象转化为活动对象，其作用域链如图\n\n![image-20220303154500631](31天JavaScript学习-第9天/image-20220303154500631.png)\n\n作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。\n\n### 变量对象\n\n变量对象的创建，依次经历以下步骤。\n\n1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n2. 检查当前上下文的函数声明，即用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。\n\n从上面的规则可以看出，function声明会比var声明优先级更高一点。\n\n下面用一个例子来理解变量对象（Variable Object, OV）的创建和活动对象（Activate Object, AO）的转化\n\n```js\nfunction test() {\n  console.log(a);\n  console.log(foo());\n\n  var a = 1;\n  function foo() {\n    return 2;\n  }\n}\n\ntest();\n```\n\n```js\n// 创建阶段\nVO = {\n\targuments: {...},\n \tfoo: <foo reference>, // foo地址引用\n\ta: undefined\n}\n```\n\n未进入执行阶段前，变量对象中的属性都不能访问。但进入执行阶段后，变量对象转变成了活动对象，里面的属性都能被访问了，然后开始进入执行阶段的操作。\n\n> Q：变量对象和活动对象的区别？\n>\n> A：它们都是同一个对象，只是处在执行的不同生命周期。\n\n```js\n// 执行阶段\n// VO -> AO\nAO = {\n  arguments: {...},\n  foo: <foo reference>,\n  a: 1\n}\n```\n\n此时，上面的例子，执行顺序就变成了这样\n\n```js\nfunction test() {\n  function foo() {\n    return 2;\n  }\n  var a;\n  console.log(a);\n  console.log(foo());\n  a = 1;\n}\n```\n\n\n\n#### 执行上下文\n\nJS中可执行的代码类型有三种：\n\n- **全局代码：**外部js文件或者本地标签内的代码，全局代码不包括function体内的代码。\n- **函数代码：**function体内的代码。\n- **eval代码：**eval()函数计算某个字符串，并执行其中的代码。\n\n当JS引擎遇到这三种代码，分为两个阶段，**代码编译阶段**和**代码执行阶段**。编译阶段由编译器完成，将代码编译成为可执行代码，这个阶段**作用域**规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，**执行上下文**在这个阶段创建。\n\n> JS引擎，不是逐条解释js代码，而是按照代码块一段段解释执行。所谓代码块是使用`<script>`标签分隔的代码段。\n>\n> 对于常见编译型语言（Java等），编译步骤为：词法分析->语法分析->语义检查->代码优化和字节生成\n>\n> 对于解释型语言（JavaScript等），通过词法分析和语法分析得到语法树后，就可以开始解释执行了。\n\n### 闭包的实现\n\n一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况有所不同。\n\n```js\nfunction player() {\n  var life = 3;\n  function lose_life() {\n    life--;\n    console.log(life);\n  }\n  return lose_life;\n}\n\nvar mario = player();\nmario(); // 2\n```\n\n这个例子中，函数lose_life被包括在函数player内部，player内部所有局部变量对lose_life都是可见的。既然如此，把lose_life作为返回值，就可以在player外部读取它的内部变量了。\n\n**闭包的用途**\n\n- 可以读取到函数内部的变量\n- 让函数内部的变量始终保持在内存中\n\n```js\nfunction player() {\n  var life = 3;\n  loss_life = function () {\n    life--;\n  }\n  function show_life() {\n    console.log(life);\n  }\n  return show_life;\n}\n\nvar mario = player();\nmario(); // 3\nloss_life();\nmario(); // 2\n```\n\n可以看到，player函数在运行一次后，局部变量life并没有被删除。原因是player是show_life的父函数，而show_life被赋给了一个全局变量mario，这导致show_life始终在内存中，而show_life的存在依赖于player，因此player也是种在内存中，不会在调用结束后，被垃圾回收机制删除。\n\n### 闭包与作用域链\n\n```js\nfunction createComparisonFunc(propertyName) {\n  return function (obj1, obj2) {\n    var value1 = obj1[propertyName];\n    var value2 = obj2[propertyName];\n\n    if (value1 > value2) {\n      return -1;\n    } else if (value1 < value2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\n\nvar compare = createComparisonFunc('name');\nvar result = compare({name: 'Nick'}, {name: 'Jack'});\ncompare = null; // 解除对匿名函数的引用（释放内存）\n```\n\n当`createComparisonFunc()`函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，`createComparisonFunc()`的活动对象才会被销毁。\n\n### 使用闭包的注意点\n\n由于闭包会使得函数中的变量始终被保存在内存中，所以不能滥用闭包，否则会出现性能问题。解决方法是，在推出函数之前，将不使用的局部变量全部删除。\n\n闭包会在父函数外部，改变父函数内部变量的值。如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便更改父函数内部变量的值。\n","slug":"31天JavaScript学习-第9天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2ab001g7owz4qk5h7uq","content":"<h1 id=\"函数表达式（一）——闭包\"><a href=\"#函数表达式（一）——闭包\" class=\"headerlink\" title=\"函数表达式（一）——闭包\"></a>函数表达式（一）——闭包</h1><span id=\"more\"></span>\n\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身的情况下构成的，如前篇说过的阶乘函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * factorial(num - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里在函数内调用自身函数名可以使用<code>arguments.callee</code>，指向正在执行函数的指针代替。</p>\n<p>但在严格模式下，不能通过脚本访问<code>arguments.callee</code>，可以使用<strong>命名函数表达式</strong>来达成同样效果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factorial = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * f(num - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>\n<p>JS中变量的作用域无非两种，全局变量和局部变量。JS可以在函数内部直接读取全局变量。如何实现在全局作用域中访问到函数内的局部变量呢？就是使用JS作用域链的特性以达到该目的。</p>\n<p>个人理解JS的闭包的作用类似JAVA中的封装，数据使用private修饰符修饰类属性被保护在类的内部，尽可能隐藏内部细节，只保留外部接口getter、setter访问。不完全对，较为浅显。</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>作用域里面嵌套作用域，就形成了作用域链。</p>\n<p>当某个函数被调用时，会创建一个执行环境（执行上下文）以及相应的作用域链。</p>\n<p>每个执行环境都有一个表示变量的对象——<strong>变量对象</strong>。一个新的执行环境的声明周期可以分为两个阶段。</p>\n<ul>\n<li><p><strong>代码编译阶段</strong></p>\n<p>在这个阶段中，执行环境会分别创建变量对象，建立作用域，以及确定this的指向。</p>\n</li>\n<li><p><strong>代码执行阶段</strong></p>\n<p>创建完成之后，就会开始执行代码，这时会完成变量赋值，函数引用，以及执行其他代码。</p>\n</li>\n</ul>\n<p>在函数执行过程中，为读取和写入变量的值，需要在作用域链中查找变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = compare(<span class=\"number\">5</span>, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当调用compare函数时，会将其执行环境中的变量对象转化为活动对象，其作用域链如图</p>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/03/02/b4aa5ee2478d/image-20220303154500631.png\" alt=\"image-20220303154500631\" class=\"lazyload\"></p>\n<p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p>\n<h3 id=\"变量对象\"><a href=\"#变量对象\" class=\"headerlink\" title=\"变量对象\"></a>变量对象</h3><p>变量对象的创建，依次经历以下步骤。</p>\n<ol>\n<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>\n<li>检查当前上下文的函数声明，即用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</li>\n</ol>\n<p>从上面的规则可以看出，function声明会比var声明优先级更高一点。</p>\n<p>下面用一个例子来理解变量对象（Variable Object, OV）的创建和活动对象（Activate Object, AO）的转化</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(foo());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建阶段</span></span><br><span class=\"line\">VO = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">arguments</span>: &#123;...&#125;,</span><br><span class=\"line\"> \t<span class=\"attr\">foo</span>: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">reference</span>&gt;</span>, // foo地址引用</span></span><br><span class=\"line\"><span class=\"xml\">\ta: undefined</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>未进入执行阶段前，变量对象中的属性都不能访问。但进入执行阶段后，变量对象转变成了活动对象，里面的属性都能被访问了，然后开始进入执行阶段的操作。</p>\n<blockquote>\n<p>Q：变量对象和活动对象的区别？</p>\n<p>A：它们都是同一个对象，只是处在执行的不同生命周期。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\"><span class=\"comment\">// VO -&gt; AO</span></span><br><span class=\"line\">AO = &#123;</span><br><span class=\"line\">  <span class=\"attr\">arguments</span>: &#123;...&#125;,</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">reference</span>&gt;</span>,</span></span><br><span class=\"line\"><span class=\"xml\">  a: 1</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时，上面的例子，执行顺序就变成了这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(foo());</span><br><span class=\"line\">  a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h4><p>JS中可执行的代码类型有三种：</p>\n<ul>\n<li><strong>全局代码：</strong>外部js文件或者本地标签内的代码，全局代码不包括function体内的代码。</li>\n<li><strong>函数代码：</strong>function体内的代码。</li>\n<li><strong>eval代码：</strong>eval()函数计算某个字符串，并执行其中的代码。</li>\n</ul>\n<p>当JS引擎遇到这三种代码，分为两个阶段，<strong>代码编译阶段</strong>和<strong>代码执行阶段</strong>。编译阶段由编译器完成，将代码编译成为可执行代码，这个阶段<strong>作用域</strong>规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，<strong>执行上下文</strong>在这个阶段创建。</p>\n<blockquote>\n<p>JS引擎，不是逐条解释js代码，而是按照代码块一段段解释执行。所谓代码块是使用<code>&lt;script&gt;</code>标签分隔的代码段。</p>\n<p>对于常见编译型语言（Java等），编译步骤为：词法分析-&gt;语法分析-&gt;语义检查-&gt;代码优化和字节生成</p>\n<p>对于解释型语言（JavaScript等），通过词法分析和语法分析得到语法树后，就可以开始解释执行了。</p>\n</blockquote>\n<h3 id=\"闭包的实现\"><a href=\"#闭包的实现\" class=\"headerlink\" title=\"闭包的实现\"></a>闭包的实现</h3><p>一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况有所不同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">player</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> life = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lose_life</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    life--;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(life);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> lose_life;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mario = player();</span><br><span class=\"line\">mario(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>这个例子中，函数lose_life被包括在函数player内部，player内部所有局部变量对lose_life都是可见的。既然如此，把lose_life作为返回值，就可以在player外部读取它的内部变量了。</p>\n<p><strong>闭包的用途</strong></p>\n<ul>\n<li>可以读取到函数内部的变量</li>\n<li>让函数内部的变量始终保持在内存中</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">player</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> life = <span class=\"number\">3</span>;</span><br><span class=\"line\">  loss_life = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    life--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show_life</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(life);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> show_life;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mario = player();</span><br><span class=\"line\">mario(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">loss_life();</span><br><span class=\"line\">mario(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，player函数在运行一次后，局部变量life并没有被删除。原因是player是show_life的父函数，而show_life被赋给了一个全局变量mario，这导致show_life始终在内存中，而show_life的存在依赖于player，因此player也是种在内存中，不会在调用结束后，被垃圾回收机制删除。</p>\n<h3 id=\"闭包与作用域链\"><a href=\"#闭包与作用域链\" class=\"headerlink\" title=\"闭包与作用域链\"></a>闭包与作用域链</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createComparisonFunc</span>(<span class=\"params\">propertyName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj1, obj2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value1 = obj1[propertyName];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value2 = obj2[propertyName];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> compare = createComparisonFunc(<span class=\"string\">&#x27;name&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = compare(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Nick&#x27;</span>&#125;, &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Jack&#x27;</span>&#125;);</span><br><span class=\"line\">compare = <span class=\"literal\">null</span>; <span class=\"comment\">// 解除对匿名函数的引用（释放内存）</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>createComparisonFunc()</code>函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，<code>createComparisonFunc()</code>的活动对象才会被销毁。</p>\n<h3 id=\"使用闭包的注意点\"><a href=\"#使用闭包的注意点\" class=\"headerlink\" title=\"使用闭包的注意点\"></a>使用闭包的注意点</h3><p>由于闭包会使得函数中的变量始终被保存在内存中，所以不能滥用闭包，否则会出现性能问题。解决方法是，在推出函数之前，将不使用的局部变量全部删除。</p>\n<p>闭包会在父函数外部，改变父函数内部变量的值。如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便更改父函数内部变量的值。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"函数表达式（一）——闭包\"><a href=\"#函数表达式（一）——闭包\" class=\"headerlink\" title=\"函数表达式（一）——闭包\"></a>函数表达式（一）——闭包</h1>","more":"<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身的情况下构成的，如前篇说过的阶乘函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * factorial(num - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里在函数内调用自身函数名可以使用<code>arguments.callee</code>，指向正在执行函数的指针代替。</p>\n<p>但在严格模式下，不能通过脚本访问<code>arguments.callee</code>，可以使用<strong>命名函数表达式</strong>来达成同样效果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factorial = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * f(num - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>\n<p>JS中变量的作用域无非两种，全局变量和局部变量。JS可以在函数内部直接读取全局变量。如何实现在全局作用域中访问到函数内的局部变量呢？就是使用JS作用域链的特性以达到该目的。</p>\n<p>个人理解JS的闭包的作用类似JAVA中的封装，数据使用private修饰符修饰类属性被保护在类的内部，尽可能隐藏内部细节，只保留外部接口getter、setter访问。不完全对，较为浅显。</p>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>作用域里面嵌套作用域，就形成了作用域链。</p>\n<p>当某个函数被调用时，会创建一个执行环境（执行上下文）以及相应的作用域链。</p>\n<p>每个执行环境都有一个表示变量的对象——<strong>变量对象</strong>。一个新的执行环境的声明周期可以分为两个阶段。</p>\n<ul>\n<li><p><strong>代码编译阶段</strong></p>\n<p>在这个阶段中，执行环境会分别创建变量对象，建立作用域，以及确定this的指向。</p>\n</li>\n<li><p><strong>代码执行阶段</strong></p>\n<p>创建完成之后，就会开始执行代码，这时会完成变量赋值，函数引用，以及执行其他代码。</p>\n</li>\n</ul>\n<p>在函数执行过程中，为读取和写入变量的值，需要在作用域链中查找变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = compare(<span class=\"number\">5</span>, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当调用compare函数时，会将其执行环境中的变量对象转化为活动对象，其作用域链如图</p>\n<p><img src=\"/2022/03/02/b4aa5ee2478d/image-20220303154500631.png\" alt=\"image-20220303154500631\"></p>\n<p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p>\n<h3 id=\"变量对象\"><a href=\"#变量对象\" class=\"headerlink\" title=\"变量对象\"></a>变量对象</h3><p>变量对象的创建，依次经历以下步骤。</p>\n<ol>\n<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>\n<li>检查当前上下文的函数声明，即用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</li>\n</ol>\n<p>从上面的规则可以看出，function声明会比var声明优先级更高一点。</p>\n<p>下面用一个例子来理解变量对象（Variable Object, OV）的创建和活动对象（Activate Object, AO）的转化</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(foo());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建阶段</span></span><br><span class=\"line\">VO = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">arguments</span>: &#123;...&#125;,</span><br><span class=\"line\"> \t<span class=\"attr\">foo</span>: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">reference</span>&gt;</span>, // foo地址引用</span></span><br><span class=\"line\"><span class=\"xml\">\ta: undefined</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>未进入执行阶段前，变量对象中的属性都不能访问。但进入执行阶段后，变量对象转变成了活动对象，里面的属性都能被访问了，然后开始进入执行阶段的操作。</p>\n<blockquote>\n<p>Q：变量对象和活动对象的区别？</p>\n<p>A：它们都是同一个对象，只是处在执行的不同生命周期。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\"><span class=\"comment\">// VO -&gt; AO</span></span><br><span class=\"line\">AO = &#123;</span><br><span class=\"line\">  <span class=\"attr\">arguments</span>: &#123;...&#125;,</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">reference</span>&gt;</span>,</span></span><br><span class=\"line\"><span class=\"xml\">  a: 1</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时，上面的例子，执行顺序就变成了这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(foo());</span><br><span class=\"line\">  a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h4><p>JS中可执行的代码类型有三种：</p>\n<ul>\n<li><strong>全局代码：</strong>外部js文件或者本地标签内的代码，全局代码不包括function体内的代码。</li>\n<li><strong>函数代码：</strong>function体内的代码。</li>\n<li><strong>eval代码：</strong>eval()函数计算某个字符串，并执行其中的代码。</li>\n</ul>\n<p>当JS引擎遇到这三种代码，分为两个阶段，<strong>代码编译阶段</strong>和<strong>代码执行阶段</strong>。编译阶段由编译器完成，将代码编译成为可执行代码，这个阶段<strong>作用域</strong>规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，<strong>执行上下文</strong>在这个阶段创建。</p>\n<blockquote>\n<p>JS引擎，不是逐条解释js代码，而是按照代码块一段段解释执行。所谓代码块是使用<code>&lt;script&gt;</code>标签分隔的代码段。</p>\n<p>对于常见编译型语言（Java等），编译步骤为：词法分析-&gt;语法分析-&gt;语义检查-&gt;代码优化和字节生成</p>\n<p>对于解释型语言（JavaScript等），通过词法分析和语法分析得到语法树后，就可以开始解释执行了。</p>\n</blockquote>\n<h3 id=\"闭包的实现\"><a href=\"#闭包的实现\" class=\"headerlink\" title=\"闭包的实现\"></a>闭包的实现</h3><p>一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况有所不同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">player</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> life = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lose_life</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    life--;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(life);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> lose_life;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mario = player();</span><br><span class=\"line\">mario(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>这个例子中，函数lose_life被包括在函数player内部，player内部所有局部变量对lose_life都是可见的。既然如此，把lose_life作为返回值，就可以在player外部读取它的内部变量了。</p>\n<p><strong>闭包的用途</strong></p>\n<ul>\n<li>可以读取到函数内部的变量</li>\n<li>让函数内部的变量始终保持在内存中</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">player</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> life = <span class=\"number\">3</span>;</span><br><span class=\"line\">  loss_life = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    life--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show_life</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(life);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> show_life;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mario = player();</span><br><span class=\"line\">mario(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">loss_life();</span><br><span class=\"line\">mario(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，player函数在运行一次后，局部变量life并没有被删除。原因是player是show_life的父函数，而show_life被赋给了一个全局变量mario，这导致show_life始终在内存中，而show_life的存在依赖于player，因此player也是种在内存中，不会在调用结束后，被垃圾回收机制删除。</p>\n<h3 id=\"闭包与作用域链\"><a href=\"#闭包与作用域链\" class=\"headerlink\" title=\"闭包与作用域链\"></a>闭包与作用域链</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createComparisonFunc</span>(<span class=\"params\">propertyName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj1, obj2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value1 = obj1[propertyName];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value2 = obj2[propertyName];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> compare = createComparisonFunc(<span class=\"string\">&#x27;name&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = compare(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Nick&#x27;</span>&#125;, &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Jack&#x27;</span>&#125;);</span><br><span class=\"line\">compare = <span class=\"literal\">null</span>; <span class=\"comment\">// 解除对匿名函数的引用（释放内存）</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>createComparisonFunc()</code>函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，<code>createComparisonFunc()</code>的活动对象才会被销毁。</p>\n<h3 id=\"使用闭包的注意点\"><a href=\"#使用闭包的注意点\" class=\"headerlink\" title=\"使用闭包的注意点\"></a>使用闭包的注意点</h3><p>由于闭包会使得函数中的变量始终被保存在内存中，所以不能滥用闭包，否则会出现性能问题。解决方法是，在推出函数之前，将不使用的局部变量全部删除。</p>\n<p>闭包会在父函数外部，改变父函数内部变量的值。如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便更改父函数内部变量的值。</p>"},{"title":"31天Javascript学习-第1天","reprint":false,"date":"2022-02-19T11:54:00.000Z","updated":"2022-02-19T11:54:00.000Z","conver":null,"_content":"\n# day01-JS的基本语法和数据类型\n\n<!--more-->\n\n## Javascript的特点\n\n### 解释性语言\n\n**解释型语言**的意思是：程序执行之前，不需要事先被翻译为机器码；而是在运行时，边翻译边执行（翻译一行，执行一行）。\n\n### 单线程\n\nJavascript作为浏览器脚本语言，主要用途是与用户互动、操作DOM等，这决定了它只能是单线程。\n\n单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。但js 引擎执行异步代码而不用等待，是因有为有 消息队列和事件循环。\n\nNodeJS是单线程异步非阻塞模式，只有js执行是单线程，I/O交给libuv，是其他线程。[nodejs真的是单线程吗？ - 小小鸟儿！ - 博客园 (cnblogs.com)](https://www.cnblogs.com/wxmdevelop/p/10234556.html)\n\n## Javascript的基本语法\n\n### HTML对JS的三种引用方式\n\n**方式1：行内式**\n\n```html\n<input type=\"button\" value=\"点我点我\" onclick=\"alert('hello world')\" />\n```\n\n**方式2：内嵌式**\n\n使用`<script>`元素，只需指定type属性\n\n```html\n<script type=\"text/javascript\">\n            // 在这里写 js 代码\n            alert('hello world');\n            console.log('hello world');\n</script>\n```\n\n**方式3：外链式**\n\n使用`<script>`元素，需指定src属性\n\n```html\n<script src=\"utils.js\"></script>\n```\n\nJS代码写在<body>中，准确来说是在页面标签元素后，body结束标签前。\n\n## 区分大小写\n\n## 标识符\n\n标识符指变量、函数、属性的名字，或者函数的参数。\n\n- 标识符第一个字符必须是一个字母、下划线或$\n- 其他字符可以是字母、下划线、$或数字\n\n按照惯例，ECMAScript标识符采用驼峰大小写格式，第一个字母小写，剩下每个单词的首字母大写。\n\n## 严格模式\n\n在js代码顶部添加`\"use strict\";`\n\n# 变量\n\nJS的变量是松散类型的，不需要指定变量类型。如`var message;`使用var声明的变量作用域为该语句所在的函数内，存在变量提升现象。\n\nES6新增关键字let。使用let声明的变量作用域为该语句所在的代码块内，不存在变量提升。且let不允许在相同的作用域内，重复声明同一个变量。\n\n# 数据类型\n\n共有5种简单数据类型：Undefined、Null、Boolean、Number、String\n\n1种复杂数据类型Object，Object本质由一组无序的键值对组成的。\n\n## typeof操作符\n\n使用typeof操作符可返回变量的数据类型\n\n注意：typeof是一个操作符而不是函数，因此可以使用圆括号也可以不使用\n\n## 简单（基本）数据类型\n\n### Undefined\n\nUndefined类型只有一个值，即特殊的undefined。\n\n对未初始化的变量执行typeof会返回undefined，而对未声明的变量执行typeof同样返回undefined\n\n```js\nvar message;\nalert(typeof message); // 'undefined'\nalert(typeof age); // 'undefined'\n```\n\n因此，保持变量显式的初始化是一个良好的编码习惯。\n\n### Null\n\nNull类型只有一个值，即特殊的null。null值表示一个空对象指针，正因此使用typeof检测null值时会返回'object'类型。\n\n如果定义的变量在将来用于保存对象，最好将该变量初始化为null。实际上，undefined值是派生自null值的，因此`null == undefined`返回值是true。\n\n### Boolean\n\nBoolean类型有两个值，true和false。各种数据类型与Boolean类型的转换如下\n\n| 数据类型  | 转换为true的值               | 转换为false的值 |\n| --------- | ---------------------------- | --------------- |\n| Boolean   | true                         | false           |\n| String    | 任何非空字符串               | \"\"（空字符串）  |\n| Number    | 任何非零数字值（包括无穷大） | 0和Nan          |\n| Object    | 任何对象                     | null            |\n| Undefined | n/a(N/A)                     | undefined       |\n\n### Number\n\nNumber类型用来表示整数和浮点数值。\n\n#### 整数\n\n除十进制外，整数还可以以八进制和十六进制的字面值来表示\n\n```\nvar octalNum1 = 070; // 八进制56\nvar octalNum2 = 079; // 无效的八进制，解析为79\nvar hexNum1 = 0xA; // 十六进制的10\nvar hexNum2 = 0x2f; // 十六进制的31\n```\n\n#### 浮点数\n\nJS浮点数值的最高精度是17位小数。\n\nJS会将某些浮点数值转换为整数值，如1.0，1.。\n\n对于极大极小值，可以用e表示法，如\n\n```js\nvar floatNum = 3.124e7;\n```\n\n#### Nan\n\nNan（Not a Number）是一个特殊的数值。\n\n- 任何涉及Nan的操作都会返回Nan\n- Nan和任何值都不相等\n\n#### 数值转换\n\nNumber()、parseInt()、parseFloat()\n\n### String\n\nJS的字符串是不可变的，字符串一旦创建，值不能改变。\n\n数值、布尔值、对象和字符串值有toString()方法，null、undefined值没有这个方法。\n\n也可使使用转型函数String()。\n\n## Object\n\nJS中的对象是一组数据和功能的集合。\n\n`var o = new Object();`\n\nObject的每个实例有下列属性和方法：\n\n**constructor：**保存着用于创建当前对象的函数\n\n**hasOwnProperty(propertyName)：**用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。\n\n**isPrototypeOf(object)：**用于检查传入的对象是否是当前对象的原型。\n\n**propertyIsEnumerable(propertyName)：**用于检查给定的属性是否能够使用for-in语句来枚举。\n\n**toLocaleString()：**返回对象的字符串表示，该字符串与执行环境的地区对应。\n\n**toString()：**返回对象的字符串表示。\n\n**valueOf()：**返回对象的字符串、数值或布尔值表示。\n\n# 操作符\n\n一组用于操作数据值的操作符，包括算术操作符、位操作符、关系操作符和相等操作符。\n\n## 一元操作符\n\n一元操作符只能操作一个值。\n\n- 递增递减操作符 ++ --\n- 一元加和减操作符 + -\n- 位操作符\n  - 按位非 ~\n  - 按位与 &\n  - 按位或 |\n  - 按位异或 ^\n  - 左移 <<\n  - 有符号的右移 >>\n  - 无符号的右移 >>>\n- 布尔操作符\n  - 逻辑非 !\n  - 逻辑与 &&\n  - 逻辑或 ||\n- 乘性操作符 * /\n- 加性操作符 + -\n- 关系操作符 < > <= >=\n- 相等操作符\n  - 相等和不相等 `==` `!=`\n  - 全等和不全等 `===` `!==`\n- 条件操作符 expression ? true : false\n- 赋值操作符 =\n\n","source":"_posts/31天Javascript学习-第1天.md","raw":"---\ntitle: 31天Javascript学习-第1天\nreprint: false\ndate: 2022-02-19 19:54:00\nupdated: 2022-02-19 19:54:00\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# day01-JS的基本语法和数据类型\n\n<!--more-->\n\n## Javascript的特点\n\n### 解释性语言\n\n**解释型语言**的意思是：程序执行之前，不需要事先被翻译为机器码；而是在运行时，边翻译边执行（翻译一行，执行一行）。\n\n### 单线程\n\nJavascript作为浏览器脚本语言，主要用途是与用户互动、操作DOM等，这决定了它只能是单线程。\n\n单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。但js 引擎执行异步代码而不用等待，是因有为有 消息队列和事件循环。\n\nNodeJS是单线程异步非阻塞模式，只有js执行是单线程，I/O交给libuv，是其他线程。[nodejs真的是单线程吗？ - 小小鸟儿！ - 博客园 (cnblogs.com)](https://www.cnblogs.com/wxmdevelop/p/10234556.html)\n\n## Javascript的基本语法\n\n### HTML对JS的三种引用方式\n\n**方式1：行内式**\n\n```html\n<input type=\"button\" value=\"点我点我\" onclick=\"alert('hello world')\" />\n```\n\n**方式2：内嵌式**\n\n使用`<script>`元素，只需指定type属性\n\n```html\n<script type=\"text/javascript\">\n            // 在这里写 js 代码\n            alert('hello world');\n            console.log('hello world');\n</script>\n```\n\n**方式3：外链式**\n\n使用`<script>`元素，需指定src属性\n\n```html\n<script src=\"utils.js\"></script>\n```\n\nJS代码写在<body>中，准确来说是在页面标签元素后，body结束标签前。\n\n## 区分大小写\n\n## 标识符\n\n标识符指变量、函数、属性的名字，或者函数的参数。\n\n- 标识符第一个字符必须是一个字母、下划线或$\n- 其他字符可以是字母、下划线、$或数字\n\n按照惯例，ECMAScript标识符采用驼峰大小写格式，第一个字母小写，剩下每个单词的首字母大写。\n\n## 严格模式\n\n在js代码顶部添加`\"use strict\";`\n\n# 变量\n\nJS的变量是松散类型的，不需要指定变量类型。如`var message;`使用var声明的变量作用域为该语句所在的函数内，存在变量提升现象。\n\nES6新增关键字let。使用let声明的变量作用域为该语句所在的代码块内，不存在变量提升。且let不允许在相同的作用域内，重复声明同一个变量。\n\n# 数据类型\n\n共有5种简单数据类型：Undefined、Null、Boolean、Number、String\n\n1种复杂数据类型Object，Object本质由一组无序的键值对组成的。\n\n## typeof操作符\n\n使用typeof操作符可返回变量的数据类型\n\n注意：typeof是一个操作符而不是函数，因此可以使用圆括号也可以不使用\n\n## 简单（基本）数据类型\n\n### Undefined\n\nUndefined类型只有一个值，即特殊的undefined。\n\n对未初始化的变量执行typeof会返回undefined，而对未声明的变量执行typeof同样返回undefined\n\n```js\nvar message;\nalert(typeof message); // 'undefined'\nalert(typeof age); // 'undefined'\n```\n\n因此，保持变量显式的初始化是一个良好的编码习惯。\n\n### Null\n\nNull类型只有一个值，即特殊的null。null值表示一个空对象指针，正因此使用typeof检测null值时会返回'object'类型。\n\n如果定义的变量在将来用于保存对象，最好将该变量初始化为null。实际上，undefined值是派生自null值的，因此`null == undefined`返回值是true。\n\n### Boolean\n\nBoolean类型有两个值，true和false。各种数据类型与Boolean类型的转换如下\n\n| 数据类型  | 转换为true的值               | 转换为false的值 |\n| --------- | ---------------------------- | --------------- |\n| Boolean   | true                         | false           |\n| String    | 任何非空字符串               | \"\"（空字符串）  |\n| Number    | 任何非零数字值（包括无穷大） | 0和Nan          |\n| Object    | 任何对象                     | null            |\n| Undefined | n/a(N/A)                     | undefined       |\n\n### Number\n\nNumber类型用来表示整数和浮点数值。\n\n#### 整数\n\n除十进制外，整数还可以以八进制和十六进制的字面值来表示\n\n```\nvar octalNum1 = 070; // 八进制56\nvar octalNum2 = 079; // 无效的八进制，解析为79\nvar hexNum1 = 0xA; // 十六进制的10\nvar hexNum2 = 0x2f; // 十六进制的31\n```\n\n#### 浮点数\n\nJS浮点数值的最高精度是17位小数。\n\nJS会将某些浮点数值转换为整数值，如1.0，1.。\n\n对于极大极小值，可以用e表示法，如\n\n```js\nvar floatNum = 3.124e7;\n```\n\n#### Nan\n\nNan（Not a Number）是一个特殊的数值。\n\n- 任何涉及Nan的操作都会返回Nan\n- Nan和任何值都不相等\n\n#### 数值转换\n\nNumber()、parseInt()、parseFloat()\n\n### String\n\nJS的字符串是不可变的，字符串一旦创建，值不能改变。\n\n数值、布尔值、对象和字符串值有toString()方法，null、undefined值没有这个方法。\n\n也可使使用转型函数String()。\n\n## Object\n\nJS中的对象是一组数据和功能的集合。\n\n`var o = new Object();`\n\nObject的每个实例有下列属性和方法：\n\n**constructor：**保存着用于创建当前对象的函数\n\n**hasOwnProperty(propertyName)：**用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。\n\n**isPrototypeOf(object)：**用于检查传入的对象是否是当前对象的原型。\n\n**propertyIsEnumerable(propertyName)：**用于检查给定的属性是否能够使用for-in语句来枚举。\n\n**toLocaleString()：**返回对象的字符串表示，该字符串与执行环境的地区对应。\n\n**toString()：**返回对象的字符串表示。\n\n**valueOf()：**返回对象的字符串、数值或布尔值表示。\n\n# 操作符\n\n一组用于操作数据值的操作符，包括算术操作符、位操作符、关系操作符和相等操作符。\n\n## 一元操作符\n\n一元操作符只能操作一个值。\n\n- 递增递减操作符 ++ --\n- 一元加和减操作符 + -\n- 位操作符\n  - 按位非 ~\n  - 按位与 &\n  - 按位或 |\n  - 按位异或 ^\n  - 左移 <<\n  - 有符号的右移 >>\n  - 无符号的右移 >>>\n- 布尔操作符\n  - 逻辑非 !\n  - 逻辑与 &&\n  - 逻辑或 ||\n- 乘性操作符 * /\n- 加性操作符 + -\n- 关系操作符 < > <= >=\n- 相等操作符\n  - 相等和不相等 `==` `!=`\n  - 全等和不全等 `===` `!==`\n- 条件操作符 expression ? true : false\n- 赋值操作符 =\n\n","slug":"31天Javascript学习-第1天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2ac001j7owz889n6kcu","content":"<h1 id=\"day01-JS的基本语法和数据类型\"><a href=\"#day01-JS的基本语法和数据类型\" class=\"headerlink\" title=\"day01-JS的基本语法和数据类型\"></a>day01-JS的基本语法和数据类型</h1><span id=\"more\"></span>\n\n<h2 id=\"Javascript的特点\"><a href=\"#Javascript的特点\" class=\"headerlink\" title=\"Javascript的特点\"></a>Javascript的特点</h2><h3 id=\"解释性语言\"><a href=\"#解释性语言\" class=\"headerlink\" title=\"解释性语言\"></a>解释性语言</h3><p><strong>解释型语言</strong>的意思是：程序执行之前，不需要事先被翻译为机器码；而是在运行时，边翻译边执行（翻译一行，执行一行）。</p>\n<h3 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h3><p>Javascript作为浏览器脚本语言，主要用途是与用户互动、操作DOM等，这决定了它只能是单线程。</p>\n<p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。但js 引擎执行异步代码而不用等待，是因有为有 消息队列和事件循环。</p>\n<p>NodeJS是单线程异步非阻塞模式，只有js执行是单线程，I/O交给libuv，是其他线程。<a href=\"https://www.cnblogs.com/wxmdevelop/p/10234556.html\">nodejs真的是单线程吗？ - 小小鸟儿！ - 博客园 (cnblogs.com)</a></p>\n<h2 id=\"Javascript的基本语法\"><a href=\"#Javascript的基本语法\" class=\"headerlink\" title=\"Javascript的基本语法\"></a>Javascript的基本语法</h2><h3 id=\"HTML对JS的三种引用方式\"><a href=\"#HTML对JS的三种引用方式\" class=\"headerlink\" title=\"HTML对JS的三种引用方式\"></a>HTML对JS的三种引用方式</h3><p><strong>方式1：行内式</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;点我点我&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;hello world&#x27;)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>方式2：内嵌式</strong></p>\n<p>使用<code>&lt;script&gt;</code>元素，只需指定type属性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 在这里写 js 代码</span></span></span><br><span class=\"line\"><span class=\"javascript\">            alert(<span class=\"string\">&#x27;hello world&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hello world&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>方式3：外链式</strong></p>\n<p>使用<code>&lt;script&gt;</code>元素，需指定src属性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;utils.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>JS代码写在<body>中，准确来说是在页面标签元素后，body结束标签前。</body></p>\n<h2 id=\"区分大小写\"><a href=\"#区分大小写\" class=\"headerlink\" title=\"区分大小写\"></a>区分大小写</h2><h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p>标识符指变量、函数、属性的名字，或者函数的参数。</p>\n<ul>\n<li>标识符第一个字符必须是一个字母、下划线或$</li>\n<li>其他字符可以是字母、下划线、$或数字</li>\n</ul>\n<p>按照惯例，ECMAScript标识符采用驼峰大小写格式，第一个字母小写，剩下每个单词的首字母大写。</p>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>在js代码顶部添加<code>&quot;use strict&quot;;</code></p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p>JS的变量是松散类型的，不需要指定变量类型。如<code>var message;</code>使用var声明的变量作用域为该语句所在的函数内，存在变量提升现象。</p>\n<p>ES6新增关键字let。使用let声明的变量作用域为该语句所在的代码块内，不存在变量提升。且let不允许在相同的作用域内，重复声明同一个变量。</p>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p>共有5种简单数据类型：Undefined、Null、Boolean、Number、String</p>\n<p>1种复杂数据类型Object，Object本质由一组无序的键值对组成的。</p>\n<h2 id=\"typeof操作符\"><a href=\"#typeof操作符\" class=\"headerlink\" title=\"typeof操作符\"></a>typeof操作符</h2><p>使用typeof操作符可返回变量的数据类型</p>\n<p>注意：typeof是一个操作符而不是函数，因此可以使用圆括号也可以不使用</p>\n<h2 id=\"简单（基本）数据类型\"><a href=\"#简单（基本）数据类型\" class=\"headerlink\" title=\"简单（基本）数据类型\"></a>简单（基本）数据类型</h2><h3 id=\"Undefined\"><a href=\"#Undefined\" class=\"headerlink\" title=\"Undefined\"></a>Undefined</h3><p>Undefined类型只有一个值，即特殊的undefined。</p>\n<p>对未初始化的变量执行typeof会返回undefined，而对未声明的变量执行typeof同样返回undefined</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message;</span><br><span class=\"line\">alert(<span class=\"keyword\">typeof</span> message); <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\">alert(<span class=\"keyword\">typeof</span> age); <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，保持变量显式的初始化是一个良好的编码习惯。</p>\n<h3 id=\"Null\"><a href=\"#Null\" class=\"headerlink\" title=\"Null\"></a>Null</h3><p>Null类型只有一个值，即特殊的null。null值表示一个空对象指针，正因此使用typeof检测null值时会返回’object’类型。</p>\n<p>如果定义的变量在将来用于保存对象，最好将该变量初始化为null。实际上，undefined值是派生自null值的，因此<code>null == undefined</code>返回值是true。</p>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><p>Boolean类型有两个值，true和false。各种数据类型与Boolean类型的转换如下</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>转换为true的值</th>\n<th>转换为false的值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Boolean</td>\n<td>true</td>\n<td>false</td>\n</tr>\n<tr>\n<td>String</td>\n<td>任何非空字符串</td>\n<td>“”（空字符串）</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>任何非零数字值（包括无穷大）</td>\n<td>0和Nan</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>任何对象</td>\n<td>null</td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td>n/a(N/A)</td>\n<td>undefined</td>\n</tr>\n</tbody></table>\n<h3 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h3><p>Number类型用来表示整数和浮点数值。</p>\n<h4 id=\"整数\"><a href=\"#整数\" class=\"headerlink\" title=\"整数\"></a>整数</h4><p>除十进制外，整数还可以以八进制和十六进制的字面值来表示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var octalNum1 = 070; // 八进制56</span><br><span class=\"line\">var octalNum2 = 079; // 无效的八进制，解析为79</span><br><span class=\"line\">var hexNum1 = 0xA; // 十六进制的10</span><br><span class=\"line\">var hexNum2 = 0x2f; // 十六进制的31</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h4><p>JS浮点数值的最高精度是17位小数。</p>\n<p>JS会将某些浮点数值转换为整数值，如1.0，1.。</p>\n<p>对于极大极小值，可以用e表示法，如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> floatNum = <span class=\"number\">3.124e7</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Nan\"><a href=\"#Nan\" class=\"headerlink\" title=\"Nan\"></a>Nan</h4><p>Nan（Not a Number）是一个特殊的数值。</p>\n<ul>\n<li>任何涉及Nan的操作都会返回Nan</li>\n<li>Nan和任何值都不相等</li>\n</ul>\n<h4 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h4><p>Number()、parseInt()、parseFloat()</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>JS的字符串是不可变的，字符串一旦创建，值不能改变。</p>\n<p>数值、布尔值、对象和字符串值有toString()方法，null、undefined值没有这个方法。</p>\n<p>也可使使用转型函数String()。</p>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><p>JS中的对象是一组数据和功能的集合。</p>\n<p><code>var o = new Object();</code></p>\n<p>Object的每个实例有下列属性和方法：</p>\n<p><strong>constructor：</strong>保存着用于创建当前对象的函数</p>\n<p><strong>hasOwnProperty(propertyName)：</strong>用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。</p>\n<p><strong>isPrototypeOf(object)：</strong>用于检查传入的对象是否是当前对象的原型。</p>\n<p><strong>propertyIsEnumerable(propertyName)：</strong>用于检查给定的属性是否能够使用for-in语句来枚举。</p>\n<p><strong>toLocaleString()：</strong>返回对象的字符串表示，该字符串与执行环境的地区对应。</p>\n<p><strong>toString()：</strong>返回对象的字符串表示。</p>\n<p><strong>valueOf()：</strong>返回对象的字符串、数值或布尔值表示。</p>\n<h1 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h1><p>一组用于操作数据值的操作符，包括算术操作符、位操作符、关系操作符和相等操作符。</p>\n<h2 id=\"一元操作符\"><a href=\"#一元操作符\" class=\"headerlink\" title=\"一元操作符\"></a>一元操作符</h2><p>一元操作符只能操作一个值。</p>\n<ul>\n<li>递增递减操作符 ++ –</li>\n<li>一元加和减操作符 + -</li>\n<li>位操作符<ul>\n<li>按位非 ~</li>\n<li>按位与 &amp;</li>\n<li>按位或 |</li>\n<li>按位异或 ^</li>\n<li>左移 &lt;&lt;</li>\n<li>有符号的右移 &gt;&gt;</li>\n<li>无符号的右移 &gt;&gt;&gt;</li>\n</ul>\n</li>\n<li>布尔操作符<ul>\n<li>逻辑非 !</li>\n<li>逻辑与 &amp;&amp;</li>\n<li>逻辑或 ||</li>\n</ul>\n</li>\n<li>乘性操作符 * /</li>\n<li>加性操作符 + -</li>\n<li>关系操作符 &lt; &gt; &lt;= &gt;=</li>\n<li>相等操作符<ul>\n<li>相等和不相等 <code>==</code> <code>!=</code></li>\n<li>全等和不全等 <code>===</code> <code>!==</code></li>\n</ul>\n</li>\n<li>条件操作符 expression ? true : false</li>\n<li>赋值操作符 =</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"day01-JS的基本语法和数据类型\"><a href=\"#day01-JS的基本语法和数据类型\" class=\"headerlink\" title=\"day01-JS的基本语法和数据类型\"></a>day01-JS的基本语法和数据类型</h1>","more":"<h2 id=\"Javascript的特点\"><a href=\"#Javascript的特点\" class=\"headerlink\" title=\"Javascript的特点\"></a>Javascript的特点</h2><h3 id=\"解释性语言\"><a href=\"#解释性语言\" class=\"headerlink\" title=\"解释性语言\"></a>解释性语言</h3><p><strong>解释型语言</strong>的意思是：程序执行之前，不需要事先被翻译为机器码；而是在运行时，边翻译边执行（翻译一行，执行一行）。</p>\n<h3 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h3><p>Javascript作为浏览器脚本语言，主要用途是与用户互动、操作DOM等，这决定了它只能是单线程。</p>\n<p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。但js 引擎执行异步代码而不用等待，是因有为有 消息队列和事件循环。</p>\n<p>NodeJS是单线程异步非阻塞模式，只有js执行是单线程，I/O交给libuv，是其他线程。<a href=\"https://www.cnblogs.com/wxmdevelop/p/10234556.html\">nodejs真的是单线程吗？ - 小小鸟儿！ - 博客园 (cnblogs.com)</a></p>\n<h2 id=\"Javascript的基本语法\"><a href=\"#Javascript的基本语法\" class=\"headerlink\" title=\"Javascript的基本语法\"></a>Javascript的基本语法</h2><h3 id=\"HTML对JS的三种引用方式\"><a href=\"#HTML对JS的三种引用方式\" class=\"headerlink\" title=\"HTML对JS的三种引用方式\"></a>HTML对JS的三种引用方式</h3><p><strong>方式1：行内式</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;点我点我&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;alert(&#x27;hello world&#x27;)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>方式2：内嵌式</strong></p>\n<p>使用<code>&lt;script&gt;</code>元素，只需指定type属性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 在这里写 js 代码</span></span></span><br><span class=\"line\"><span class=\"javascript\">            alert(<span class=\"string\">&#x27;hello world&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hello world&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>方式3：外链式</strong></p>\n<p>使用<code>&lt;script&gt;</code>元素，需指定src属性</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;utils.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>JS代码写在<body>中，准确来说是在页面标签元素后，body结束标签前。</body></p>\n<h2 id=\"区分大小写\"><a href=\"#区分大小写\" class=\"headerlink\" title=\"区分大小写\"></a>区分大小写</h2><h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p>标识符指变量、函数、属性的名字，或者函数的参数。</p>\n<ul>\n<li>标识符第一个字符必须是一个字母、下划线或$</li>\n<li>其他字符可以是字母、下划线、$或数字</li>\n</ul>\n<p>按照惯例，ECMAScript标识符采用驼峰大小写格式，第一个字母小写，剩下每个单词的首字母大写。</p>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>在js代码顶部添加<code>&quot;use strict&quot;;</code></p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p>JS的变量是松散类型的，不需要指定变量类型。如<code>var message;</code>使用var声明的变量作用域为该语句所在的函数内，存在变量提升现象。</p>\n<p>ES6新增关键字let。使用let声明的变量作用域为该语句所在的代码块内，不存在变量提升。且let不允许在相同的作用域内，重复声明同一个变量。</p>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p>共有5种简单数据类型：Undefined、Null、Boolean、Number、String</p>\n<p>1种复杂数据类型Object，Object本质由一组无序的键值对组成的。</p>\n<h2 id=\"typeof操作符\"><a href=\"#typeof操作符\" class=\"headerlink\" title=\"typeof操作符\"></a>typeof操作符</h2><p>使用typeof操作符可返回变量的数据类型</p>\n<p>注意：typeof是一个操作符而不是函数，因此可以使用圆括号也可以不使用</p>\n<h2 id=\"简单（基本）数据类型\"><a href=\"#简单（基本）数据类型\" class=\"headerlink\" title=\"简单（基本）数据类型\"></a>简单（基本）数据类型</h2><h3 id=\"Undefined\"><a href=\"#Undefined\" class=\"headerlink\" title=\"Undefined\"></a>Undefined</h3><p>Undefined类型只有一个值，即特殊的undefined。</p>\n<p>对未初始化的变量执行typeof会返回undefined，而对未声明的变量执行typeof同样返回undefined</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message;</span><br><span class=\"line\">alert(<span class=\"keyword\">typeof</span> message); <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\">alert(<span class=\"keyword\">typeof</span> age); <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，保持变量显式的初始化是一个良好的编码习惯。</p>\n<h3 id=\"Null\"><a href=\"#Null\" class=\"headerlink\" title=\"Null\"></a>Null</h3><p>Null类型只有一个值，即特殊的null。null值表示一个空对象指针，正因此使用typeof检测null值时会返回’object’类型。</p>\n<p>如果定义的变量在将来用于保存对象，最好将该变量初始化为null。实际上，undefined值是派生自null值的，因此<code>null == undefined</code>返回值是true。</p>\n<h3 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h3><p>Boolean类型有两个值，true和false。各种数据类型与Boolean类型的转换如下</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>转换为true的值</th>\n<th>转换为false的值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Boolean</td>\n<td>true</td>\n<td>false</td>\n</tr>\n<tr>\n<td>String</td>\n<td>任何非空字符串</td>\n<td>“”（空字符串）</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>任何非零数字值（包括无穷大）</td>\n<td>0和Nan</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>任何对象</td>\n<td>null</td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td>n/a(N/A)</td>\n<td>undefined</td>\n</tr>\n</tbody></table>\n<h3 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h3><p>Number类型用来表示整数和浮点数值。</p>\n<h4 id=\"整数\"><a href=\"#整数\" class=\"headerlink\" title=\"整数\"></a>整数</h4><p>除十进制外，整数还可以以八进制和十六进制的字面值来表示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var octalNum1 = 070; // 八进制56</span><br><span class=\"line\">var octalNum2 = 079; // 无效的八进制，解析为79</span><br><span class=\"line\">var hexNum1 = 0xA; // 十六进制的10</span><br><span class=\"line\">var hexNum2 = 0x2f; // 十六进制的31</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h4><p>JS浮点数值的最高精度是17位小数。</p>\n<p>JS会将某些浮点数值转换为整数值，如1.0，1.。</p>\n<p>对于极大极小值，可以用e表示法，如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> floatNum = <span class=\"number\">3.124e7</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Nan\"><a href=\"#Nan\" class=\"headerlink\" title=\"Nan\"></a>Nan</h4><p>Nan（Not a Number）是一个特殊的数值。</p>\n<ul>\n<li>任何涉及Nan的操作都会返回Nan</li>\n<li>Nan和任何值都不相等</li>\n</ul>\n<h4 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h4><p>Number()、parseInt()、parseFloat()</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>JS的字符串是不可变的，字符串一旦创建，值不能改变。</p>\n<p>数值、布尔值、对象和字符串值有toString()方法，null、undefined值没有这个方法。</p>\n<p>也可使使用转型函数String()。</p>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><p>JS中的对象是一组数据和功能的集合。</p>\n<p><code>var o = new Object();</code></p>\n<p>Object的每个实例有下列属性和方法：</p>\n<p><strong>constructor：</strong>保存着用于创建当前对象的函数</p>\n<p><strong>hasOwnProperty(propertyName)：</strong>用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。</p>\n<p><strong>isPrototypeOf(object)：</strong>用于检查传入的对象是否是当前对象的原型。</p>\n<p><strong>propertyIsEnumerable(propertyName)：</strong>用于检查给定的属性是否能够使用for-in语句来枚举。</p>\n<p><strong>toLocaleString()：</strong>返回对象的字符串表示，该字符串与执行环境的地区对应。</p>\n<p><strong>toString()：</strong>返回对象的字符串表示。</p>\n<p><strong>valueOf()：</strong>返回对象的字符串、数值或布尔值表示。</p>\n<h1 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h1><p>一组用于操作数据值的操作符，包括算术操作符、位操作符、关系操作符和相等操作符。</p>\n<h2 id=\"一元操作符\"><a href=\"#一元操作符\" class=\"headerlink\" title=\"一元操作符\"></a>一元操作符</h2><p>一元操作符只能操作一个值。</p>\n<ul>\n<li>递增递减操作符 ++ –</li>\n<li>一元加和减操作符 + -</li>\n<li>位操作符<ul>\n<li>按位非 ~</li>\n<li>按位与 &amp;</li>\n<li>按位或 |</li>\n<li>按位异或 ^</li>\n<li>左移 &lt;&lt;</li>\n<li>有符号的右移 &gt;&gt;</li>\n<li>无符号的右移 &gt;&gt;&gt;</li>\n</ul>\n</li>\n<li>布尔操作符<ul>\n<li>逻辑非 !</li>\n<li>逻辑与 &amp;&amp;</li>\n<li>逻辑或 ||</li>\n</ul>\n</li>\n<li>乘性操作符 * /</li>\n<li>加性操作符 + -</li>\n<li>关系操作符 &lt; &gt; &lt;= &gt;=</li>\n<li>相等操作符<ul>\n<li>相等和不相等 <code>==</code> <code>!=</code></li>\n<li>全等和不全等 <code>===</code> <code>!==</code></li>\n</ul>\n</li>\n<li>条件操作符 expression ? true : false</li>\n<li>赋值操作符 =</li>\n</ul>"},{"title":"31天Javascript学习-第2天","reprint":false,"date":"2022-02-21T07:10:24.000Z","updated":"2022-02-21T07:10:29.000Z","conver":null,"_content":"\n# 变量作用域和内存问题\n\n<!--more-->\n\n## 变量\n\nJS的变量有两种不同的数据类型的值：**基本类型值**和**引用类型值**。\n\n**基本数据类型**：\n\n基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。\n\n**引用数据类型**：\n\n对象是保存到**堆内存**中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间；而**变量保存了对象的内存地址**（对象的引用），保存在栈内存当中。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。\n\nJS 中，所有的**变量**都是保存在**栈内存**中的。\n\n其最大区别是在参数传值：\n\n- 基本数据类型：传数值\n- 引用数据类型：传地址\n\nJS中所有函数的参数都是**按值传递**的。\n\n## 作用域\n\nJS中，一共两种作用域（ES5），为了减少命名冲突\n\n- **全局作用域**：作用于整个script标签内部或JS文件中，\n- **函数作用域**（局部作用域）\n\n### window对象\n\n全局作用域在页面打开时创建，在页面关闭时销毁。全局作用域中有一个全局对象window，代表浏览器的窗口。\n\n- 创建的**变量**都会作为window对象的**属性**保存。如全局作用域中的`var a = 100`，这里`a`等价于`window.a`。\n- 创建的**函数**都会作为window对象的**方法**保存。\n\n### 作用域链\n\n代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）。其为了保证对执行环境有权访问的所有变量和函数的有序访问。\n\n其规则是：在内部作用域中可以访问到外部作用域的变量，反之无法访问。\n\n当函数作用域操作一个变量时，遵循**就近原则**，先在自身作用域中寻找，找不到再向上一级作用域中查找。\n\n### 变量声明提前（变量提升）\n\n使用var关键字声明的变量，会在所有代码执行之前被声明，但不会赋值。若声明变量不是使用var关键字，则不会提前声明。\n\n例：\n\n```js\nconsole.log(a);\n\nvar a = 123; // undefined\n```\n\n变量a被提前声明了，但没有赋值，所以为undefined。\n\n### 函数声明提前\n\n使用**函数声明**的形式创建的函数，会被声明提前。\n\n函数声明：`function foo(){}`\n\n使用**函数表达式**创建的函数，不会被声明提前。\n\n函数表达式：`var foo = function(){};`\n\n### 函数作用域中的声明提前\n\n在函数作用域中，也有声明提前的特性。\n\n### 没有块级作用域(ES5)\n\nJS没有块级作用域，即由`{}`包裹起来的代码中的变量，只能在该块的内部使用。\n\n## 内存问题\n\nJS具有自动垃圾收集机制，常用有两种垃圾收集方式：\n\n- 标记清除\n- 引用计数\n\n","source":"_posts/31天Javascript学习-第2天.md","raw":"---\ntitle: 31天Javascript学习-第2天\nreprint: false\ndate: 2022-02-21 15:10:24\nupdated: 2022-02-21 15:10:29\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# 变量作用域和内存问题\n\n<!--more-->\n\n## 变量\n\nJS的变量有两种不同的数据类型的值：**基本类型值**和**引用类型值**。\n\n**基本数据类型**：\n\n基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。\n\n**引用数据类型**：\n\n对象是保存到**堆内存**中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间；而**变量保存了对象的内存地址**（对象的引用），保存在栈内存当中。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。\n\nJS 中，所有的**变量**都是保存在**栈内存**中的。\n\n其最大区别是在参数传值：\n\n- 基本数据类型：传数值\n- 引用数据类型：传地址\n\nJS中所有函数的参数都是**按值传递**的。\n\n## 作用域\n\nJS中，一共两种作用域（ES5），为了减少命名冲突\n\n- **全局作用域**：作用于整个script标签内部或JS文件中，\n- **函数作用域**（局部作用域）\n\n### window对象\n\n全局作用域在页面打开时创建，在页面关闭时销毁。全局作用域中有一个全局对象window，代表浏览器的窗口。\n\n- 创建的**变量**都会作为window对象的**属性**保存。如全局作用域中的`var a = 100`，这里`a`等价于`window.a`。\n- 创建的**函数**都会作为window对象的**方法**保存。\n\n### 作用域链\n\n代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）。其为了保证对执行环境有权访问的所有变量和函数的有序访问。\n\n其规则是：在内部作用域中可以访问到外部作用域的变量，反之无法访问。\n\n当函数作用域操作一个变量时，遵循**就近原则**，先在自身作用域中寻找，找不到再向上一级作用域中查找。\n\n### 变量声明提前（变量提升）\n\n使用var关键字声明的变量，会在所有代码执行之前被声明，但不会赋值。若声明变量不是使用var关键字，则不会提前声明。\n\n例：\n\n```js\nconsole.log(a);\n\nvar a = 123; // undefined\n```\n\n变量a被提前声明了，但没有赋值，所以为undefined。\n\n### 函数声明提前\n\n使用**函数声明**的形式创建的函数，会被声明提前。\n\n函数声明：`function foo(){}`\n\n使用**函数表达式**创建的函数，不会被声明提前。\n\n函数表达式：`var foo = function(){};`\n\n### 函数作用域中的声明提前\n\n在函数作用域中，也有声明提前的特性。\n\n### 没有块级作用域(ES5)\n\nJS没有块级作用域，即由`{}`包裹起来的代码中的变量，只能在该块的内部使用。\n\n## 内存问题\n\nJS具有自动垃圾收集机制，常用有两种垃圾收集方式：\n\n- 标记清除\n- 引用计数\n\n","slug":"31天Javascript学习-第2天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2ad001m7owza51862pr","content":"<h1 id=\"变量作用域和内存问题\"><a href=\"#变量作用域和内存问题\" class=\"headerlink\" title=\"变量作用域和内存问题\"></a>变量作用域和内存问题</h1><span id=\"more\"></span>\n\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>JS的变量有两种不同的数据类型的值：<strong>基本类型值</strong>和<strong>引用类型值</strong>。</p>\n<p><strong>基本数据类型</strong>：</p>\n<p>基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。</p>\n<p><strong>引用数据类型</strong>：</p>\n<p>对象是保存到<strong>堆内存</strong>中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间；而<strong>变量保存了对象的内存地址</strong>（对象的引用），保存在栈内存当中。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。</p>\n<p>JS 中，所有的<strong>变量</strong>都是保存在<strong>栈内存</strong>中的。</p>\n<p>其最大区别是在参数传值：</p>\n<ul>\n<li>基本数据类型：传数值</li>\n<li>引用数据类型：传地址</li>\n</ul>\n<p>JS中所有函数的参数都是<strong>按值传递</strong>的。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>JS中，一共两种作用域（ES5），为了减少命名冲突</p>\n<ul>\n<li><strong>全局作用域</strong>：作用于整个script标签内部或JS文件中，</li>\n<li><strong>函数作用域</strong>（局部作用域）</li>\n</ul>\n<h3 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h3><p>全局作用域在页面打开时创建，在页面关闭时销毁。全局作用域中有一个全局对象window，代表浏览器的窗口。</p>\n<ul>\n<li>创建的<strong>变量</strong>都会作为window对象的<strong>属性</strong>保存。如全局作用域中的<code>var a = 100</code>，这里<code>a</code>等价于<code>window.a</code>。</li>\n<li>创建的<strong>函数</strong>都会作为window对象的<strong>方法</strong>保存。</li>\n</ul>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。其为了保证对执行环境有权访问的所有变量和函数的有序访问。</p>\n<p>其规则是：在内部作用域中可以访问到外部作用域的变量，反之无法访问。</p>\n<p>当函数作用域操作一个变量时，遵循<strong>就近原则</strong>，先在自身作用域中寻找，找不到再向上一级作用域中查找。</p>\n<h3 id=\"变量声明提前（变量提升）\"><a href=\"#变量声明提前（变量提升）\" class=\"headerlink\" title=\"变量声明提前（变量提升）\"></a>变量声明提前（变量提升）</h3><p>使用var关键字声明的变量，会在所有代码执行之前被声明，但不会赋值。若声明变量不是使用var关键字，则不会提前声明。</p>\n<p>例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>变量a被提前声明了，但没有赋值，所以为undefined。</p>\n<h3 id=\"函数声明提前\"><a href=\"#函数声明提前\" class=\"headerlink\" title=\"函数声明提前\"></a>函数声明提前</h3><p>使用<strong>函数声明</strong>的形式创建的函数，会被声明提前。</p>\n<p>函数声明：<code>function foo()&#123;&#125;</code></p>\n<p>使用<strong>函数表达式</strong>创建的函数，不会被声明提前。</p>\n<p>函数表达式：<code>var foo = function()&#123;&#125;;</code></p>\n<h3 id=\"函数作用域中的声明提前\"><a href=\"#函数作用域中的声明提前\" class=\"headerlink\" title=\"函数作用域中的声明提前\"></a>函数作用域中的声明提前</h3><p>在函数作用域中，也有声明提前的特性。</p>\n<h3 id=\"没有块级作用域-ES5\"><a href=\"#没有块级作用域-ES5\" class=\"headerlink\" title=\"没有块级作用域(ES5)\"></a>没有块级作用域(ES5)</h3><p>JS没有块级作用域，即由<code>&#123;&#125;</code>包裹起来的代码中的变量，只能在该块的内部使用。</p>\n<h2 id=\"内存问题\"><a href=\"#内存问题\" class=\"headerlink\" title=\"内存问题\"></a>内存问题</h2><p>JS具有自动垃圾收集机制，常用有两种垃圾收集方式：</p>\n<ul>\n<li>标记清除</li>\n<li>引用计数</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"变量作用域和内存问题\"><a href=\"#变量作用域和内存问题\" class=\"headerlink\" title=\"变量作用域和内存问题\"></a>变量作用域和内存问题</h1>","more":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>JS的变量有两种不同的数据类型的值：<strong>基本类型值</strong>和<strong>引用类型值</strong>。</p>\n<p><strong>基本数据类型</strong>：</p>\n<p>基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。</p>\n<p><strong>引用数据类型</strong>：</p>\n<p>对象是保存到<strong>堆内存</strong>中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间；而<strong>变量保存了对象的内存地址</strong>（对象的引用），保存在栈内存当中。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。</p>\n<p>JS 中，所有的<strong>变量</strong>都是保存在<strong>栈内存</strong>中的。</p>\n<p>其最大区别是在参数传值：</p>\n<ul>\n<li>基本数据类型：传数值</li>\n<li>引用数据类型：传地址</li>\n</ul>\n<p>JS中所有函数的参数都是<strong>按值传递</strong>的。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>JS中，一共两种作用域（ES5），为了减少命名冲突</p>\n<ul>\n<li><strong>全局作用域</strong>：作用于整个script标签内部或JS文件中，</li>\n<li><strong>函数作用域</strong>（局部作用域）</li>\n</ul>\n<h3 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h3><p>全局作用域在页面打开时创建，在页面关闭时销毁。全局作用域中有一个全局对象window，代表浏览器的窗口。</p>\n<ul>\n<li>创建的<strong>变量</strong>都会作为window对象的<strong>属性</strong>保存。如全局作用域中的<code>var a = 100</code>，这里<code>a</code>等价于<code>window.a</code>。</li>\n<li>创建的<strong>函数</strong>都会作为window对象的<strong>方法</strong>保存。</li>\n</ul>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。其为了保证对执行环境有权访问的所有变量和函数的有序访问。</p>\n<p>其规则是：在内部作用域中可以访问到外部作用域的变量，反之无法访问。</p>\n<p>当函数作用域操作一个变量时，遵循<strong>就近原则</strong>，先在自身作用域中寻找，找不到再向上一级作用域中查找。</p>\n<h3 id=\"变量声明提前（变量提升）\"><a href=\"#变量声明提前（变量提升）\" class=\"headerlink\" title=\"变量声明提前（变量提升）\"></a>变量声明提前（变量提升）</h3><p>使用var关键字声明的变量，会在所有代码执行之前被声明，但不会赋值。若声明变量不是使用var关键字，则不会提前声明。</p>\n<p>例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>变量a被提前声明了，但没有赋值，所以为undefined。</p>\n<h3 id=\"函数声明提前\"><a href=\"#函数声明提前\" class=\"headerlink\" title=\"函数声明提前\"></a>函数声明提前</h3><p>使用<strong>函数声明</strong>的形式创建的函数，会被声明提前。</p>\n<p>函数声明：<code>function foo()&#123;&#125;</code></p>\n<p>使用<strong>函数表达式</strong>创建的函数，不会被声明提前。</p>\n<p>函数表达式：<code>var foo = function()&#123;&#125;;</code></p>\n<h3 id=\"函数作用域中的声明提前\"><a href=\"#函数作用域中的声明提前\" class=\"headerlink\" title=\"函数作用域中的声明提前\"></a>函数作用域中的声明提前</h3><p>在函数作用域中，也有声明提前的特性。</p>\n<h3 id=\"没有块级作用域-ES5\"><a href=\"#没有块级作用域-ES5\" class=\"headerlink\" title=\"没有块级作用域(ES5)\"></a>没有块级作用域(ES5)</h3><p>JS没有块级作用域，即由<code>&#123;&#125;</code>包裹起来的代码中的变量，只能在该块的内部使用。</p>\n<h2 id=\"内存问题\"><a href=\"#内存问题\" class=\"headerlink\" title=\"内存问题\"></a>内存问题</h2><p>JS具有自动垃圾收集机制，常用有两种垃圾收集方式：</p>\n<ul>\n<li>标记清除</li>\n<li>引用计数</li>\n</ul>"},{"title":"31天Javascript学习-第3天","reprint":false,"date":"2022-02-22T10:43:34.000Z","updated":"2022-02-22T10:43:34.000Z","conver":null,"_content":"\n# 内置引用类型（一）——Object、Array、Date\n\n<!--more-->\n\nES中引用类型是一种数据结构，有时也称为**对象定义**。ES对内置对象（引用类型的值）的定义是：由ES实现提供的、不依赖于宿主环境的对象，这些对象在ES程序执行前就已经存在了。\n\n类似的：\n\n- 引用类型\t\t\t类\n- 引用类型的值\t对象\n\n对象是某个特定引用类型的实例，ES提供很多原生引用类型以方便开发使用。\n\n## Object\n\n大多**引用类型值**都是Object类型的实例。创建Object实例方式有两种：\n\n- new操作符后跟Object构造函数\n- 对象字面量\n\n访问对象属性有两种方法：\n\n- 点表示法 `person.name`\n- 方括号表示法 `person[\"name\"]`\n\n## Array\n\nES的数组的每一项可以保存任意类型的数据。创建数据有两种方式：\n\n**使用字面量**\n\n`var arr1 = [1, 2];`\n\n**使用构造函数**\n\n`let arr = new Array(args);`\n\n如果参数为空，则表示创建一个空数组；如果参数为数值，则表示数组的长度；如果有多个参数，表示数组中的元素。\n\n### 稀疏数组与密集数组\n\n- 稀疏数组：索引不连续、数组长度大于元素个数的数组，可以简单理解为有 `empty`（有空隙）的数组。\n- 密集数组：索引连续、数组长度等于元素个数的数组。\n\n数组的项数保存在其length属性中，该属性**不是只读**的，因此可以人为修改该属性。\n\n- 如果修改的 length 大于原长度，则多出部分会空出来，置为 undefined。\n- 如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素。\n\n```js\nlet arr = new Array(5);\n// 等价于\nlet arr = [];\narr.length = 5;\n// 此时返回一个length的值等于5的数组对象，但数组并不包含任何实际的元素，不能理解成包含5个值为undefined的元素\nconsole.log(arr); // [ <5 empty items> ]\n```\n\n#### empty和undefined\n\n从上面的例子可以看出，使用`new Array(len)`创建的数组，输出是一个包含len个empty元素的数组。empty并不是JS的基础数据类型之一，但它到底是什么呢？\n\n```js\nconsole.log(arr[0]); // undefined\n```\n\n当访问empty元素时，输出了undefined，empty和undefined是等价的？\n\n```js\nlet arr = new Array(4);\nlet arr_undefined = [undefined, undefined];\nconsole.log(arr); // [ <4 empty items> ]\nconsole.log(arr_undefined); // [ undefined, undefined ]\nconsole.log(arr[0]); // undefined\nconsole.log(arr_undefined[0]); // undefined\n\nconsole.log(arr[0] == arr_undefined[0]); // true\nconsole.log(arr[0] === arr_undefined[0]); // true\n\narr.forEach(item => {console.log(item);}) //undefined\narr_undefined.forEach(item => {console.log(item);}) // undefined\nconsole.log(arr.hasOwnProperty(0)); // false\nconsole.log(arr_undefined.hasOwnProperty(0)); // true\n```\n\n可以看到，只有在访问具体单个元素的时候，empty和undefined才表现一致，其余情况并不相同。\n\nempty是v8引擎对一个空的对象引用的描述，但JS中不存在这种基本类型，因此使用undefined表示。\n\n在用for循环对empty数组遍历，会将empty转换为undefined，而`forEach()`会自动忽略empty。\n\n#### 数组的常见方法\n\n##### 检测方法\n\n| 方法            | 描述           | 备注 |\n| :-------------- | :------------- | :--: |\n| Array.isArray() | 判断是否为数组 |      |\n\n##### 转换方法\n\n| 方法             | 描述               | 备注                                               |\n| ---------------- | ------------------ | -------------------------------------------------- |\n| toString()       | 将数组转换为字符串 | 创建字符串会调用数组中每一项的toString()方法       |\n| valueOf()        | 返回数组本身       |                                                    |\n| toLocaleString() | 将数组转换为字符串 | 创建字符串会调用数组中每一项的toLocaleString()方法 |\n\n##### 栈方法\n\n| 方法   | 描述                                               | 备注 |\n| ------ | -------------------------------------------------- | ---- |\n| push() | 向数组末尾插入一个或多个元素，返回修改后数组的长度 |      |\n| pop()  | 从数组末尾移除一个元素，返回修改后数组的长度       |      |\n\n##### 队列方法\n\n| 方法      | 描述                                               | 备注 |\n| --------- | -------------------------------------------------- | ---- |\n| unshift() | 向数组头部插入一个或多个元素，返回修改后数组的长度 |      |\n| shift()   | 从数组头部移除一个元素，返回修改后数组的长度       |      |\n\n##### 重排序方法\n\n| 方法      | 描述                                                         | 备注 |\n| --------- | ------------------------------------------------------------ | ---- |\n| reverse() | 对数组反转                                                   |      |\n| sort()    | 按升序排列数组项，按照Unicode编码，对每个数组项调用toString() |      |\n\n如果在使用sort()方法**不带参**，默认按照**Unicode编码**，对数组元素从小到大排序。\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\nconsole.log(arr.sort()); // [ 1, 10, 11, 2, 3, 5 ]\n```\n\n可以看到，数字11排在了2的前面，因为`sort()`方法是按照**Unicode编码**进行排序的。\n\nsort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。\n\n浏览器会根据回调函数的返回值来决定元素的排序：\n\n- **如果返回一个大于 0 的值，则元素会交换位置**\n- **如果返回一个小于 0 的值，则元素位置不变**\n- **如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置**\n\n下面是一个简单的比较函数：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nfunction compare(value1, value2) {\n  if (value1 < value2) {\n    return -1;\n  } else if (value1 > value2) {\n    return 1;\n  } else {\n    return 0\n  }\n}\n\nconsole.log(arr.sort(compare)); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n更简化的写法：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.sort(function (a, b){\n  return a - b; // 升序\n});\n\nconsole.log(result); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n或箭头函数（推荐）：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.sort((a, b) => a - b);\n\nconsole.log(result); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n##### 操作方法\n\n| 方法     | 描述                                                         | 备注           |\n| -------- | ------------------------------------------------------------ | -------------- |\n| concat() | 合并数组，返回一个**新的数组**                               | 不会改变原数组 |\n| slice()  | 从数组中**提取**指定的一个或多个元素，返回结果为**新的数组** | 不会改变原数组 |\n| splice() | 从数组中**删除**指定的一个或多个元素，返回结果为**被删除元素组成的新数组** | 会改变原数组   |\n\nsplice()有三种使用方法：\n\n- **删除：**传入两参。起始位置，删除的项数\n- **插入：**传入三个或三个以上的参数。起始位置，0，插入的元素\n- **替换：**传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素\n\n##### 位置方法\n\n| 方法          | 描述                                           | 备注 |\n| ------------- | ---------------------------------------------- | ---- |\n| indexOf()     | 从前往后索引，检索一个数组中是否含有指定的元素 |      |\n| lastIndexOf() | 从后往前索引，检索一个数组中是否含有指定的元素 |      |\n\n##### 迭代方法\n\n| 方法      | 描述                                                         | 备注                                                   |\n| --------- | ------------------------------------------------------------ | ------------------------------------------------------ |\n| every()   | 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true |                                                        |\n| filter()  | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |\n| forEach() | 和 for 循环类似，但需要兼容 IE8 以上                         | forEach() 没有返回值。也就是说，它的返回值是 undefined |\n| map()     | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |\n| some()    | 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true | 一真即真。只要有一项返回 true，最终的结果就返回 true   |\n\n##### 归并方法\n\n| 方法          | 描述                                                         | 备注 |\n| ------------- | ------------------------------------------------------------ | ---- |\n| reduce()      | 接收一个函数作为累加器，返回值是回调函数累计处理的结果       |      |\n| reduceRight() | 接收一个函数作为累加器，返回值是回调函数累计处理的结果，方向相反 |      |\n\nreduce()函数接收4个参数：前一个值，当前值，项的索引和数组对象。常见可用于数组求和等：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.reduce(function(prev, cur, index, array){\n  return prev + cur;\n});\n\nconsole.log(result); // 32\n```\n\n## Date\n\n### 创建Date对象\n\n`var now = new Date()`\n\n在调用构造函数而不传递参数的情况下，自动获得当前日期和时间。若想根据特定的日期和时间创建Date对象，则需传入该日期的毫秒数（即UTC时间1970年1月1日00:00:00）。为简化该计算过程，ES提供两个方法：Date.parse()，Date.UTC()。\n\n实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()\n\n","source":"_posts/31天Javascript学习-第3天.md","raw":"---\ntitle: 31天Javascript学习-第3天\nreprint: false\ndate: 2022-02-22 18:43:34\nupdated: 2022-02-22 18:43:34\nconver:\ncategories: 前端\ntags:\n  - JavaScript\n---\n\n# 内置引用类型（一）——Object、Array、Date\n\n<!--more-->\n\nES中引用类型是一种数据结构，有时也称为**对象定义**。ES对内置对象（引用类型的值）的定义是：由ES实现提供的、不依赖于宿主环境的对象，这些对象在ES程序执行前就已经存在了。\n\n类似的：\n\n- 引用类型\t\t\t类\n- 引用类型的值\t对象\n\n对象是某个特定引用类型的实例，ES提供很多原生引用类型以方便开发使用。\n\n## Object\n\n大多**引用类型值**都是Object类型的实例。创建Object实例方式有两种：\n\n- new操作符后跟Object构造函数\n- 对象字面量\n\n访问对象属性有两种方法：\n\n- 点表示法 `person.name`\n- 方括号表示法 `person[\"name\"]`\n\n## Array\n\nES的数组的每一项可以保存任意类型的数据。创建数据有两种方式：\n\n**使用字面量**\n\n`var arr1 = [1, 2];`\n\n**使用构造函数**\n\n`let arr = new Array(args);`\n\n如果参数为空，则表示创建一个空数组；如果参数为数值，则表示数组的长度；如果有多个参数，表示数组中的元素。\n\n### 稀疏数组与密集数组\n\n- 稀疏数组：索引不连续、数组长度大于元素个数的数组，可以简单理解为有 `empty`（有空隙）的数组。\n- 密集数组：索引连续、数组长度等于元素个数的数组。\n\n数组的项数保存在其length属性中，该属性**不是只读**的，因此可以人为修改该属性。\n\n- 如果修改的 length 大于原长度，则多出部分会空出来，置为 undefined。\n- 如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素。\n\n```js\nlet arr = new Array(5);\n// 等价于\nlet arr = [];\narr.length = 5;\n// 此时返回一个length的值等于5的数组对象，但数组并不包含任何实际的元素，不能理解成包含5个值为undefined的元素\nconsole.log(arr); // [ <5 empty items> ]\n```\n\n#### empty和undefined\n\n从上面的例子可以看出，使用`new Array(len)`创建的数组，输出是一个包含len个empty元素的数组。empty并不是JS的基础数据类型之一，但它到底是什么呢？\n\n```js\nconsole.log(arr[0]); // undefined\n```\n\n当访问empty元素时，输出了undefined，empty和undefined是等价的？\n\n```js\nlet arr = new Array(4);\nlet arr_undefined = [undefined, undefined];\nconsole.log(arr); // [ <4 empty items> ]\nconsole.log(arr_undefined); // [ undefined, undefined ]\nconsole.log(arr[0]); // undefined\nconsole.log(arr_undefined[0]); // undefined\n\nconsole.log(arr[0] == arr_undefined[0]); // true\nconsole.log(arr[0] === arr_undefined[0]); // true\n\narr.forEach(item => {console.log(item);}) //undefined\narr_undefined.forEach(item => {console.log(item);}) // undefined\nconsole.log(arr.hasOwnProperty(0)); // false\nconsole.log(arr_undefined.hasOwnProperty(0)); // true\n```\n\n可以看到，只有在访问具体单个元素的时候，empty和undefined才表现一致，其余情况并不相同。\n\nempty是v8引擎对一个空的对象引用的描述，但JS中不存在这种基本类型，因此使用undefined表示。\n\n在用for循环对empty数组遍历，会将empty转换为undefined，而`forEach()`会自动忽略empty。\n\n#### 数组的常见方法\n\n##### 检测方法\n\n| 方法            | 描述           | 备注 |\n| :-------------- | :------------- | :--: |\n| Array.isArray() | 判断是否为数组 |      |\n\n##### 转换方法\n\n| 方法             | 描述               | 备注                                               |\n| ---------------- | ------------------ | -------------------------------------------------- |\n| toString()       | 将数组转换为字符串 | 创建字符串会调用数组中每一项的toString()方法       |\n| valueOf()        | 返回数组本身       |                                                    |\n| toLocaleString() | 将数组转换为字符串 | 创建字符串会调用数组中每一项的toLocaleString()方法 |\n\n##### 栈方法\n\n| 方法   | 描述                                               | 备注 |\n| ------ | -------------------------------------------------- | ---- |\n| push() | 向数组末尾插入一个或多个元素，返回修改后数组的长度 |      |\n| pop()  | 从数组末尾移除一个元素，返回修改后数组的长度       |      |\n\n##### 队列方法\n\n| 方法      | 描述                                               | 备注 |\n| --------- | -------------------------------------------------- | ---- |\n| unshift() | 向数组头部插入一个或多个元素，返回修改后数组的长度 |      |\n| shift()   | 从数组头部移除一个元素，返回修改后数组的长度       |      |\n\n##### 重排序方法\n\n| 方法      | 描述                                                         | 备注 |\n| --------- | ------------------------------------------------------------ | ---- |\n| reverse() | 对数组反转                                                   |      |\n| sort()    | 按升序排列数组项，按照Unicode编码，对每个数组项调用toString() |      |\n\n如果在使用sort()方法**不带参**，默认按照**Unicode编码**，对数组元素从小到大排序。\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\nconsole.log(arr.sort()); // [ 1, 10, 11, 2, 3, 5 ]\n```\n\n可以看到，数字11排在了2的前面，因为`sort()`方法是按照**Unicode编码**进行排序的。\n\nsort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。\n\n浏览器会根据回调函数的返回值来决定元素的排序：\n\n- **如果返回一个大于 0 的值，则元素会交换位置**\n- **如果返回一个小于 0 的值，则元素位置不变**\n- **如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置**\n\n下面是一个简单的比较函数：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nfunction compare(value1, value2) {\n  if (value1 < value2) {\n    return -1;\n  } else if (value1 > value2) {\n    return 1;\n  } else {\n    return 0\n  }\n}\n\nconsole.log(arr.sort(compare)); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n更简化的写法：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.sort(function (a, b){\n  return a - b; // 升序\n});\n\nconsole.log(result); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n或箭头函数（推荐）：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.sort((a, b) => a - b);\n\nconsole.log(result); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n##### 操作方法\n\n| 方法     | 描述                                                         | 备注           |\n| -------- | ------------------------------------------------------------ | -------------- |\n| concat() | 合并数组，返回一个**新的数组**                               | 不会改变原数组 |\n| slice()  | 从数组中**提取**指定的一个或多个元素，返回结果为**新的数组** | 不会改变原数组 |\n| splice() | 从数组中**删除**指定的一个或多个元素，返回结果为**被删除元素组成的新数组** | 会改变原数组   |\n\nsplice()有三种使用方法：\n\n- **删除：**传入两参。起始位置，删除的项数\n- **插入：**传入三个或三个以上的参数。起始位置，0，插入的元素\n- **替换：**传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素\n\n##### 位置方法\n\n| 方法          | 描述                                           | 备注 |\n| ------------- | ---------------------------------------------- | ---- |\n| indexOf()     | 从前往后索引，检索一个数组中是否含有指定的元素 |      |\n| lastIndexOf() | 从后往前索引，检索一个数组中是否含有指定的元素 |      |\n\n##### 迭代方法\n\n| 方法      | 描述                                                         | 备注                                                   |\n| --------- | ------------------------------------------------------------ | ------------------------------------------------------ |\n| every()   | 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true |                                                        |\n| filter()  | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |\n| forEach() | 和 for 循环类似，但需要兼容 IE8 以上                         | forEach() 没有返回值。也就是说，它的返回值是 undefined |\n| map()     | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |\n| some()    | 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true | 一真即真。只要有一项返回 true，最终的结果就返回 true   |\n\n##### 归并方法\n\n| 方法          | 描述                                                         | 备注 |\n| ------------- | ------------------------------------------------------------ | ---- |\n| reduce()      | 接收一个函数作为累加器，返回值是回调函数累计处理的结果       |      |\n| reduceRight() | 接收一个函数作为累加器，返回值是回调函数累计处理的结果，方向相反 |      |\n\nreduce()函数接收4个参数：前一个值，当前值，项的索引和数组对象。常见可用于数组求和等：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.reduce(function(prev, cur, index, array){\n  return prev + cur;\n});\n\nconsole.log(result); // 32\n```\n\n## Date\n\n### 创建Date对象\n\n`var now = new Date()`\n\n在调用构造函数而不传递参数的情况下，自动获得当前日期和时间。若想根据特定的日期和时间创建Date对象，则需传入该日期的毫秒数（即UTC时间1970年1月1日00:00:00）。为简化该计算过程，ES提供两个方法：Date.parse()，Date.UTC()。\n\n实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()\n\n","slug":"31天Javascript学习-第3天","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2ad001p7owz060j43sj","content":"<h1 id=\"内置引用类型（一）——Object、Array、Date\"><a href=\"#内置引用类型（一）——Object、Array、Date\" class=\"headerlink\" title=\"内置引用类型（一）——Object、Array、Date\"></a>内置引用类型（一）——Object、Array、Date</h1><span id=\"more\"></span>\n\n<p>ES中引用类型是一种数据结构，有时也称为<strong>对象定义</strong>。ES对内置对象（引用类型的值）的定义是：由ES实现提供的、不依赖于宿主环境的对象，这些对象在ES程序执行前就已经存在了。</p>\n<p>类似的：</p>\n<ul>\n<li>引用类型            类</li>\n<li>引用类型的值    对象</li>\n</ul>\n<p>对象是某个特定引用类型的实例，ES提供很多原生引用类型以方便开发使用。</p>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><p>大多<strong>引用类型值</strong>都是Object类型的实例。创建Object实例方式有两种：</p>\n<ul>\n<li>new操作符后跟Object构造函数</li>\n<li>对象字面量</li>\n</ul>\n<p>访问对象属性有两种方法：</p>\n<ul>\n<li>点表示法 <code>person.name</code></li>\n<li>方括号表示法 <code>person[&quot;name&quot;]</code></li>\n</ul>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><p>ES的数组的每一项可以保存任意类型的数据。创建数据有两种方式：</p>\n<p><strong>使用字面量</strong></p>\n<p><code>var arr1 = [1, 2];</code></p>\n<p><strong>使用构造函数</strong></p>\n<p><code>let arr = new Array(args);</code></p>\n<p>如果参数为空，则表示创建一个空数组；如果参数为数值，则表示数组的长度；如果有多个参数，表示数组中的元素。</p>\n<h3 id=\"稀疏数组与密集数组\"><a href=\"#稀疏数组与密集数组\" class=\"headerlink\" title=\"稀疏数组与密集数组\"></a>稀疏数组与密集数组</h3><ul>\n<li>稀疏数组：索引不连续、数组长度大于元素个数的数组，可以简单理解为有 <code>empty</code>（有空隙）的数组。</li>\n<li>密集数组：索引连续、数组长度等于元素个数的数组。</li>\n</ul>\n<p>数组的项数保存在其length属性中，该属性<strong>不是只读</strong>的，因此可以人为修改该属性。</p>\n<ul>\n<li>如果修改的 length 大于原长度，则多出部分会空出来，置为 undefined。</li>\n<li>如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\">arr.length = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">// 此时返回一个length的值等于5的数组对象，但数组并不包含任何实际的元素，不能理解成包含5个值为undefined的元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ &lt;5 empty items&gt; ]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"empty和undefined\"><a href=\"#empty和undefined\" class=\"headerlink\" title=\"empty和undefined\"></a>empty和undefined</h4><p>从上面的例子可以看出，使用<code>new Array(len)</code>创建的数组，输出是一个包含len个empty元素的数组。empty并不是JS的基础数据类型之一，但它到底是什么呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>当访问empty元素时，输出了undefined，empty和undefined是等价的？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr_undefined = [<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ &lt;4 empty items&gt; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr_undefined); <span class=\"comment\">// [ undefined, undefined ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr_undefined[<span class=\"number\">0</span>]); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>] == arr_undefined[<span class=\"number\">0</span>]); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>] === arr_undefined[<span class=\"number\">0</span>]); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(item);&#125;) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">arr_undefined.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(item);&#125;) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.hasOwnProperty(<span class=\"number\">0</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr_undefined.hasOwnProperty(<span class=\"number\">0</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，只有在访问具体单个元素的时候，empty和undefined才表现一致，其余情况并不相同。</p>\n<p>empty是v8引擎对一个空的对象引用的描述，但JS中不存在这种基本类型，因此使用undefined表示。</p>\n<p>在用for循环对empty数组遍历，会将empty转换为undefined，而<code>forEach()</code>会自动忽略empty。</p>\n<h4 id=\"数组的常见方法\"><a href=\"#数组的常见方法\" class=\"headerlink\" title=\"数组的常见方法\"></a>数组的常见方法</h4><h5 id=\"检测方法\"><a href=\"#检测方法\" class=\"headerlink\" title=\"检测方法\"></a>检测方法</h5><table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th align=\"left\">描述</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Array.isArray()</td>\n<td align=\"left\">判断是否为数组</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h5 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>toString()</td>\n<td>将数组转换为字符串</td>\n<td>创建字符串会调用数组中每一项的toString()方法</td>\n</tr>\n<tr>\n<td>valueOf()</td>\n<td>返回数组本身</td>\n<td></td>\n</tr>\n<tr>\n<td>toLocaleString()</td>\n<td>将数组转换为字符串</td>\n<td>创建字符串会调用数组中每一项的toLocaleString()方法</td>\n</tr>\n</tbody></table>\n<h5 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>push()</td>\n<td>向数组末尾插入一个或多个元素，返回修改后数组的长度</td>\n<td></td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>从数组末尾移除一个元素，返回修改后数组的长度</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"队列方法\"><a href=\"#队列方法\" class=\"headerlink\" title=\"队列方法\"></a>队列方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>unshift()</td>\n<td>向数组头部插入一个或多个元素，返回修改后数组的长度</td>\n<td></td>\n</tr>\n<tr>\n<td>shift()</td>\n<td>从数组头部移除一个元素，返回修改后数组的长度</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>reverse()</td>\n<td>对数组反转</td>\n<td></td>\n</tr>\n<tr>\n<td>sort()</td>\n<td>按升序排列数组项，按照Unicode编码，对每个数组项调用toString()</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>如果在使用sort()方法<strong>不带参</strong>，默认按照<strong>Unicode编码</strong>，对数组元素从小到大排序。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort()); <span class=\"comment\">// [ 1, 10, 11, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，数字11排在了2的前面，因为<code>sort()</code>方法是按照<strong>Unicode编码</strong>进行排序的。</p>\n<p>sort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。</p>\n<p>浏览器会根据回调函数的返回值来决定元素的排序：</p>\n<ul>\n<li><strong>如果返回一个大于 0 的值，则元素会交换位置</strong></li>\n<li><strong>如果返回一个小于 0 的值，则元素位置不变</strong></li>\n<li><strong>如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置</strong></li>\n</ul>\n<p>下面是一个简单的比较函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort(compare)); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>更简化的写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b; <span class=\"comment\">// 升序</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>或箭头函数（推荐）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>concat()</td>\n<td>合并数组，返回一个<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>slice()</td>\n<td>从数组中<strong>提取</strong>指定的一个或多个元素，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>splice()</td>\n<td>从数组中<strong>删除</strong>指定的一个或多个元素，返回结果为<strong>被删除元素组成的新数组</strong></td>\n<td>会改变原数组</td>\n</tr>\n</tbody></table>\n<p>splice()有三种使用方法：</p>\n<ul>\n<li><strong>删除：</strong>传入两参。起始位置，删除的项数</li>\n<li><strong>插入：</strong>传入三个或三个以上的参数。起始位置，0，插入的元素</li>\n<li><strong>替换：</strong>传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素</li>\n</ul>\n<h5 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>indexOf()</td>\n<td>从前往后索引，检索一个数组中是否含有指定的元素</td>\n<td></td>\n</tr>\n<tr>\n<td>lastIndexOf()</td>\n<td>从后往前索引，检索一个数组中是否含有指定的元素</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>every()</td>\n<td>确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true</td>\n<td></td>\n</tr>\n<tr>\n<td>filter()</td>\n<td>过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>forEach()</td>\n<td>和 for 循环类似，但需要兼容 IE8 以上</td>\n<td>forEach() 没有返回值。也就是说，它的返回值是 undefined</td>\n</tr>\n<tr>\n<td>map()</td>\n<td>过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>some()</td>\n<td>数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true</td>\n<td>一真即真。只要有一项返回 true，最终的结果就返回 true</td>\n</tr>\n</tbody></table>\n<h5 id=\"归并方法\"><a href=\"#归并方法\" class=\"headerlink\" title=\"归并方法\"></a>归并方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>reduce()</td>\n<td>接收一个函数作为累加器，返回值是回调函数累计处理的结果</td>\n<td></td>\n</tr>\n<tr>\n<td>reduceRight()</td>\n<td>接收一个函数作为累加器，返回值是回调函数累计处理的结果，方向相反</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>reduce()函数接收4个参数：前一个值，当前值，项的索引和数组对象。常见可用于数组求和等：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur, index, array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev + cur;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 32</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h2><h3 id=\"创建Date对象\"><a href=\"#创建Date对象\" class=\"headerlink\" title=\"创建Date对象\"></a>创建Date对象</h3><p><code>var now = new Date()</code></p>\n<p>在调用构造函数而不传递参数的情况下，自动获得当前日期和时间。若想根据特定的日期和时间创建Date对象，则需传入该日期的毫秒数（即UTC时间1970年1月1日00:00:00）。为简化该计算过程，ES提供两个方法：Date.parse()，Date.UTC()。</p>\n<p>实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"内置引用类型（一）——Object、Array、Date\"><a href=\"#内置引用类型（一）——Object、Array、Date\" class=\"headerlink\" title=\"内置引用类型（一）——Object、Array、Date\"></a>内置引用类型（一）——Object、Array、Date</h1>","more":"<p>ES中引用类型是一种数据结构，有时也称为<strong>对象定义</strong>。ES对内置对象（引用类型的值）的定义是：由ES实现提供的、不依赖于宿主环境的对象，这些对象在ES程序执行前就已经存在了。</p>\n<p>类似的：</p>\n<ul>\n<li>引用类型            类</li>\n<li>引用类型的值    对象</li>\n</ul>\n<p>对象是某个特定引用类型的实例，ES提供很多原生引用类型以方便开发使用。</p>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><p>大多<strong>引用类型值</strong>都是Object类型的实例。创建Object实例方式有两种：</p>\n<ul>\n<li>new操作符后跟Object构造函数</li>\n<li>对象字面量</li>\n</ul>\n<p>访问对象属性有两种方法：</p>\n<ul>\n<li>点表示法 <code>person.name</code></li>\n<li>方括号表示法 <code>person[&quot;name&quot;]</code></li>\n</ul>\n<h2 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h2><p>ES的数组的每一项可以保存任意类型的数据。创建数据有两种方式：</p>\n<p><strong>使用字面量</strong></p>\n<p><code>var arr1 = [1, 2];</code></p>\n<p><strong>使用构造函数</strong></p>\n<p><code>let arr = new Array(args);</code></p>\n<p>如果参数为空，则表示创建一个空数组；如果参数为数值，则表示数组的长度；如果有多个参数，表示数组中的元素。</p>\n<h3 id=\"稀疏数组与密集数组\"><a href=\"#稀疏数组与密集数组\" class=\"headerlink\" title=\"稀疏数组与密集数组\"></a>稀疏数组与密集数组</h3><ul>\n<li>稀疏数组：索引不连续、数组长度大于元素个数的数组，可以简单理解为有 <code>empty</code>（有空隙）的数组。</li>\n<li>密集数组：索引连续、数组长度等于元素个数的数组。</li>\n</ul>\n<p>数组的项数保存在其length属性中，该属性<strong>不是只读</strong>的，因此可以人为修改该属性。</p>\n<ul>\n<li>如果修改的 length 大于原长度，则多出部分会空出来，置为 undefined。</li>\n<li>如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\">arr.length = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">// 此时返回一个length的值等于5的数组对象，但数组并不包含任何实际的元素，不能理解成包含5个值为undefined的元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ &lt;5 empty items&gt; ]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"empty和undefined\"><a href=\"#empty和undefined\" class=\"headerlink\" title=\"empty和undefined\"></a>empty和undefined</h4><p>从上面的例子可以看出，使用<code>new Array(len)</code>创建的数组，输出是一个包含len个empty元素的数组。empty并不是JS的基础数据类型之一，但它到底是什么呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>当访问empty元素时，输出了undefined，empty和undefined是等价的？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr_undefined = [<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [ &lt;4 empty items&gt; ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr_undefined); <span class=\"comment\">// [ undefined, undefined ]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>]); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr_undefined[<span class=\"number\">0</span>]); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>] == arr_undefined[<span class=\"number\">0</span>]); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">0</span>] === arr_undefined[<span class=\"number\">0</span>]); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(item);&#125;) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">arr_undefined.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(item);&#125;) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.hasOwnProperty(<span class=\"number\">0</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr_undefined.hasOwnProperty(<span class=\"number\">0</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，只有在访问具体单个元素的时候，empty和undefined才表现一致，其余情况并不相同。</p>\n<p>empty是v8引擎对一个空的对象引用的描述，但JS中不存在这种基本类型，因此使用undefined表示。</p>\n<p>在用for循环对empty数组遍历，会将empty转换为undefined，而<code>forEach()</code>会自动忽略empty。</p>\n<h4 id=\"数组的常见方法\"><a href=\"#数组的常见方法\" class=\"headerlink\" title=\"数组的常见方法\"></a>数组的常见方法</h4><h5 id=\"检测方法\"><a href=\"#检测方法\" class=\"headerlink\" title=\"检测方法\"></a>检测方法</h5><table>\n<thead>\n<tr>\n<th align=\"left\">方法</th>\n<th align=\"left\">描述</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Array.isArray()</td>\n<td align=\"left\">判断是否为数组</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h5 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>toString()</td>\n<td>将数组转换为字符串</td>\n<td>创建字符串会调用数组中每一项的toString()方法</td>\n</tr>\n<tr>\n<td>valueOf()</td>\n<td>返回数组本身</td>\n<td></td>\n</tr>\n<tr>\n<td>toLocaleString()</td>\n<td>将数组转换为字符串</td>\n<td>创建字符串会调用数组中每一项的toLocaleString()方法</td>\n</tr>\n</tbody></table>\n<h5 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>push()</td>\n<td>向数组末尾插入一个或多个元素，返回修改后数组的长度</td>\n<td></td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>从数组末尾移除一个元素，返回修改后数组的长度</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"队列方法\"><a href=\"#队列方法\" class=\"headerlink\" title=\"队列方法\"></a>队列方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>unshift()</td>\n<td>向数组头部插入一个或多个元素，返回修改后数组的长度</td>\n<td></td>\n</tr>\n<tr>\n<td>shift()</td>\n<td>从数组头部移除一个元素，返回修改后数组的长度</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>reverse()</td>\n<td>对数组反转</td>\n<td></td>\n</tr>\n<tr>\n<td>sort()</td>\n<td>按升序排列数组项，按照Unicode编码，对每个数组项调用toString()</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>如果在使用sort()方法<strong>不带参</strong>，默认按照<strong>Unicode编码</strong>，对数组元素从小到大排序。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort()); <span class=\"comment\">// [ 1, 10, 11, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，数字11排在了2的前面，因为<code>sort()</code>方法是按照<strong>Unicode编码</strong>进行排序的。</p>\n<p>sort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。</p>\n<p>浏览器会根据回调函数的返回值来决定元素的排序：</p>\n<ul>\n<li><strong>如果返回一个大于 0 的值，则元素会交换位置</strong></li>\n<li><strong>如果返回一个小于 0 的值，则元素位置不变</strong></li>\n<li><strong>如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置</strong></li>\n</ul>\n<p>下面是一个简单的比较函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort(compare)); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>更简化的写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b; <span class=\"comment\">// 升序</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>或箭头函数（推荐）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>concat()</td>\n<td>合并数组，返回一个<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>slice()</td>\n<td>从数组中<strong>提取</strong>指定的一个或多个元素，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>splice()</td>\n<td>从数组中<strong>删除</strong>指定的一个或多个元素，返回结果为<strong>被删除元素组成的新数组</strong></td>\n<td>会改变原数组</td>\n</tr>\n</tbody></table>\n<p>splice()有三种使用方法：</p>\n<ul>\n<li><strong>删除：</strong>传入两参。起始位置，删除的项数</li>\n<li><strong>插入：</strong>传入三个或三个以上的参数。起始位置，0，插入的元素</li>\n<li><strong>替换：</strong>传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素</li>\n</ul>\n<h5 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>indexOf()</td>\n<td>从前往后索引，检索一个数组中是否含有指定的元素</td>\n<td></td>\n</tr>\n<tr>\n<td>lastIndexOf()</td>\n<td>从后往前索引，检索一个数组中是否含有指定的元素</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>every()</td>\n<td>确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true</td>\n<td></td>\n</tr>\n<tr>\n<td>filter()</td>\n<td>过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>forEach()</td>\n<td>和 for 循环类似，但需要兼容 IE8 以上</td>\n<td>forEach() 没有返回值。也就是说，它的返回值是 undefined</td>\n</tr>\n<tr>\n<td>map()</td>\n<td>过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>some()</td>\n<td>数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true</td>\n<td>一真即真。只要有一项返回 true，最终的结果就返回 true</td>\n</tr>\n</tbody></table>\n<h5 id=\"归并方法\"><a href=\"#归并方法\" class=\"headerlink\" title=\"归并方法\"></a>归并方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>reduce()</td>\n<td>接收一个函数作为累加器，返回值是回调函数累计处理的结果</td>\n<td></td>\n</tr>\n<tr>\n<td>reduceRight()</td>\n<td>接收一个函数作为累加器，返回值是回调函数累计处理的结果，方向相反</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>reduce()函数接收4个参数：前一个值，当前值，项的索引和数组对象。常见可用于数组求和等：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur, index, array</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev + cur;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 32</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h2><h3 id=\"创建Date对象\"><a href=\"#创建Date对象\" class=\"headerlink\" title=\"创建Date对象\"></a>创建Date对象</h3><p><code>var now = new Date()</code></p>\n<p>在调用构造函数而不传递参数的情况下，自动获得当前日期和时间。若想根据特定的日期和时间创建Date对象，则需传入该日期的毫秒数（即UTC时间1970年1月1日00:00:00）。为简化该计算过程，ES提供两个方法：Date.parse()，Date.UTC()。</p>\n<p>实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()</p>"},{"title":"linux关于压缩命令","reprint":false,"date":"2022-02-19T07:24:49.000Z","updated":"2022-02-19T07:24:49.000Z","conver":null,"_content":"\nLinux的压缩一直没有弄清楚，在这里系统整理一遍。\n\n<!--more-->\n\n# Linux中常用压缩格式\n\nlinux常见压缩包以tar.xx格式存在，其中tar是一种打包格式，而后面的gz、bz2等才是压缩方式。\n\n## tar.gz\n\n**压缩：**`tar -zcvf filename.tar.gz [目标文件]`\n\nc:\t**c**reate\t创建新归档\n\n**解压：**`tar -zxvf filename.tar.gz`\n\n其中zxvf含义分别如下\n\nz: 　　g**z**ip  　　　　　　　   压缩格式\n\nx: 　　e**x**tract　　　　　　　　  解压\n\nv:　　 **v**erbose　　　　　　　　详细信息\n\nf: 　　**f**ile(file=archieve)　　　　文件\n\n## tar.bz2\n\n**压缩：**`tar -jcvf filename.tar.bz2 [目标文件]`\n\n**解压：**`tar -jxvf filename.tar.bz2`\n\nj: 　bzip2　　　　　　　　　 压缩格式\n\n其它选项和tar.gz解压含义相同\n\n## tar.xz\n\n**压缩：**`tar -Jcvf filename.tar.bz2 [目标文件]`\n\n**解压：**`tar -Jxvf filename.tar.xz`\n\n注意J大写\n\n## tar.Z\n\n**压缩：**`tar -Zcvf filename.tar.bz2 [目标文件]`\n\n**解压：**`tar -Zxvf filename.tar.xz`\n\n注意Z大写\n\n## 附\n\n**事实上, 从1.15版本开始tar就可以自动识别压缩的格式,故不需人为区分压缩格式就能正确解压**\n\n```\ntar -xvf filename.tar.gz\ntar -xvf filename.tar.bz2\ntar -xvf filename.tar.xz\ntar -xvf filename.tar.Z\n```\n\n## zip\n\nzip包使用zip/unzip命令进行处理。\n\n**压缩：**`zip [目标目录] [待压缩目录]`\n\n**解压：**`unzip [待解压文件] -d [目标目录]`\n","source":"_posts/linux关于解压命令.md","raw":"---\ntitle: linux关于压缩命令\nreprint: false\ndate: 2022-02-19 15:24:49\nupdated: 2022-02-19 15:24:49\nconver:\ncategories: linux\ntags:\n  - linux\n---\n\nLinux的压缩一直没有弄清楚，在这里系统整理一遍。\n\n<!--more-->\n\n# Linux中常用压缩格式\n\nlinux常见压缩包以tar.xx格式存在，其中tar是一种打包格式，而后面的gz、bz2等才是压缩方式。\n\n## tar.gz\n\n**压缩：**`tar -zcvf filename.tar.gz [目标文件]`\n\nc:\t**c**reate\t创建新归档\n\n**解压：**`tar -zxvf filename.tar.gz`\n\n其中zxvf含义分别如下\n\nz: 　　g**z**ip  　　　　　　　   压缩格式\n\nx: 　　e**x**tract　　　　　　　　  解压\n\nv:　　 **v**erbose　　　　　　　　详细信息\n\nf: 　　**f**ile(file=archieve)　　　　文件\n\n## tar.bz2\n\n**压缩：**`tar -jcvf filename.tar.bz2 [目标文件]`\n\n**解压：**`tar -jxvf filename.tar.bz2`\n\nj: 　bzip2　　　　　　　　　 压缩格式\n\n其它选项和tar.gz解压含义相同\n\n## tar.xz\n\n**压缩：**`tar -Jcvf filename.tar.bz2 [目标文件]`\n\n**解压：**`tar -Jxvf filename.tar.xz`\n\n注意J大写\n\n## tar.Z\n\n**压缩：**`tar -Zcvf filename.tar.bz2 [目标文件]`\n\n**解压：**`tar -Zxvf filename.tar.xz`\n\n注意Z大写\n\n## 附\n\n**事实上, 从1.15版本开始tar就可以自动识别压缩的格式,故不需人为区分压缩格式就能正确解压**\n\n```\ntar -xvf filename.tar.gz\ntar -xvf filename.tar.bz2\ntar -xvf filename.tar.xz\ntar -xvf filename.tar.Z\n```\n\n## zip\n\nzip包使用zip/unzip命令进行处理。\n\n**压缩：**`zip [目标目录] [待压缩目录]`\n\n**解压：**`unzip [待解压文件] -d [目标目录]`\n","slug":"linux关于解压命令","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2ae001s7owz1dcj9h6s","content":"<p>Linux的压缩一直没有弄清楚，在这里系统整理一遍。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Linux中常用压缩格式\"><a href=\"#Linux中常用压缩格式\" class=\"headerlink\" title=\"Linux中常用压缩格式\"></a>Linux中常用压缩格式</h1><p>linux常见压缩包以tar.xx格式存在，其中tar是一种打包格式，而后面的gz、bz2等才是压缩方式。</p>\n<h2 id=\"tar-gz\"><a href=\"#tar-gz\" class=\"headerlink\" title=\"tar.gz\"></a>tar.gz</h2><p><strong>压缩：</strong><code>tar -zcvf filename.tar.gz [目标文件]</code></p>\n<p>c:    <strong>c</strong>reate    创建新归档</p>\n<p><strong>解压：</strong><code>tar -zxvf filename.tar.gz</code></p>\n<p>其中zxvf含义分别如下</p>\n<p>z: 　　g<strong>z</strong>ip  　　　　　　　   压缩格式</p>\n<p>x: 　　e<strong>x</strong>tract　　　　　　　　  解压</p>\n<p>v:　　 <strong>v</strong>erbose　　　　　　　　详细信息</p>\n<p>f: 　　<strong>f</strong>ile(file=archieve)　　　　文件</p>\n<h2 id=\"tar-bz2\"><a href=\"#tar-bz2\" class=\"headerlink\" title=\"tar.bz2\"></a>tar.bz2</h2><p><strong>压缩：</strong><code>tar -jcvf filename.tar.bz2 [目标文件]</code></p>\n<p><strong>解压：</strong><code>tar -jxvf filename.tar.bz2</code></p>\n<p>j: 　bzip2　　　　　　　　　 压缩格式</p>\n<p>其它选项和tar.gz解压含义相同</p>\n<h2 id=\"tar-xz\"><a href=\"#tar-xz\" class=\"headerlink\" title=\"tar.xz\"></a>tar.xz</h2><p><strong>压缩：</strong><code>tar -Jcvf filename.tar.bz2 [目标文件]</code></p>\n<p><strong>解压：</strong><code>tar -Jxvf filename.tar.xz</code></p>\n<p>注意J大写</p>\n<h2 id=\"tar-Z\"><a href=\"#tar-Z\" class=\"headerlink\" title=\"tar.Z\"></a>tar.Z</h2><p><strong>压缩：</strong><code>tar -Zcvf filename.tar.bz2 [目标文件]</code></p>\n<p><strong>解压：</strong><code>tar -Zxvf filename.tar.xz</code></p>\n<p>注意Z大写</p>\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><p><strong>事实上, 从1.15版本开始tar就可以自动识别压缩的格式,故不需人为区分压缩格式就能正确解压</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf filename.tar.gz</span><br><span class=\"line\">tar -xvf filename.tar.bz2</span><br><span class=\"line\">tar -xvf filename.tar.xz</span><br><span class=\"line\">tar -xvf filename.tar.Z</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip\"></a>zip</h2><p>zip包使用zip/unzip命令进行处理。</p>\n<p><strong>压缩：</strong><code>zip [目标目录] [待压缩目录]</code></p>\n<p><strong>解压：</strong><code>unzip [待解压文件] -d [目标目录]</code></p>\n","site":{"data":{}},"excerpt":"<p>Linux的压缩一直没有弄清楚，在这里系统整理一遍。</p>","more":"<h1 id=\"Linux中常用压缩格式\"><a href=\"#Linux中常用压缩格式\" class=\"headerlink\" title=\"Linux中常用压缩格式\"></a>Linux中常用压缩格式</h1><p>linux常见压缩包以tar.xx格式存在，其中tar是一种打包格式，而后面的gz、bz2等才是压缩方式。</p>\n<h2 id=\"tar-gz\"><a href=\"#tar-gz\" class=\"headerlink\" title=\"tar.gz\"></a>tar.gz</h2><p><strong>压缩：</strong><code>tar -zcvf filename.tar.gz [目标文件]</code></p>\n<p>c:    <strong>c</strong>reate    创建新归档</p>\n<p><strong>解压：</strong><code>tar -zxvf filename.tar.gz</code></p>\n<p>其中zxvf含义分别如下</p>\n<p>z: 　　g<strong>z</strong>ip  　　　　　　　   压缩格式</p>\n<p>x: 　　e<strong>x</strong>tract　　　　　　　　  解压</p>\n<p>v:　　 <strong>v</strong>erbose　　　　　　　　详细信息</p>\n<p>f: 　　<strong>f</strong>ile(file=archieve)　　　　文件</p>\n<h2 id=\"tar-bz2\"><a href=\"#tar-bz2\" class=\"headerlink\" title=\"tar.bz2\"></a>tar.bz2</h2><p><strong>压缩：</strong><code>tar -jcvf filename.tar.bz2 [目标文件]</code></p>\n<p><strong>解压：</strong><code>tar -jxvf filename.tar.bz2</code></p>\n<p>j: 　bzip2　　　　　　　　　 压缩格式</p>\n<p>其它选项和tar.gz解压含义相同</p>\n<h2 id=\"tar-xz\"><a href=\"#tar-xz\" class=\"headerlink\" title=\"tar.xz\"></a>tar.xz</h2><p><strong>压缩：</strong><code>tar -Jcvf filename.tar.bz2 [目标文件]</code></p>\n<p><strong>解压：</strong><code>tar -Jxvf filename.tar.xz</code></p>\n<p>注意J大写</p>\n<h2 id=\"tar-Z\"><a href=\"#tar-Z\" class=\"headerlink\" title=\"tar.Z\"></a>tar.Z</h2><p><strong>压缩：</strong><code>tar -Zcvf filename.tar.bz2 [目标文件]</code></p>\n<p><strong>解压：</strong><code>tar -Zxvf filename.tar.xz</code></p>\n<p>注意Z大写</p>\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><p><strong>事实上, 从1.15版本开始tar就可以自动识别压缩的格式,故不需人为区分压缩格式就能正确解压</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf filename.tar.gz</span><br><span class=\"line\">tar -xvf filename.tar.bz2</span><br><span class=\"line\">tar -xvf filename.tar.xz</span><br><span class=\"line\">tar -xvf filename.tar.Z</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip\"></a>zip</h2><p>zip包使用zip/unzip命令进行处理。</p>\n<p><strong>压缩：</strong><code>zip [目标目录] [待压缩目录]</code></p>\n<p><strong>解压：</strong><code>unzip [待解压文件] -d [目标目录]</code></p>"},{"title":"英文文献常用语句积累","reprint":false,"date":"2022-02-22T07:48:32.000Z","updated":"2022-02-22T07:48:32.000Z","conver":null,"_content":"\n**在阅读文献的同时积累一些常用的句式和用词**\n\n<!--more-->\n\n| 词句                          | 译文                                     |\n| ----------------------------- | ---------------------------------------- |\n| in practice                   | 在实践中；实际上，事实上                 |\n| architecture                  | 结构；体系结构，架构；建筑设计，建筑风格 |\n| crucial                       | 重要的；决定性的；定局的；决断的；       |\n| a,b,c and d, **respectively** | 分别地，依次地                           |\n| arbitrary                     | 任意的，随心所欲的；                     |\n| coarse-to-fine                | 由粗到精                                 |\n| generalization ability        | 泛化能力                                 |\n| tackle                        | 应付，解决（难题或局面）；（足球等）抢断 |\n| lateral connections           | 横向连接                                 |\n| propagate                     | 传播                                     |\n| gradually                     | 逐步地                                   |\n| semantic information          | 语义信息                                 |\n| be endowed with               | 被赋予                                   |\n| undergo                       | 经历                                     |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n\n","source":"_posts/英文文献常用语句积累.md","raw":"---\ntitle: 英文文献常用语句积累\nreprint: false\ndate: 2022-02-22 15:48:32\nupdated: 2022-02-22 15:48:32\nconver:\ncategories: 文章写作\ntags:\n  - 文献积累\n  - 写作\n---\n\n**在阅读文献的同时积累一些常用的句式和用词**\n\n<!--more-->\n\n| 词句                          | 译文                                     |\n| ----------------------------- | ---------------------------------------- |\n| in practice                   | 在实践中；实际上，事实上                 |\n| architecture                  | 结构；体系结构，架构；建筑设计，建筑风格 |\n| crucial                       | 重要的；决定性的；定局的；决断的；       |\n| a,b,c and d, **respectively** | 分别地，依次地                           |\n| arbitrary                     | 任意的，随心所欲的；                     |\n| coarse-to-fine                | 由粗到精                                 |\n| generalization ability        | 泛化能力                                 |\n| tackle                        | 应付，解决（难题或局面）；（足球等）抢断 |\n| lateral connections           | 横向连接                                 |\n| propagate                     | 传播                                     |\n| gradually                     | 逐步地                                   |\n| semantic information          | 语义信息                                 |\n| be endowed with               | 被赋予                                   |\n| undergo                       | 经历                                     |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n|                               |                                          |\n\n","slug":"英文文献常用语句积累","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2ai00217owzaqa81rme","content":"<p><strong>在阅读文献的同时积累一些常用的句式和用词</strong></p>\n<span id=\"more\"></span>\n\n<table>\n<thead>\n<tr>\n<th>词句</th>\n<th>译文</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>in practice</td>\n<td>在实践中；实际上，事实上</td>\n</tr>\n<tr>\n<td>architecture</td>\n<td>结构；体系结构，架构；建筑设计，建筑风格</td>\n</tr>\n<tr>\n<td>crucial</td>\n<td>重要的；决定性的；定局的；决断的；</td>\n</tr>\n<tr>\n<td>a,b,c and d, <strong>respectively</strong></td>\n<td>分别地，依次地</td>\n</tr>\n<tr>\n<td>arbitrary</td>\n<td>任意的，随心所欲的；</td>\n</tr>\n<tr>\n<td>coarse-to-fine</td>\n<td>由粗到精</td>\n</tr>\n<tr>\n<td>generalization ability</td>\n<td>泛化能力</td>\n</tr>\n<tr>\n<td>tackle</td>\n<td>应付，解决（难题或局面）；（足球等）抢断</td>\n</tr>\n<tr>\n<td>lateral connections</td>\n<td>横向连接</td>\n</tr>\n<tr>\n<td>propagate</td>\n<td>传播</td>\n</tr>\n<tr>\n<td>gradually</td>\n<td>逐步地</td>\n</tr>\n<tr>\n<td>semantic information</td>\n<td>语义信息</td>\n</tr>\n<tr>\n<td>be endowed with</td>\n<td>被赋予</td>\n</tr>\n<tr>\n<td>undergo</td>\n<td>经历</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<p><strong>在阅读文献的同时积累一些常用的句式和用词</strong></p>","more":"<table>\n<thead>\n<tr>\n<th>词句</th>\n<th>译文</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>in practice</td>\n<td>在实践中；实际上，事实上</td>\n</tr>\n<tr>\n<td>architecture</td>\n<td>结构；体系结构，架构；建筑设计，建筑风格</td>\n</tr>\n<tr>\n<td>crucial</td>\n<td>重要的；决定性的；定局的；决断的；</td>\n</tr>\n<tr>\n<td>a,b,c and d, <strong>respectively</strong></td>\n<td>分别地，依次地</td>\n</tr>\n<tr>\n<td>arbitrary</td>\n<td>任意的，随心所欲的；</td>\n</tr>\n<tr>\n<td>coarse-to-fine</td>\n<td>由粗到精</td>\n</tr>\n<tr>\n<td>generalization ability</td>\n<td>泛化能力</td>\n</tr>\n<tr>\n<td>tackle</td>\n<td>应付，解决（难题或局面）；（足球等）抢断</td>\n</tr>\n<tr>\n<td>lateral connections</td>\n<td>横向连接</td>\n</tr>\n<tr>\n<td>propagate</td>\n<td>传播</td>\n</tr>\n<tr>\n<td>gradually</td>\n<td>逐步地</td>\n</tr>\n<tr>\n<td>semantic information</td>\n<td>语义信息</td>\n</tr>\n<tr>\n<td>be endowed with</td>\n<td>被赋予</td>\n</tr>\n<tr>\n<td>undergo</td>\n<td>经历</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>"},{"title":"前端面试汇总","reprint":false,"date":"2022-04-22T13:24:21.000Z","updated":"2022-04-22T13:24:21.000Z","conver":null,"_content":"\n<!--more-->\n\n# 前端面试汇总\n\n## JS部分\n\n### 1.作用域与作用域链\n\n一段程序中用到的名字，限制名字可用性的代码范围就是这个名字的作用域scope。JS的作用域为静态作用域，也可称词法作用域。JS常用的作用域有函数作用域，块级作用域let，const。\n\n作用域链，由多级作用域连续引用的链式结果，先在局部作用域找，如果每找到再向父级作用域找。\n\n### 2.原型与原型链\n\n![img](前端面试汇总/v2-e4815bc5d515f8d6bc4c5c8217c397ee_1440w.jpg)\n\n### 3.js的事件异步单线程\n\n![img](前端面试汇总/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png)\n\nJS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。\n\n- **宏任务（macrotask）：**常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I/O、postMessage、messageChannel、setImmediate（node.js环境）\n- **微任务（microtask）：**如Promise、MutaionObserver、process.nextTick(node.js环境)\n\nJS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。\n\nJS引擎线程和GUI渲染线程是互斥的\n\n宏任务、微任务、DOM渲染执行顺序：\n\n1. 先清空Call Stack\n2. 然后执行当前的微任务\n3. 接下来渲染DOM\n4. 宏任务\n\n**Event Loop**\n\nevent loop在执行各种任务时也将任务队列分为`Task Queue`和`MicroTask Queue`。\n\n不同的执行环境中，Event Loop的执行机制是不同的。\n\n1. 执行一个宏任务（栈中没有就从事件队列中获取）\n2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染\n5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）\n\n### 4.浏览器DOM渲染及阻塞问题\n\n- 阻塞型：\n  - 内联JS\n  - 外联普通JS\n  - 外联defer属性JS\n  - 内联CSS\n  - script标签之前的外联CSS\n\n- 非阻塞型：\n  - 外联sync属性JS\n  - img标签\n  - iframe\n  - script标签后的外联css\n\n### 5. new关键字与Object.create()的区别\n\n```js\n// new 关键字 const a = new Foo();\nlet o = new Object();\no.__proto__ = Foo.prototype;\nFoo.call(o);\na = o;\n\n\n\n// Object.create() a = Object.create(old);\nObject.myCreate = function(obj) {\n  function F(){};\n  F.prototype = obj;\n  return new F();\n}\n```\n\n### 6. typeof和instance of\n\ntypeof用于检测数据类型，对象、数组、null返回值是object，函数返回值是function，undefined返回值是undefined。\n\ninstanceof本意是用来判断A是否是B的实例对象，其检测的是原型。如下面的例子\n\n```js\nconsole.log([] instanceof Array); // true\nconsole.log([] instanceof Object); // true\n```\n\n### 7.Ajax\n\nAsynchronous JavaScript And XML（异步Javascript和XML）。\n\n核心是`XMLHttpRequest`对象，可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。\n\n一个Ajax请求的步骤：\n\n1. 创建异步对象，即XMLHttpRequest对象\n2. 使用open方法设置请求参数。`open(method, url, async)`\n3. 发送请求。`send()`\n4. 注册事件，注册`onreadystatechange`事件，状态改变时就会调用。\n5. 服务端响应，获取返回的数据\n\n```js\n// 创建XMLHttpRequest对象\nlet xmlHttp = new XMLHttpRequest();\n\n// 设置请求的参数，调用open只是启动一个请求以备发送\n// 第三个参数true（异步），false（同步）\nxmlHttp.open('get', 'test.php', false);\n\n// 发送请求，sned方法接收一个参数，要作为请求主体发送的数据，若不需要通过请求主体发送数据，\n// 则必须传入null\nxmlHttp.send(null);\n\n// 注册事件\nxmlHttp.onreadystatechange = function () {\n  if (xmlHttp.readyState == 4 && xmlHttp.status === 200) {\n    console.log('success' + JSON.stringify(xmlhttp.responseText));\n  }\n};\n```\n\n在收到响应后，响应的数据会自动填充XHR对象的属性：\n\n- **responseText：**作为响应主体被返回的文本\n- **responseXML：**如果响应的内容类型是\"text/xml\"或\"application/xml\"，这个属性中将保存包含响应数据的XML DOM文档。\n- **status：**响应的HTTP状态\n- **statusText：**HTTP状态的说明\n\n**readyState属性**\n\n多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下：\n\n- **0：**未初始化，尚未调用open()方法\n- **1：**启动，已经调用open()方法，但尚未调用send()方法\n- **2：**发送，已经调用send()方法，但尚未接收到响应\n- **3：**接收，已经接收到部分响应数据\n- **4：**完成，已经接收到全部的响应数据，已经可以在客户端使用了\n\n每次readyState属性值发生变动，都会触发一次readystatechange事件。\n\n### 8.Promise\n\n**Promise对象的三个状态**\n\n- 初始化（等待中）：pending\n- 成功：fulfilled\n- 失败：rejected\n\n**Promise处理失败的写法**\n\n1. 通过catch方法统一捕获状态变为reject的promise，在promise链中，只要有一个请求失败，就直接执行catch()。\n2. then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行，这种写法不影响promise链的执行。\n\n### 9.async / await\n\n本质是Generator的语法糖\n\n async返回Promise实例对象，await得到异步结果。\n\nawait等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。\n\n如果等到的不是一个Promise对象，await运算结果就是它等到的量。\n\n如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。）\n\n### 10.对象的内部属性和方法\n\n- configurable：能否使用delete、能否修改属性特性、能否修改访问器属性\n\n- enumerable：对象属性能否通过for-in循环\n\n- writable：对象属性是否能修改\n\n- value：对象属性的默认值\n\n  ```js\n  let obj = {};\n  Object.defineProperties(obj, 'name', {\n    configurable: false,\n    enumable: false,\n    writable: false,\n    value: 'zrtty'\n  });\n  ```\n\n### 11.模块化\n\n- **服务器端规范：**CommonJS，Node.js使用的模块化规范\n- **浏览器端规范：**\n  - AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。\n  - CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。\n  - ES6：import，export\n\n### 12.Array的方法\n\n**splice(index, howmany, item1,...itemx); **返回删除的项\n\nindex-规定添加或删除的位置，使用负数，从数组尾部规定位置\n\nhowmany-要删除的数量，如果为0，则不删除项目\n\nitem1...itemx-向数组添加的新项目\n\n##### 操作方法\n\n| 方法     | 描述                                                         | 备注           |\n| -------- | ------------------------------------------------------------ | -------------- |\n| concat() | 合并数组，返回一个**新的数组**                               | 不会改变原数组 |\n| slice()  | 从数组中**提取**指定的一个或多个元素，返回结果为**新的数组** | 不会改变原数组 |\n| splice() | 从数组中**删除**指定的一个或多个元素，返回结果为**被删除元素组成的新数组** | 会改变原数组   |\n\nsplice()有三种使用方法：\n\n- **删除：**传入两参。起始位置，删除的项数\n- **插入：**传入三个或三个以上的参数。起始位置，0，插入的元素\n- **替换：**传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素\n\n##### 位置方法\n\n| 方法          | 描述                                           | 备注 |\n| ------------- | ---------------------------------------------- | ---- |\n| indexOf()     | 从前往后索引，检索一个数组中是否含有指定的元素 |      |\n| lastIndexOf() | 从后往前索引，检索一个数组中是否含有指定的元素 |      |\n\n##### 迭代方法\n\n| 方法      | 描述                                                         | 备注                                                   |\n| --------- | ------------------------------------------------------------ | ------------------------------------------------------ |\n| every()   | 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true |                                                        |\n| filter()  | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |\n| forEach() | 和 for 循环类似，但需要兼容 IE8 以上                         | forEach() 没有返回值。也就是说，它的返回值是 undefined |\n| map()     | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |\n| some()    | 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true | 一真即真。只要有一项返回 true，最终的结果就返回 true   |\n\n##### 重排序方法\n\n| 方法      | 描述                                                         | 备注 |\n| --------- | ------------------------------------------------------------ | ---- |\n| reverse() | 对数组反转                                                   |      |\n| sort()    | 按升序排列数组项，按照Unicode编码，对每个数组项调用toString() |      |\n\n如果在使用sort()方法**不带参**，默认按照**Unicode编码**，对数组元素从小到大排序。\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\nconsole.log(arr.sort()); // [ 1, 10, 11, 2, 3, 5 ]\n```\n\n可以看到，数字11排在了2的前面，因为`sort()`方法是按照**Unicode编码**进行排序的。\n\nsort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。\n\n浏览器会根据回调函数的返回值来决定元素的排序：\n\n- **如果返回一个大于 0 的值，则元素会交换位置**\n- **如果返回一个小于 0 的值，则元素位置不变**\n- **如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置**\n\n下面是一个简单的比较函数：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nfunction compare(value1, value2) {\n  if (value1 < value2) {\n    return -1;\n  } else if (value1 > value2) {\n    return 1;\n  } else {\n    return 0\n  }\n}\n\nconsole.log(arr.sort(compare)); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n更简化的写法：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.sort(function (a, b){\n  return a - b; // 升序\n});\n\nconsole.log(result); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n或箭头函数（推荐）：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.sort((a, b) => a - b);\n\nconsole.log(result); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n### 13.防抖与节流\n\n```js\n// 防抖\nfunction debounce(fn, delay = 200) {\n  let timeout;\n  return function(){\n    timeout && clearTimeout(timeout);\n    timeout = setTimeout(fn.bind(this), delay);\n  }\n}\n```\n\n```js\n// 节流\nfunction throttle(fn, threshold = 200) {\n  let timeout;\n  let start = new Date();\n  return function(){\n    const current = new Date() - 0;\n    timeout && clearTimeout(timeout);\n    if (current - start >= threshold) {\n      fn.call(this, ...arguments);\n      start = current;\n    } else {\n      timeout = setTimeout(fn.bind(this), threshold, ...arguments);\n    }\n  }\n}\n```\n\n\n\n## HTML部分\n\n### 标签语义化\n\nHTML 标签语义化是让大家直观的认识标签(markup)和属性(attribute)的用途和作用。\n\n如`<header>`，`<footer>`，`<article>`，`<section>`\n\n## CSS部分\n\n### 1.css元素权重\n\n| 行内样式    | 1000 |\n| :---------- | ---- |\n| ID选择器    | 0100 |\n| class选择器 | 0010 |\n| 标签、伪类  | 0001 |\n| *           | 0000 |\n\n### 2.position定位属性\n\n- **static：**默认正常流\n- **absolute：**完全脱标，完全不占位置，父类要有定位（relative，absolute，fixed），若没有则以Document文档定位\n- **relative：**相对于其在标准流中的位置，不脱标，占据原来位置\n- **fixed：**完全脱标，完全不占位置，只认浏览器的可视窗口\n- **sticky：**根据正常文档流定位，不脱标\n\n### 3.display属性\n\n- **inline：**行内元素\n- **block：**块级元素\n- **inline-block：**行内块元素\n- **flex：**弹性盒，单轴\n- **grid：**网格，双轴\n\n### 4.浮动属性\n\n相邻浮动的块元素可以并在一行，超出父级宽度就换行。*浮动让行内元素或块元素转化为行内块元素（不确定）。*\n\n高度塌陷：父元素如果没有设置尺寸，父元素内整体浮动的元素无法撑开父元素，父元素需要清除浮动。\n\n1. 在父元素内部最后添加一个没有高度的元素，设置clear: both;\n2. 使用::after伪类为父元素添加后标签\n3. 通过对父元素设置overflow属性，使父元素形成BFC，父元素高度计算会包括浮动元素的高度。\n\n### 6.圣杯与双飞翼布局\n\n两种布局都是三栏布局，两边固定宽度，中间自适应，中间栏要放在文挡流前面以优先渲染。\n\n**圣杯布局**\n\n首先设置三栏浮动，设置中间div宽度100%，左右div被挤到后一行。此时给中间div设置左右padding以便给左右div留出位置。为了让左div回到上一行，设置其position为relative并margin-left设为-100%，再添加left: -300px使其回到第一行最左侧。同理，右div设置position为relative并margin-left：-200px，right：-200px。\n\n**双飞翼布局**\n\n中间的div多了一个子容器，通过控制其子容器的margin或padding空出左右两列的宽度。\n\n### 7.居中问题\n\n**水平居中**\n\n行内元素一行文字\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      text-align: center;\n    }\n```\n\n```html\n  <div class=\"content\">\n    <p>okkkk</p>\n  </div>\n```\n\n![image-20220422203142481](前端面试汇总/image-20220422203142481.png)\n\n行内元素多行文字\n\n```css\n    .content p {\n      padding: 10px;\n      margin: 0;\n    }\n```\n\n```html\n  <div class=\"content\">\n    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Facere eius praesentium saepe, exercitationem enim magni\n      a. Ea aut fugit recusandae a quod animi quibusdam repellendus vel? Dolorem molestiae eius fugiat?Lorem ipsum,\n      dolor sit amet consectetur adipisicing elit. Consectetur quis ratione est optio expedita vero hic sapiente enim\n      minima placeat mollitia recusandae deserunt sed, laboriosam dolore. Odit beatae provident nisi!</p>\n  </div>\n```\n\n![image-20220422203626056](前端面试汇总/image-20220422203626056.png)\n\n块级元素方法一\n\n```css\n    .inner {\n      background-color: coral;\n      height: 100px;\n      width: 100px;\n      margin: 0 auto;\n    }\n```\n\n```html\n  <div class=\"content\">\n    <div class=\"inner\"></div>\n  </div>\n```\n\n块级元素方法二\n\n先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      position: relative;\n    }\n\n    .inner {\n      background-color: coral;\n      height: 100px;\n      width: 100px;\n      position: absolute;\n      left: 50%;\n      transform: translateX(-50%);\n    }\n```\n\n块级元素方法三\n\n通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      justify-content: center;\n      display: flex;\n    }\n```\n\n块级元素方法四\n\n通过flex将父容器设置为为Flex布局，再设置子元素居中。\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      display: flex;\n    }\n    \n    .inner {\n      margin: 0 auto;\n    }\n```\n\n**垂直居中**\n\n单行行内元素\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      line-height: 200px;\n    }\n```\n\n多行内联元素垂直居中 flex\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      display: flex;\n      justify-content: center;\n    }\n```\n\n多行内联元素垂直居中 table\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      display: table;\n    }\n    \n    .content p {\n      display: table-cell;\n      vertical-align: middle;\n    }\n```\n\n块级元素垂直居中一\n\n通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      position: relative;\n    }\n\n    .inner {\n      background-color: coral;\n      height: 100px;\n      width: 100px;\n      position: absolute;\n      top: 50%;\n      margin-top: -50px;\n    }\n```\n\n块级元素垂直居中二\n\n当垂直居中的元素的高度和宽度未知时，可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中。\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      position: relative;\n    }\n\n    .inner {\n      background-color: coral;\n      height: 100px;\n      width: 100px;\n      position: absolute;\n      top: 50%;\n      transform: translateY(-50%);\n    }\n```\n\n块级元素垂直居中三 flex\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      display: flex;\n      align-items: center;\n    }\n```\n\n### 8.性能优化\n\n\n\n## 算法部分\n\n### 排序算法\n\n#### 冒泡\n\n```js\nlet temp;\nfor (let i = 0; i < arr.length; ++i) {\n  for (let j = i + 1 ; j < arr.length; ++j) {\n    if (arr[j] < arr[i]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n    }\n  }\n}\n```\n\n时间复杂度O(n^2)\n\n#### 选择排序\n\n```js\nfunction selectionSort(arr) {\n  let len = arr.length;\n  let temp;\n  for (let i = 0; i < len - 1; ++i) {\n    let minIndex = i;\n    for (let j = i + 1; j < len; ++j) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n    temp = arr[i];\n    arr[i] = arr[minIndex];\n    arr[minIndex] = temp;\n  }\n  return arr;\n}\n```\n\n时间复杂度O(n^2)\n\n#### 插入排序\n\n```js\nfunction insertionSort(arr) {\n  let len = arr.length;\n  let preIndex, current;\n  for (let i = 1; i < len; ++i) {\n    preIndex = i - 1;\n    current = arr[i];\n    while(preIndex >= 0 && arr[preIndex] > current) {\n      arr[preIndex + 1] = arr[preIndex];\n      preIndex--;\n    }\n    arr[preIndex + 1] = current;\n  }\n  return arr;\n}\n```\n\n时间复杂度O(n^2)\n\n#### 快排\n\n```js\nfunction quickSort(arr, left, right) {\n  let temp, l = left, r = right;\n  if (left >= right) {\n    return;\n  }\n  temp = arr[left];\n  while (left < right) {\n    //先从右往左开始搜索, 直到找到一个比temp小的数字\n    while (arr[right] >= temp && left < right) right--;\n    arr[left] = arr[right];\n    //从左往右开始搜索，直到找到一个比temp大的数字\n    while (arr[left] <= temp && left < right) left++;\n    arr[right] = arr[left];\n  }\n  arr[left] = temp;\n  quickSort(arr, l, left);\n  quickSort(arr, left + 1, r);\n}\n```\n\n时间复杂度最差O(n^2)，平均为O(nlogn)\n\n#### 桶排序\n\n```js\n\n```\n\n为使桶排序更加高效，需要做到两点：\n\n1. 额外空间充足下，尽可能增加桶的数量\n2. 使用的映射函数能够将输入的N个数据均匀的分配到K个桶中\n\n#### 堆排序\n\n\n\n#### 归并排序\n\n\n\n### 二分查找\n\n### 二叉树\n\n#### 前序遍历\n\n```\n\n```\n\n\n\n#### 中序遍历\n\n#### 后序遍历\n\n#### 层序遍历\n\n### 图\n\n#### BFS（广度优先）\n\n#### DFS（深度优先）\n\n### 贪心算法\n\n### \n\n## 网络部分\n\n### 1.OSI七层模型\n\n应用层：HTTP、HTTPS、FTP、SSH\n\n表示层\n\n会话层\n\n传输层：TCP、UDP\n\n网络层：IP、ARP\n\n数据链路层\n\n物理层\n\n### 2.HTTP协议常用状态码\n\n1xx：信息，请求收到，继续处理\n2xx：成功，行为被成功地接受、理解和采纳\t200\n3xx：重定向，为了完成请求，必须进一步执行的动作\t\n4xx：客户端错误，请求包含语法错误或者请求无法实现\t400\t403\t404\n5xx：服务器错误，服务器不能实现一种明显无效的请求\t500\t502\n\n### 3.tcp三次握手四次挥手\n\n![三次握手.png](前端面试汇总/1460000020610340.png)\n\n![image.png](前端面试汇总/1460000020610341.png)\n\n**第四次挥手释放连接，等待2MSL的意义？**\n\n**MSL**是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\n\n为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。\n\n**两个理由：**\n\n1. 保证客户端发送的最后一个ACK报文段能够到达服务端。\n   这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。\n2. 防止“已失效的连接请求报文段”出现在本连接中。\n   客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。\n\n### 4.http与https\n\nhttp协议以明文方式传输，易被中间人窃取。HTTPS在HTTP的基础上加入了SSL/TLS协议，依靠证书来验证服务器的身份，并为浏览器与服务器之间的通信加密。\n\n![img](前端面试汇总/70.png)\n\n### 5.Http简述\n\nHttp协议是超文本传输协议的缩写，是位于应用层的协议，是基于TCP/IP通信协议来传递数据，HTTP不提供任何方式的数据加密。\n\n\n\n## 框架部分\n\n### 1.vue的生命周期\n\n![实例的生命周期](前端面试汇总/lifecycle.svg)\n\n### 2.双向绑定\n\n**Vue2.x**\n\n实现核心是数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`，对data的每个属性进行了getter和setter的拦截。\n\n1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者\n2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数\n3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图\n4、mvvm入口函数，整合以上三者\n\n\n\n### 3.diff算法\n\nvue的diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。\n\ndiff整体策略为：**深度优先，同层比较**\n\n1. 比较只会在同层级进行, 不会跨层级比较\n2. 比较的过程中，循环从两边向中间收拢\n\n![img](前端面试汇总/9e3c68d1b0884d9ca0f8ffc5ee64a28etplv-k3u1fbpfcp-watermark.image)\n\n","source":"_posts/前端面试汇总.md","raw":"---\ntitle: 前端面试汇总\nreprint: false\ndate: 2022-04-22 21:24:21\nupdated: 2022-04-22 21:24:21\nconver:\ncategories: 前端\ntags:\n  - 面试\n---\n\n<!--more-->\n\n# 前端面试汇总\n\n## JS部分\n\n### 1.作用域与作用域链\n\n一段程序中用到的名字，限制名字可用性的代码范围就是这个名字的作用域scope。JS的作用域为静态作用域，也可称词法作用域。JS常用的作用域有函数作用域，块级作用域let，const。\n\n作用域链，由多级作用域连续引用的链式结果，先在局部作用域找，如果每找到再向父级作用域找。\n\n### 2.原型与原型链\n\n![img](前端面试汇总/v2-e4815bc5d515f8d6bc4c5c8217c397ee_1440w.jpg)\n\n### 3.js的事件异步单线程\n\n![img](前端面试汇总/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png)\n\nJS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。\n\n- **宏任务（macrotask）：**常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I/O、postMessage、messageChannel、setImmediate（node.js环境）\n- **微任务（microtask）：**如Promise、MutaionObserver、process.nextTick(node.js环境)\n\nJS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。\n\nJS引擎线程和GUI渲染线程是互斥的\n\n宏任务、微任务、DOM渲染执行顺序：\n\n1. 先清空Call Stack\n2. 然后执行当前的微任务\n3. 接下来渲染DOM\n4. 宏任务\n\n**Event Loop**\n\nevent loop在执行各种任务时也将任务队列分为`Task Queue`和`MicroTask Queue`。\n\n不同的执行环境中，Event Loop的执行机制是不同的。\n\n1. 执行一个宏任务（栈中没有就从事件队列中获取）\n2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染\n5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）\n\n### 4.浏览器DOM渲染及阻塞问题\n\n- 阻塞型：\n  - 内联JS\n  - 外联普通JS\n  - 外联defer属性JS\n  - 内联CSS\n  - script标签之前的外联CSS\n\n- 非阻塞型：\n  - 外联sync属性JS\n  - img标签\n  - iframe\n  - script标签后的外联css\n\n### 5. new关键字与Object.create()的区别\n\n```js\n// new 关键字 const a = new Foo();\nlet o = new Object();\no.__proto__ = Foo.prototype;\nFoo.call(o);\na = o;\n\n\n\n// Object.create() a = Object.create(old);\nObject.myCreate = function(obj) {\n  function F(){};\n  F.prototype = obj;\n  return new F();\n}\n```\n\n### 6. typeof和instance of\n\ntypeof用于检测数据类型，对象、数组、null返回值是object，函数返回值是function，undefined返回值是undefined。\n\ninstanceof本意是用来判断A是否是B的实例对象，其检测的是原型。如下面的例子\n\n```js\nconsole.log([] instanceof Array); // true\nconsole.log([] instanceof Object); // true\n```\n\n### 7.Ajax\n\nAsynchronous JavaScript And XML（异步Javascript和XML）。\n\n核心是`XMLHttpRequest`对象，可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。\n\n一个Ajax请求的步骤：\n\n1. 创建异步对象，即XMLHttpRequest对象\n2. 使用open方法设置请求参数。`open(method, url, async)`\n3. 发送请求。`send()`\n4. 注册事件，注册`onreadystatechange`事件，状态改变时就会调用。\n5. 服务端响应，获取返回的数据\n\n```js\n// 创建XMLHttpRequest对象\nlet xmlHttp = new XMLHttpRequest();\n\n// 设置请求的参数，调用open只是启动一个请求以备发送\n// 第三个参数true（异步），false（同步）\nxmlHttp.open('get', 'test.php', false);\n\n// 发送请求，sned方法接收一个参数，要作为请求主体发送的数据，若不需要通过请求主体发送数据，\n// 则必须传入null\nxmlHttp.send(null);\n\n// 注册事件\nxmlHttp.onreadystatechange = function () {\n  if (xmlHttp.readyState == 4 && xmlHttp.status === 200) {\n    console.log('success' + JSON.stringify(xmlhttp.responseText));\n  }\n};\n```\n\n在收到响应后，响应的数据会自动填充XHR对象的属性：\n\n- **responseText：**作为响应主体被返回的文本\n- **responseXML：**如果响应的内容类型是\"text/xml\"或\"application/xml\"，这个属性中将保存包含响应数据的XML DOM文档。\n- **status：**响应的HTTP状态\n- **statusText：**HTTP状态的说明\n\n**readyState属性**\n\n多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下：\n\n- **0：**未初始化，尚未调用open()方法\n- **1：**启动，已经调用open()方法，但尚未调用send()方法\n- **2：**发送，已经调用send()方法，但尚未接收到响应\n- **3：**接收，已经接收到部分响应数据\n- **4：**完成，已经接收到全部的响应数据，已经可以在客户端使用了\n\n每次readyState属性值发生变动，都会触发一次readystatechange事件。\n\n### 8.Promise\n\n**Promise对象的三个状态**\n\n- 初始化（等待中）：pending\n- 成功：fulfilled\n- 失败：rejected\n\n**Promise处理失败的写法**\n\n1. 通过catch方法统一捕获状态变为reject的promise，在promise链中，只要有一个请求失败，就直接执行catch()。\n2. then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行，这种写法不影响promise链的执行。\n\n### 9.async / await\n\n本质是Generator的语法糖\n\n async返回Promise实例对象，await得到异步结果。\n\nawait等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。\n\n如果等到的不是一个Promise对象，await运算结果就是它等到的量。\n\n如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。）\n\n### 10.对象的内部属性和方法\n\n- configurable：能否使用delete、能否修改属性特性、能否修改访问器属性\n\n- enumerable：对象属性能否通过for-in循环\n\n- writable：对象属性是否能修改\n\n- value：对象属性的默认值\n\n  ```js\n  let obj = {};\n  Object.defineProperties(obj, 'name', {\n    configurable: false,\n    enumable: false,\n    writable: false,\n    value: 'zrtty'\n  });\n  ```\n\n### 11.模块化\n\n- **服务器端规范：**CommonJS，Node.js使用的模块化规范\n- **浏览器端规范：**\n  - AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。\n  - CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。\n  - ES6：import，export\n\n### 12.Array的方法\n\n**splice(index, howmany, item1,...itemx); **返回删除的项\n\nindex-规定添加或删除的位置，使用负数，从数组尾部规定位置\n\nhowmany-要删除的数量，如果为0，则不删除项目\n\nitem1...itemx-向数组添加的新项目\n\n##### 操作方法\n\n| 方法     | 描述                                                         | 备注           |\n| -------- | ------------------------------------------------------------ | -------------- |\n| concat() | 合并数组，返回一个**新的数组**                               | 不会改变原数组 |\n| slice()  | 从数组中**提取**指定的一个或多个元素，返回结果为**新的数组** | 不会改变原数组 |\n| splice() | 从数组中**删除**指定的一个或多个元素，返回结果为**被删除元素组成的新数组** | 会改变原数组   |\n\nsplice()有三种使用方法：\n\n- **删除：**传入两参。起始位置，删除的项数\n- **插入：**传入三个或三个以上的参数。起始位置，0，插入的元素\n- **替换：**传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素\n\n##### 位置方法\n\n| 方法          | 描述                                           | 备注 |\n| ------------- | ---------------------------------------------- | ---- |\n| indexOf()     | 从前往后索引，检索一个数组中是否含有指定的元素 |      |\n| lastIndexOf() | 从后往前索引，检索一个数组中是否含有指定的元素 |      |\n\n##### 迭代方法\n\n| 方法      | 描述                                                         | 备注                                                   |\n| --------- | ------------------------------------------------------------ | ------------------------------------------------------ |\n| every()   | 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true |                                                        |\n| filter()  | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |\n| forEach() | 和 for 循环类似，但需要兼容 IE8 以上                         | forEach() 没有返回值。也就是说，它的返回值是 undefined |\n| map()     | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |\n| some()    | 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true | 一真即真。只要有一项返回 true，最终的结果就返回 true   |\n\n##### 重排序方法\n\n| 方法      | 描述                                                         | 备注 |\n| --------- | ------------------------------------------------------------ | ---- |\n| reverse() | 对数组反转                                                   |      |\n| sort()    | 按升序排列数组项，按照Unicode编码，对每个数组项调用toString() |      |\n\n如果在使用sort()方法**不带参**，默认按照**Unicode编码**，对数组元素从小到大排序。\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\nconsole.log(arr.sort()); // [ 1, 10, 11, 2, 3, 5 ]\n```\n\n可以看到，数字11排在了2的前面，因为`sort()`方法是按照**Unicode编码**进行排序的。\n\nsort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。\n\n浏览器会根据回调函数的返回值来决定元素的排序：\n\n- **如果返回一个大于 0 的值，则元素会交换位置**\n- **如果返回一个小于 0 的值，则元素位置不变**\n- **如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置**\n\n下面是一个简单的比较函数：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nfunction compare(value1, value2) {\n  if (value1 < value2) {\n    return -1;\n  } else if (value1 > value2) {\n    return 1;\n  } else {\n    return 0\n  }\n}\n\nconsole.log(arr.sort(compare)); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n更简化的写法：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.sort(function (a, b){\n  return a - b; // 升序\n});\n\nconsole.log(result); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n或箭头函数（推荐）：\n\n```js\nlet arr = [1, 2, 3, 5, 10, 11];\n\nlet result = arr.sort((a, b) => a - b);\n\nconsole.log(result); // [ 1, 2, 3, 5, 10, 11 ]\n```\n\n### 13.防抖与节流\n\n```js\n// 防抖\nfunction debounce(fn, delay = 200) {\n  let timeout;\n  return function(){\n    timeout && clearTimeout(timeout);\n    timeout = setTimeout(fn.bind(this), delay);\n  }\n}\n```\n\n```js\n// 节流\nfunction throttle(fn, threshold = 200) {\n  let timeout;\n  let start = new Date();\n  return function(){\n    const current = new Date() - 0;\n    timeout && clearTimeout(timeout);\n    if (current - start >= threshold) {\n      fn.call(this, ...arguments);\n      start = current;\n    } else {\n      timeout = setTimeout(fn.bind(this), threshold, ...arguments);\n    }\n  }\n}\n```\n\n\n\n## HTML部分\n\n### 标签语义化\n\nHTML 标签语义化是让大家直观的认识标签(markup)和属性(attribute)的用途和作用。\n\n如`<header>`，`<footer>`，`<article>`，`<section>`\n\n## CSS部分\n\n### 1.css元素权重\n\n| 行内样式    | 1000 |\n| :---------- | ---- |\n| ID选择器    | 0100 |\n| class选择器 | 0010 |\n| 标签、伪类  | 0001 |\n| *           | 0000 |\n\n### 2.position定位属性\n\n- **static：**默认正常流\n- **absolute：**完全脱标，完全不占位置，父类要有定位（relative，absolute，fixed），若没有则以Document文档定位\n- **relative：**相对于其在标准流中的位置，不脱标，占据原来位置\n- **fixed：**完全脱标，完全不占位置，只认浏览器的可视窗口\n- **sticky：**根据正常文档流定位，不脱标\n\n### 3.display属性\n\n- **inline：**行内元素\n- **block：**块级元素\n- **inline-block：**行内块元素\n- **flex：**弹性盒，单轴\n- **grid：**网格，双轴\n\n### 4.浮动属性\n\n相邻浮动的块元素可以并在一行，超出父级宽度就换行。*浮动让行内元素或块元素转化为行内块元素（不确定）。*\n\n高度塌陷：父元素如果没有设置尺寸，父元素内整体浮动的元素无法撑开父元素，父元素需要清除浮动。\n\n1. 在父元素内部最后添加一个没有高度的元素，设置clear: both;\n2. 使用::after伪类为父元素添加后标签\n3. 通过对父元素设置overflow属性，使父元素形成BFC，父元素高度计算会包括浮动元素的高度。\n\n### 6.圣杯与双飞翼布局\n\n两种布局都是三栏布局，两边固定宽度，中间自适应，中间栏要放在文挡流前面以优先渲染。\n\n**圣杯布局**\n\n首先设置三栏浮动，设置中间div宽度100%，左右div被挤到后一行。此时给中间div设置左右padding以便给左右div留出位置。为了让左div回到上一行，设置其position为relative并margin-left设为-100%，再添加left: -300px使其回到第一行最左侧。同理，右div设置position为relative并margin-left：-200px，right：-200px。\n\n**双飞翼布局**\n\n中间的div多了一个子容器，通过控制其子容器的margin或padding空出左右两列的宽度。\n\n### 7.居中问题\n\n**水平居中**\n\n行内元素一行文字\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      text-align: center;\n    }\n```\n\n```html\n  <div class=\"content\">\n    <p>okkkk</p>\n  </div>\n```\n\n![image-20220422203142481](前端面试汇总/image-20220422203142481.png)\n\n行内元素多行文字\n\n```css\n    .content p {\n      padding: 10px;\n      margin: 0;\n    }\n```\n\n```html\n  <div class=\"content\">\n    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Facere eius praesentium saepe, exercitationem enim magni\n      a. Ea aut fugit recusandae a quod animi quibusdam repellendus vel? Dolorem molestiae eius fugiat?Lorem ipsum,\n      dolor sit amet consectetur adipisicing elit. Consectetur quis ratione est optio expedita vero hic sapiente enim\n      minima placeat mollitia recusandae deserunt sed, laboriosam dolore. Odit beatae provident nisi!</p>\n  </div>\n```\n\n![image-20220422203626056](前端面试汇总/image-20220422203626056.png)\n\n块级元素方法一\n\n```css\n    .inner {\n      background-color: coral;\n      height: 100px;\n      width: 100px;\n      margin: 0 auto;\n    }\n```\n\n```html\n  <div class=\"content\">\n    <div class=\"inner\"></div>\n  </div>\n```\n\n块级元素方法二\n\n先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      position: relative;\n    }\n\n    .inner {\n      background-color: coral;\n      height: 100px;\n      width: 100px;\n      position: absolute;\n      left: 50%;\n      transform: translateX(-50%);\n    }\n```\n\n块级元素方法三\n\n通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      justify-content: center;\n      display: flex;\n    }\n```\n\n块级元素方法四\n\n通过flex将父容器设置为为Flex布局，再设置子元素居中。\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      display: flex;\n    }\n    \n    .inner {\n      margin: 0 auto;\n    }\n```\n\n**垂直居中**\n\n单行行内元素\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      line-height: 200px;\n    }\n```\n\n多行内联元素垂直居中 flex\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      display: flex;\n      justify-content: center;\n    }\n```\n\n多行内联元素垂直居中 table\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      display: table;\n    }\n    \n    .content p {\n      display: table-cell;\n      vertical-align: middle;\n    }\n```\n\n块级元素垂直居中一\n\n通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      position: relative;\n    }\n\n    .inner {\n      background-color: coral;\n      height: 100px;\n      width: 100px;\n      position: absolute;\n      top: 50%;\n      margin-top: -50px;\n    }\n```\n\n块级元素垂直居中二\n\n当垂直居中的元素的高度和宽度未知时，可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中。\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      position: relative;\n    }\n\n    .inner {\n      background-color: coral;\n      height: 100px;\n      width: 100px;\n      position: absolute;\n      top: 50%;\n      transform: translateY(-50%);\n    }\n```\n\n块级元素垂直居中三 flex\n\n```css\n    .content {\n      height: 200px;\n      background-color: khaki;\n      display: flex;\n      align-items: center;\n    }\n```\n\n### 8.性能优化\n\n\n\n## 算法部分\n\n### 排序算法\n\n#### 冒泡\n\n```js\nlet temp;\nfor (let i = 0; i < arr.length; ++i) {\n  for (let j = i + 1 ; j < arr.length; ++j) {\n    if (arr[j] < arr[i]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n    }\n  }\n}\n```\n\n时间复杂度O(n^2)\n\n#### 选择排序\n\n```js\nfunction selectionSort(arr) {\n  let len = arr.length;\n  let temp;\n  for (let i = 0; i < len - 1; ++i) {\n    let minIndex = i;\n    for (let j = i + 1; j < len; ++j) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j;\n      }\n    }\n    temp = arr[i];\n    arr[i] = arr[minIndex];\n    arr[minIndex] = temp;\n  }\n  return arr;\n}\n```\n\n时间复杂度O(n^2)\n\n#### 插入排序\n\n```js\nfunction insertionSort(arr) {\n  let len = arr.length;\n  let preIndex, current;\n  for (let i = 1; i < len; ++i) {\n    preIndex = i - 1;\n    current = arr[i];\n    while(preIndex >= 0 && arr[preIndex] > current) {\n      arr[preIndex + 1] = arr[preIndex];\n      preIndex--;\n    }\n    arr[preIndex + 1] = current;\n  }\n  return arr;\n}\n```\n\n时间复杂度O(n^2)\n\n#### 快排\n\n```js\nfunction quickSort(arr, left, right) {\n  let temp, l = left, r = right;\n  if (left >= right) {\n    return;\n  }\n  temp = arr[left];\n  while (left < right) {\n    //先从右往左开始搜索, 直到找到一个比temp小的数字\n    while (arr[right] >= temp && left < right) right--;\n    arr[left] = arr[right];\n    //从左往右开始搜索，直到找到一个比temp大的数字\n    while (arr[left] <= temp && left < right) left++;\n    arr[right] = arr[left];\n  }\n  arr[left] = temp;\n  quickSort(arr, l, left);\n  quickSort(arr, left + 1, r);\n}\n```\n\n时间复杂度最差O(n^2)，平均为O(nlogn)\n\n#### 桶排序\n\n```js\n\n```\n\n为使桶排序更加高效，需要做到两点：\n\n1. 额外空间充足下，尽可能增加桶的数量\n2. 使用的映射函数能够将输入的N个数据均匀的分配到K个桶中\n\n#### 堆排序\n\n\n\n#### 归并排序\n\n\n\n### 二分查找\n\n### 二叉树\n\n#### 前序遍历\n\n```\n\n```\n\n\n\n#### 中序遍历\n\n#### 后序遍历\n\n#### 层序遍历\n\n### 图\n\n#### BFS（广度优先）\n\n#### DFS（深度优先）\n\n### 贪心算法\n\n### \n\n## 网络部分\n\n### 1.OSI七层模型\n\n应用层：HTTP、HTTPS、FTP、SSH\n\n表示层\n\n会话层\n\n传输层：TCP、UDP\n\n网络层：IP、ARP\n\n数据链路层\n\n物理层\n\n### 2.HTTP协议常用状态码\n\n1xx：信息，请求收到，继续处理\n2xx：成功，行为被成功地接受、理解和采纳\t200\n3xx：重定向，为了完成请求，必须进一步执行的动作\t\n4xx：客户端错误，请求包含语法错误或者请求无法实现\t400\t403\t404\n5xx：服务器错误，服务器不能实现一种明显无效的请求\t500\t502\n\n### 3.tcp三次握手四次挥手\n\n![三次握手.png](前端面试汇总/1460000020610340.png)\n\n![image.png](前端面试汇总/1460000020610341.png)\n\n**第四次挥手释放连接，等待2MSL的意义？**\n\n**MSL**是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\n\n为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。\n\n**两个理由：**\n\n1. 保证客户端发送的最后一个ACK报文段能够到达服务端。\n   这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。\n2. 防止“已失效的连接请求报文段”出现在本连接中。\n   客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。\n\n### 4.http与https\n\nhttp协议以明文方式传输，易被中间人窃取。HTTPS在HTTP的基础上加入了SSL/TLS协议，依靠证书来验证服务器的身份，并为浏览器与服务器之间的通信加密。\n\n![img](前端面试汇总/70.png)\n\n### 5.Http简述\n\nHttp协议是超文本传输协议的缩写，是位于应用层的协议，是基于TCP/IP通信协议来传递数据，HTTP不提供任何方式的数据加密。\n\n\n\n## 框架部分\n\n### 1.vue的生命周期\n\n![实例的生命周期](前端面试汇总/lifecycle.svg)\n\n### 2.双向绑定\n\n**Vue2.x**\n\n实现核心是数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`，对data的每个属性进行了getter和setter的拦截。\n\n1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者\n2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数\n3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图\n4、mvvm入口函数，整合以上三者\n\n\n\n### 3.diff算法\n\nvue的diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。\n\ndiff整体策略为：**深度优先，同层比较**\n\n1. 比较只会在同层级进行, 不会跨层级比较\n2. 比较的过程中，循环从两边向中间收拢\n\n![img](前端面试汇总/9e3c68d1b0884d9ca0f8ffc5ee64a28etplv-k3u1fbpfcp-watermark.image)\n\n","slug":"前端面试汇总","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl2hhl2ap002e7owz2iwwe6vm","content":"<span id=\"more\"></span>\n\n<h1 id=\"前端面试汇总\"><a href=\"#前端面试汇总\" class=\"headerlink\" title=\"前端面试汇总\"></a>前端面试汇总</h1><h2 id=\"JS部分\"><a href=\"#JS部分\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h2><h3 id=\"1-作用域与作用域链\"><a href=\"#1-作用域与作用域链\" class=\"headerlink\" title=\"1.作用域与作用域链\"></a>1.作用域与作用域链</h3><p>一段程序中用到的名字，限制名字可用性的代码范围就是这个名字的作用域scope。JS的作用域为静态作用域，也可称词法作用域。JS常用的作用域有函数作用域，块级作用域let，const。</p>\n<p>作用域链，由多级作用域连续引用的链式结果，先在局部作用域找，如果每找到再向父级作用域找。</p>\n<h3 id=\"2-原型与原型链\"><a href=\"#2-原型与原型链\" class=\"headerlink\" title=\"2.原型与原型链\"></a>2.原型与原型链</h3><p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/04/22/7f255ae33214/v2-e4815bc5d515f8d6bc4c5c8217c397ee_1440w.jpg\" alt=\"img\" class=\"lazyload\"></p>\n<h3 id=\"3-js的事件异步单线程\"><a href=\"#3-js的事件异步单线程\" class=\"headerlink\" title=\"3.js的事件异步单线程\"></a>3.js的事件异步单线程</h3><p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/04/22/7f255ae33214/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png\" alt=\"img\" class=\"lazyload\"></p>\n<p>JS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。</p>\n<ul>\n<li><strong>宏任务（macrotask）：</strong>常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I/O、postMessage、messageChannel、setImmediate（node.js环境）</li>\n<li><strong>微任务（microtask）：</strong>如Promise、MutaionObserver、process.nextTick(node.js环境)</li>\n</ul>\n<p>JS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。</p>\n<p>JS引擎线程和GUI渲染线程是互斥的</p>\n<p>宏任务、微任务、DOM渲染执行顺序：</p>\n<ol>\n<li>先清空Call Stack</li>\n<li>然后执行当前的微任务</li>\n<li>接下来渲染DOM</li>\n<li>宏任务</li>\n</ol>\n<p><strong>Event Loop</strong></p>\n<p>event loop在执行各种任务时也将任务队列分为<code>Task Queue</code>和<code>MicroTask Queue</code>。</p>\n<p>不同的执行环境中，Event Loop的执行机制是不同的。</p>\n<ol>\n<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>\n<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>\n<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>\n<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>\n</ol>\n<h3 id=\"4-浏览器DOM渲染及阻塞问题\"><a href=\"#4-浏览器DOM渲染及阻塞问题\" class=\"headerlink\" title=\"4.浏览器DOM渲染及阻塞问题\"></a>4.浏览器DOM渲染及阻塞问题</h3><ul>\n<li><p>阻塞型：</p>\n<ul>\n<li>内联JS</li>\n<li>外联普通JS</li>\n<li>外联defer属性JS</li>\n<li>内联CSS</li>\n<li>script标签之前的外联CSS</li>\n</ul>\n</li>\n<li><p>非阻塞型：</p>\n<ul>\n<li>外联sync属性JS</li>\n<li>img标签</li>\n<li>iframe</li>\n<li>script标签后的外联css</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-new关键字与Object-create-的区别\"><a href=\"#5-new关键字与Object-create-的区别\" class=\"headerlink\" title=\"5. new关键字与Object.create()的区别\"></a>5. new关键字与Object.create()的区别</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new 关键字 const a = new Foo();</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">o.__proto__ = Foo.prototype;</span><br><span class=\"line\">Foo.call(o);</span><br><span class=\"line\">a = o;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.create() a = Object.create(old);</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.myCreate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  F.prototype = obj;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-typeof和instance-of\"><a href=\"#6-typeof和instance-of\" class=\"headerlink\" title=\"6. typeof和instance of\"></a>6. typeof和instance of</h3><p>typeof用于检测数据类型，对象、数组、null返回值是object，函数返回值是function，undefined返回值是undefined。</p>\n<p>instanceof本意是用来判断A是否是B的实例对象，其检测的是原型。如下面的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log([] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-Ajax\"><a href=\"#7-Ajax\" class=\"headerlink\" title=\"7.Ajax\"></a>7.Ajax</h3><p>Asynchronous JavaScript And XML（异步Javascript和XML）。</p>\n<p>核心是<code>XMLHttpRequest</code>对象，可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。</p>\n<p>一个Ajax请求的步骤：</p>\n<ol>\n<li>创建异步对象，即XMLHttpRequest对象</li>\n<li>使用open方法设置请求参数。<code>open(method, url, async)</code></li>\n<li>发送请求。<code>send()</code></li>\n<li>注册事件，注册<code>onreadystatechange</code>事件，状态改变时就会调用。</li>\n<li>服务端响应，获取返回的数据</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建XMLHttpRequest对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> xmlHttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置请求的参数，调用open只是启动一个请求以备发送</span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数true（异步），false（同步）</span></span><br><span class=\"line\">xmlHttp.open(<span class=\"string\">&#x27;get&#x27;</span>, <span class=\"string\">&#x27;test.php&#x27;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送请求，sned方法接收一个参数，要作为请求主体发送的数据，若不需要通过请求主体发送数据，</span></span><br><span class=\"line\"><span class=\"comment\">// 则必须传入null</span></span><br><span class=\"line\">xmlHttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">xmlHttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xmlHttp.readyState == <span class=\"number\">4</span> &amp;&amp; xmlHttp.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;success&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(xmlhttp.responseText));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在收到响应后，响应的数据会自动填充XHR对象的属性：</p>\n<ul>\n<li><strong>responseText：</strong>作为响应主体被返回的文本</li>\n<li><strong>responseXML：</strong>如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含响应数据的XML DOM文档。</li>\n<li><strong>status：</strong>响应的HTTP状态</li>\n<li><strong>statusText：</strong>HTTP状态的说明</li>\n</ul>\n<p><strong>readyState属性</strong></p>\n<p>多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下：</p>\n<ul>\n<li><strong>0：</strong>未初始化，尚未调用open()方法</li>\n<li><strong>1：</strong>启动，已经调用open()方法，但尚未调用send()方法</li>\n<li><strong>2：</strong>发送，已经调用send()方法，但尚未接收到响应</li>\n<li><strong>3：</strong>接收，已经接收到部分响应数据</li>\n<li><strong>4：</strong>完成，已经接收到全部的响应数据，已经可以在客户端使用了</li>\n</ul>\n<p>每次readyState属性值发生变动，都会触发一次readystatechange事件。</p>\n<h3 id=\"8-Promise\"><a href=\"#8-Promise\" class=\"headerlink\" title=\"8.Promise\"></a>8.Promise</h3><p><strong>Promise对象的三个状态</strong></p>\n<ul>\n<li>初始化（等待中）：pending</li>\n<li>成功：fulfilled</li>\n<li>失败：rejected</li>\n</ul>\n<p><strong>Promise处理失败的写法</strong></p>\n<ol>\n<li>通过catch方法统一捕获状态变为reject的promise，在promise链中，只要有一个请求失败，就直接执行catch()。</li>\n<li>then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行，这种写法不影响promise链的执行。</li>\n</ol>\n<h3 id=\"9-async-await\"><a href=\"#9-async-await\" class=\"headerlink\" title=\"9.async / await\"></a>9.async / await</h3><p>本质是Generator的语法糖</p>\n<p> async返回Promise实例对象，await得到异步结果。</p>\n<p>await等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。</p>\n<p>如果等到的不是一个Promise对象，await运算结果就是它等到的量。</p>\n<p>如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。）</p>\n<h3 id=\"10-对象的内部属性和方法\"><a href=\"#10-对象的内部属性和方法\" class=\"headerlink\" title=\"10.对象的内部属性和方法\"></a>10.对象的内部属性和方法</h3><ul>\n<li><p>configurable：能否使用delete、能否修改属性特性、能否修改访问器属性</p>\n</li>\n<li><p>enumerable：对象属性能否通过for-in循环</p>\n</li>\n<li><p>writable：对象属性是否能修改</p>\n</li>\n<li><p>value：对象属性的默认值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(obj, <span class=\"string\">&#x27;name&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"string\">&#x27;zrtty&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"11-模块化\"><a href=\"#11-模块化\" class=\"headerlink\" title=\"11.模块化\"></a>11.模块化</h3><ul>\n<li><strong>服务器端规范：</strong>CommonJS，Node.js使用的模块化规范</li>\n<li><strong>浏览器端规范：</strong><ul>\n<li>AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。</li>\n<li>CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。</li>\n<li>ES6：import，export</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"12-Array的方法\"><a href=\"#12-Array的方法\" class=\"headerlink\" title=\"12.Array的方法\"></a>12.Array的方法</h3><p>**splice(index, howmany, item1,…itemx); **返回删除的项</p>\n<p>index-规定添加或删除的位置，使用负数，从数组尾部规定位置</p>\n<p>howmany-要删除的数量，如果为0，则不删除项目</p>\n<p>item1…itemx-向数组添加的新项目</p>\n<h5 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>concat()</td>\n<td>合并数组，返回一个<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>slice()</td>\n<td>从数组中<strong>提取</strong>指定的一个或多个元素，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>splice()</td>\n<td>从数组中<strong>删除</strong>指定的一个或多个元素，返回结果为<strong>被删除元素组成的新数组</strong></td>\n<td>会改变原数组</td>\n</tr>\n</tbody></table>\n<p>splice()有三种使用方法：</p>\n<ul>\n<li><strong>删除：</strong>传入两参。起始位置，删除的项数</li>\n<li><strong>插入：</strong>传入三个或三个以上的参数。起始位置，0，插入的元素</li>\n<li><strong>替换：</strong>传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素</li>\n</ul>\n<h5 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>indexOf()</td>\n<td>从前往后索引，检索一个数组中是否含有指定的元素</td>\n<td></td>\n</tr>\n<tr>\n<td>lastIndexOf()</td>\n<td>从后往前索引，检索一个数组中是否含有指定的元素</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>every()</td>\n<td>确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true</td>\n<td></td>\n</tr>\n<tr>\n<td>filter()</td>\n<td>过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>forEach()</td>\n<td>和 for 循环类似，但需要兼容 IE8 以上</td>\n<td>forEach() 没有返回值。也就是说，它的返回值是 undefined</td>\n</tr>\n<tr>\n<td>map()</td>\n<td>过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>some()</td>\n<td>数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true</td>\n<td>一真即真。只要有一项返回 true，最终的结果就返回 true</td>\n</tr>\n</tbody></table>\n<h5 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>reverse()</td>\n<td>对数组反转</td>\n<td></td>\n</tr>\n<tr>\n<td>sort()</td>\n<td>按升序排列数组项，按照Unicode编码，对每个数组项调用toString()</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>如果在使用sort()方法<strong>不带参</strong>，默认按照<strong>Unicode编码</strong>，对数组元素从小到大排序。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort()); <span class=\"comment\">// [ 1, 10, 11, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，数字11排在了2的前面，因为<code>sort()</code>方法是按照<strong>Unicode编码</strong>进行排序的。</p>\n<p>sort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。</p>\n<p>浏览器会根据回调函数的返回值来决定元素的排序：</p>\n<ul>\n<li><strong>如果返回一个大于 0 的值，则元素会交换位置</strong></li>\n<li><strong>如果返回一个小于 0 的值，则元素位置不变</strong></li>\n<li><strong>如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置</strong></li>\n</ul>\n<p>下面是一个简单的比较函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort(compare)); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>更简化的写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b; <span class=\"comment\">// 升序</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>或箭头函数（推荐）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-防抖与节流\"><a href=\"#13-防抖与节流\" class=\"headerlink\" title=\"13.防抖与节流\"></a>13.防抖与节流</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 防抖</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, delay = <span class=\"number\">200</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    timeout &amp;&amp; <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    timeout = <span class=\"built_in\">setTimeout</span>(fn.bind(<span class=\"built_in\">this</span>), delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节流</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, threshold = <span class=\"number\">200</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> current = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - <span class=\"number\">0</span>;</span><br><span class=\"line\">    timeout &amp;&amp; <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current - start &gt;= threshold) &#123;</span><br><span class=\"line\">      fn.call(<span class=\"built_in\">this</span>, ...arguments);</span><br><span class=\"line\">      start = current;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(fn.bind(<span class=\"built_in\">this</span>), threshold, ...arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"HTML部分\"><a href=\"#HTML部分\" class=\"headerlink\" title=\"HTML部分\"></a>HTML部分</h2><h3 id=\"标签语义化\"><a href=\"#标签语义化\" class=\"headerlink\" title=\"标签语义化\"></a>标签语义化</h3><p>HTML 标签语义化是让大家直观的认识标签(markup)和属性(attribute)的用途和作用。</p>\n<p>如<code>&lt;header&gt;</code>，<code>&lt;footer&gt;</code>，<code>&lt;article&gt;</code>，<code>&lt;section&gt;</code></p>\n<h2 id=\"CSS部分\"><a href=\"#CSS部分\" class=\"headerlink\" title=\"CSS部分\"></a>CSS部分</h2><h3 id=\"1-css元素权重\"><a href=\"#1-css元素权重\" class=\"headerlink\" title=\"1.css元素权重\"></a>1.css元素权重</h3><table>\n<thead>\n<tr>\n<th align=\"left\">行内样式</th>\n<th>1000</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ID选择器</td>\n<td>0100</td>\n</tr>\n<tr>\n<td align=\"left\">class选择器</td>\n<td>0010</td>\n</tr>\n<tr>\n<td align=\"left\">标签、伪类</td>\n<td>0001</td>\n</tr>\n<tr>\n<td align=\"left\">*</td>\n<td>0000</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-position定位属性\"><a href=\"#2-position定位属性\" class=\"headerlink\" title=\"2.position定位属性\"></a>2.position定位属性</h3><ul>\n<li><strong>static：</strong>默认正常流</li>\n<li><strong>absolute：</strong>完全脱标，完全不占位置，父类要有定位（relative，absolute，fixed），若没有则以Document文档定位</li>\n<li><strong>relative：</strong>相对于其在标准流中的位置，不脱标，占据原来位置</li>\n<li><strong>fixed：</strong>完全脱标，完全不占位置，只认浏览器的可视窗口</li>\n<li><strong>sticky：</strong>根据正常文档流定位，不脱标</li>\n</ul>\n<h3 id=\"3-display属性\"><a href=\"#3-display属性\" class=\"headerlink\" title=\"3.display属性\"></a>3.display属性</h3><ul>\n<li><strong>inline：</strong>行内元素</li>\n<li><strong>block：</strong>块级元素</li>\n<li><strong>inline-block：</strong>行内块元素</li>\n<li><strong>flex：</strong>弹性盒，单轴</li>\n<li><strong>grid：</strong>网格，双轴</li>\n</ul>\n<h3 id=\"4-浮动属性\"><a href=\"#4-浮动属性\" class=\"headerlink\" title=\"4.浮动属性\"></a>4.浮动属性</h3><p>相邻浮动的块元素可以并在一行，超出父级宽度就换行。<em>浮动让行内元素或块元素转化为行内块元素（不确定）。</em></p>\n<p>高度塌陷：父元素如果没有设置尺寸，父元素内整体浮动的元素无法撑开父元素，父元素需要清除浮动。</p>\n<ol>\n<li>在父元素内部最后添加一个没有高度的元素，设置clear: both;</li>\n<li>使用::after伪类为父元素添加后标签</li>\n<li>通过对父元素设置overflow属性，使父元素形成BFC，父元素高度计算会包括浮动元素的高度。</li>\n</ol>\n<h3 id=\"6-圣杯与双飞翼布局\"><a href=\"#6-圣杯与双飞翼布局\" class=\"headerlink\" title=\"6.圣杯与双飞翼布局\"></a>6.圣杯与双飞翼布局</h3><p>两种布局都是三栏布局，两边固定宽度，中间自适应，中间栏要放在文挡流前面以优先渲染。</p>\n<p><strong>圣杯布局</strong></p>\n<p>首先设置三栏浮动，设置中间div宽度100%，左右div被挤到后一行。此时给中间div设置左右padding以便给左右div留出位置。为了让左div回到上一行，设置其position为relative并margin-left设为-100%，再添加left: -300px使其回到第一行最左侧。同理，右div设置position为relative并margin-left：-200px，right：-200px。</p>\n<p><strong>双飞翼布局</strong></p>\n<p>中间的div多了一个子容器，通过控制其子容器的margin或padding空出左右两列的宽度。</p>\n<h3 id=\"7-居中问题\"><a href=\"#7-居中问题\" class=\"headerlink\" title=\"7.居中问题\"></a>7.居中问题</h3><p><strong>水平居中</strong></p>\n<p>行内元素一行文字</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>okkkk<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/04/22/7f255ae33214/image-20220422203142481.png\" alt=\"image-20220422203142481\" class=\"lazyload\"></p>\n<p>行内元素多行文字</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Facere eius praesentium saepe, exercitationem enim magni</span><br><span class=\"line\">    a. Ea aut fugit recusandae a quod animi quibusdam repellendus vel? Dolorem molestiae eius fugiat?Lorem ipsum,</span><br><span class=\"line\">    dolor sit amet consectetur adipisicing elit. Consectetur quis ratione est optio expedita vero hic sapiente enim</span><br><span class=\"line\">    minima placeat mollitia recusandae deserunt sed, laboriosam dolore. Odit beatae provident nisi!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/04/22/7f255ae33214/image-20220422203626056.png\" alt=\"image-20220422203626056\" class=\"lazyload\"></p>\n<p>块级元素方法一</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;inner&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>块级元素方法二</p>\n<p>先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(-<span class=\"number\">50%</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素方法三</p>\n<p>通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素方法四</p>\n<p>通过flex将父容器设置为为Flex布局，再设置子元素居中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>垂直居中</strong></p>\n<p>单行行内元素</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多行内联元素垂直居中 flex</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多行内联元素垂直居中 table</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.content</span> <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">  <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素垂直居中一</p>\n<p>通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素垂直居中二</p>\n<p>当垂直居中的元素的高度和宽度未知时，可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-<span class=\"number\">50%</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素垂直居中三 flex</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-性能优化\"><a href=\"#8-性能优化\" class=\"headerlink\" title=\"8.性能优化\"></a>8.性能优化</h3><h2 id=\"算法部分\"><a href=\"#算法部分\" class=\"headerlink\" title=\"算法部分\"></a>算法部分</h2><h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><h4 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> temp;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span> ; j &lt; arr.length; ++j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class=\"line\">      temp = arr[j];</span><br><span class=\"line\">      arr[j] = arr[i];</span><br><span class=\"line\">      arr[i] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n^2)</p>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minIndex = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; ++j) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class=\"line\">        minIndex = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    temp = arr[i];</span><br><span class=\"line\">    arr[i] = arr[minIndex];</span><br><span class=\"line\">    arr[minIndex] = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n^2)</p>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> preIndex, current;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">    preIndex = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">    current = arr[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class=\"line\">      arr[preIndex + <span class=\"number\">1</span>] = arr[preIndex];</span><br><span class=\"line\">      preIndex--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[preIndex + <span class=\"number\">1</span>] = current;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n^2)</p>\n<h4 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr, left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp, l = left, r = right;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left &gt;= right) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  temp = arr[left];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//先从右往左开始搜索, 直到找到一个比temp小的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arr[right] &gt;= temp &amp;&amp; left &lt; right) right--;</span><br><span class=\"line\">    arr[left] = arr[right];</span><br><span class=\"line\">    <span class=\"comment\">//从左往右开始搜索，直到找到一个比temp大的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arr[left] &lt;= temp &amp;&amp; left &lt; right) left++;</span><br><span class=\"line\">    arr[right] = arr[left];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr[left] = temp;</span><br><span class=\"line\">  quickSort(arr, l, left);</span><br><span class=\"line\">  quickSort(arr, left + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度最差O(n^2)，平均为O(nlogn)</p>\n<h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>为使桶排序更加高效，需要做到两点：</p>\n<ol>\n<li>额外空间充足下，尽可能增加桶的数量</li>\n<li>使用的映射函数能够将输入的N个数据均匀的分配到K个桶中</li>\n</ol>\n<h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><h4 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h4><h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><h4 id=\"BFS（广度优先）\"><a href=\"#BFS（广度优先）\" class=\"headerlink\" title=\"BFS（广度优先）\"></a>BFS（广度优先）</h4><h4 id=\"DFS（深度优先）\"><a href=\"#DFS（深度优先）\" class=\"headerlink\" title=\"DFS（深度优先）\"></a>DFS（深度优先）</h4><h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3><h3 id><a href=\"#\" class=\"headerlink\" title></a></h3><h2 id=\"网络部分\"><a href=\"#网络部分\" class=\"headerlink\" title=\"网络部分\"></a>网络部分</h2><h3 id=\"1-OSI七层模型\"><a href=\"#1-OSI七层模型\" class=\"headerlink\" title=\"1.OSI七层模型\"></a>1.OSI七层模型</h3><p>应用层：HTTP、HTTPS、FTP、SSH</p>\n<p>表示层</p>\n<p>会话层</p>\n<p>传输层：TCP、UDP</p>\n<p>网络层：IP、ARP</p>\n<p>数据链路层</p>\n<p>物理层</p>\n<h3 id=\"2-HTTP协议常用状态码\"><a href=\"#2-HTTP协议常用状态码\" class=\"headerlink\" title=\"2.HTTP协议常用状态码\"></a>2.HTTP协议常用状态码</h3><p>1xx：信息，请求收到，继续处理<br>2xx：成功，行为被成功地接受、理解和采纳    200<br>3xx：重定向，为了完成请求，必须进一步执行的动作<br>4xx：客户端错误，请求包含语法错误或者请求无法实现    400    403    404<br>5xx：服务器错误，服务器不能实现一种明显无效的请求    500    502</p>\n<h3 id=\"3-tcp三次握手四次挥手\"><a href=\"#3-tcp三次握手四次挥手\" class=\"headerlink\" title=\"3.tcp三次握手四次挥手\"></a>3.tcp三次握手四次挥手</h3><p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/04/22/7f255ae33214/1460000020610340.png\" alt=\"三次握手.png\" class=\"lazyload\"></p>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/04/22/7f255ae33214/1460000020610341.png\" alt=\"image.png\" class=\"lazyload\"></p>\n<p><strong>第四次挥手释放连接，等待2MSL的意义？</strong></p>\n<p><strong>MSL</strong>是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>\n<p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>\n<p><strong>两个理由：</strong></p>\n<ol>\n<li>保证客户端发送的最后一个ACK报文段能够到达服务端。<br>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li>\n<li>防止“已失效的连接请求报文段”出现在本连接中。<br>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>\n</ol>\n<h3 id=\"4-http与https\"><a href=\"#4-http与https\" class=\"headerlink\" title=\"4.http与https\"></a>4.http与https</h3><p>http协议以明文方式传输，易被中间人窃取。HTTPS在HTTP的基础上加入了SSL/TLS协议，依靠证书来验证服务器的身份，并为浏览器与服务器之间的通信加密。</p>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/04/22/7f255ae33214/70.png\" alt=\"img\" class=\"lazyload\"></p>\n<h3 id=\"5-Http简述\"><a href=\"#5-Http简述\" class=\"headerlink\" title=\"5.Http简述\"></a>5.Http简述</h3><p>Http协议是超文本传输协议的缩写，是位于应用层的协议，是基于TCP/IP通信协议来传递数据，HTTP不提供任何方式的数据加密。</p>\n<h2 id=\"框架部分\"><a href=\"#框架部分\" class=\"headerlink\" title=\"框架部分\"></a>框架部分</h2><h3 id=\"1-vue的生命周期\"><a href=\"#1-vue的生命周期\" class=\"headerlink\" title=\"1.vue的生命周期\"></a>1.vue的生命周期</h3><p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/04/22/7f255ae33214/lifecycle.svg\" alt=\"实例的生命周期\" class=\"lazyload\"></p>\n<h3 id=\"2-双向绑定\"><a href=\"#2-双向绑定\" class=\"headerlink\" title=\"2.双向绑定\"></a>2.双向绑定</h3><p><strong>Vue2.x</strong></p>\n<p>实现核心是数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>，对data的每个属性进行了getter和setter的拦截。</p>\n<p>1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数<br>3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>4、mvvm入口函数，整合以上三者</p>\n<h3 id=\"3-diff算法\"><a href=\"#3-diff算法\" class=\"headerlink\" title=\"3.diff算法\"></a>3.diff算法</h3><p>vue的diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。</p>\n<p>diff整体策略为：<strong>深度优先，同层比较</strong></p>\n<ol>\n<li>比较只会在同层级进行, 不会跨层级比较</li>\n<li>比较的过程中，循环从两边向中间收拢</li>\n</ol>\n<p><img data-fancybox=\"gallery\" data-sizes=\"auto\" data-src=\"/2022/04/22/7f255ae33214/9e3c68d1b0884d9ca0f8ffc5ee64a28etplv-k3u1fbpfcp-watermark.image\" alt=\"img\" class=\"lazyload\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端面试汇总\"><a href=\"#前端面试汇总\" class=\"headerlink\" title=\"前端面试汇总\"></a>前端面试汇总</h1><h2 id=\"JS部分\"><a href=\"#JS部分\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h2><h3 id=\"1-作用域与作用域链\"><a href=\"#1-作用域与作用域链\" class=\"headerlink\" title=\"1.作用域与作用域链\"></a>1.作用域与作用域链</h3><p>一段程序中用到的名字，限制名字可用性的代码范围就是这个名字的作用域scope。JS的作用域为静态作用域，也可称词法作用域。JS常用的作用域有函数作用域，块级作用域let，const。</p>\n<p>作用域链，由多级作用域连续引用的链式结果，先在局部作用域找，如果每找到再向父级作用域找。</p>\n<h3 id=\"2-原型与原型链\"><a href=\"#2-原型与原型链\" class=\"headerlink\" title=\"2.原型与原型链\"></a>2.原型与原型链</h3><p><img src=\"/2022/04/22/7f255ae33214/v2-e4815bc5d515f8d6bc4c5c8217c397ee_1440w.jpg\" alt=\"img\"></p>\n<h3 id=\"3-js的事件异步单线程\"><a href=\"#3-js的事件异步单线程\" class=\"headerlink\" title=\"3.js的事件异步单线程\"></a>3.js的事件异步单线程</h3><p><img src=\"/2022/04/22/7f255ae33214/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png\" alt=\"img\"></p>\n<p>JS的异步任务又分为宏任务和微任务两种。宏任务是由宿主（浏览器、Node）发起的，而微任务由JS自身发起。</p>\n<ul>\n<li><strong>宏任务（macrotask）：</strong>常见的定时器，用户交互事件等。如script（整体代码）、setTimeout、setInterval、UI渲染、I/O、postMessage、messageChannel、setImmediate（node.js环境）</li>\n<li><strong>微任务（microtask）：</strong>如Promise、MutaionObserver、process.nextTick(node.js环境)</li>\n</ul>\n<p>JS代码在执行时，首先执行同步任务，当同步任务执行完毕后，开始执行异步任务，异步任务执行时，首先按照代码的层级，同层级先执行微任务其次执行宏任务，以此类推。</p>\n<p>JS引擎线程和GUI渲染线程是互斥的</p>\n<p>宏任务、微任务、DOM渲染执行顺序：</p>\n<ol>\n<li>先清空Call Stack</li>\n<li>然后执行当前的微任务</li>\n<li>接下来渲染DOM</li>\n<li>宏任务</li>\n</ol>\n<p><strong>Event Loop</strong></p>\n<p>event loop在执行各种任务时也将任务队列分为<code>Task Queue</code>和<code>MicroTask Queue</code>。</p>\n<p>不同的执行环境中，Event Loop的执行机制是不同的。</p>\n<ol>\n<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>\n<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>\n<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>\n<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>\n</ol>\n<h3 id=\"4-浏览器DOM渲染及阻塞问题\"><a href=\"#4-浏览器DOM渲染及阻塞问题\" class=\"headerlink\" title=\"4.浏览器DOM渲染及阻塞问题\"></a>4.浏览器DOM渲染及阻塞问题</h3><ul>\n<li><p>阻塞型：</p>\n<ul>\n<li>内联JS</li>\n<li>外联普通JS</li>\n<li>外联defer属性JS</li>\n<li>内联CSS</li>\n<li>script标签之前的外联CSS</li>\n</ul>\n</li>\n<li><p>非阻塞型：</p>\n<ul>\n<li>外联sync属性JS</li>\n<li>img标签</li>\n<li>iframe</li>\n<li>script标签后的外联css</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-new关键字与Object-create-的区别\"><a href=\"#5-new关键字与Object-create-的区别\" class=\"headerlink\" title=\"5. new关键字与Object.create()的区别\"></a>5. new关键字与Object.create()的区别</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new 关键字 const a = new Foo();</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">o.__proto__ = Foo.prototype;</span><br><span class=\"line\">Foo.call(o);</span><br><span class=\"line\">a = o;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.create() a = Object.create(old);</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.myCreate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  F.prototype = obj;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-typeof和instance-of\"><a href=\"#6-typeof和instance-of\" class=\"headerlink\" title=\"6. typeof和instance of\"></a>6. typeof和instance of</h3><p>typeof用于检测数据类型，对象、数组、null返回值是object，函数返回值是function，undefined返回值是undefined。</p>\n<p>instanceof本意是用来判断A是否是B的实例对象，其检测的是原型。如下面的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log([] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-Ajax\"><a href=\"#7-Ajax\" class=\"headerlink\" title=\"7.Ajax\"></a>7.Ajax</h3><p>Asynchronous JavaScript And XML（异步Javascript和XML）。</p>\n<p>核心是<code>XMLHttpRequest</code>对象，可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。</p>\n<p>一个Ajax请求的步骤：</p>\n<ol>\n<li>创建异步对象，即XMLHttpRequest对象</li>\n<li>使用open方法设置请求参数。<code>open(method, url, async)</code></li>\n<li>发送请求。<code>send()</code></li>\n<li>注册事件，注册<code>onreadystatechange</code>事件，状态改变时就会调用。</li>\n<li>服务端响应，获取返回的数据</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建XMLHttpRequest对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> xmlHttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置请求的参数，调用open只是启动一个请求以备发送</span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数true（异步），false（同步）</span></span><br><span class=\"line\">xmlHttp.open(<span class=\"string\">&#x27;get&#x27;</span>, <span class=\"string\">&#x27;test.php&#x27;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送请求，sned方法接收一个参数，要作为请求主体发送的数据，若不需要通过请求主体发送数据，</span></span><br><span class=\"line\"><span class=\"comment\">// 则必须传入null</span></span><br><span class=\"line\">xmlHttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">xmlHttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xmlHttp.readyState == <span class=\"number\">4</span> &amp;&amp; xmlHttp.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;success&#x27;</span> + <span class=\"built_in\">JSON</span>.stringify(xmlhttp.responseText));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在收到响应后，响应的数据会自动填充XHR对象的属性：</p>\n<ul>\n<li><strong>responseText：</strong>作为响应主体被返回的文本</li>\n<li><strong>responseXML：</strong>如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含响应数据的XML DOM文档。</li>\n<li><strong>status：</strong>响应的HTTP状态</li>\n<li><strong>statusText：</strong>HTTP状态的说明</li>\n</ul>\n<p><strong>readyState属性</strong></p>\n<p>多数情况下，我们还是要发送异步请求。此时可以检测XHR对象的readyState属性，该属性表示请求和响应过程中的当前活动阶段。这个属性的值如下：</p>\n<ul>\n<li><strong>0：</strong>未初始化，尚未调用open()方法</li>\n<li><strong>1：</strong>启动，已经调用open()方法，但尚未调用send()方法</li>\n<li><strong>2：</strong>发送，已经调用send()方法，但尚未接收到响应</li>\n<li><strong>3：</strong>接收，已经接收到部分响应数据</li>\n<li><strong>4：</strong>完成，已经接收到全部的响应数据，已经可以在客户端使用了</li>\n</ul>\n<p>每次readyState属性值发生变动，都会触发一次readystatechange事件。</p>\n<h3 id=\"8-Promise\"><a href=\"#8-Promise\" class=\"headerlink\" title=\"8.Promise\"></a>8.Promise</h3><p><strong>Promise对象的三个状态</strong></p>\n<ul>\n<li>初始化（等待中）：pending</li>\n<li>成功：fulfilled</li>\n<li>失败：rejected</li>\n</ul>\n<p><strong>Promise处理失败的写法</strong></p>\n<ol>\n<li>通过catch方法统一捕获状态变为reject的promise，在promise链中，只要有一个请求失败，就直接执行catch()。</li>\n<li>then可以传递两个参数，第一个参数为resolve后执行，第二个参数为reject后执行，这种写法不影响promise链的执行。</li>\n</ol>\n<h3 id=\"9-async-await\"><a href=\"#9-async-await\" class=\"headerlink\" title=\"9.async / await\"></a>9.async / await</h3><p>本质是Generator的语法糖</p>\n<p> async返回Promise实例对象，await得到异步结果。</p>\n<p>await等待的是一个表达式，这个表达式可以是Promise对象或者其他值。（也即没有特殊限定一定是等待async）。</p>\n<p>如果等到的不是一个Promise对象，await运算结果就是它等到的量。</p>\n<p>如果等到的是一个Promise对象，它会阻塞后面的代码，等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。（这就是await必须用在async函数内部的原因，async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行。）</p>\n<h3 id=\"10-对象的内部属性和方法\"><a href=\"#10-对象的内部属性和方法\" class=\"headerlink\" title=\"10.对象的内部属性和方法\"></a>10.对象的内部属性和方法</h3><ul>\n<li><p>configurable：能否使用delete、能否修改属性特性、能否修改访问器属性</p>\n</li>\n<li><p>enumerable：对象属性能否通过for-in循环</p>\n</li>\n<li><p>writable：对象属性是否能修改</p>\n</li>\n<li><p>value：对象属性的默认值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(obj, <span class=\"string\">&#x27;name&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"string\">&#x27;zrtty&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"11-模块化\"><a href=\"#11-模块化\" class=\"headerlink\" title=\"11.模块化\"></a>11.模块化</h3><ul>\n<li><strong>服务器端规范：</strong>CommonJS，Node.js使用的模块化规范</li>\n<li><strong>浏览器端规范：</strong><ul>\n<li>AMD规范，是RequireJS在推广过程中对模块化定义的规范化产出。</li>\n<li>CMD规范，是SeaJS在推广过程中对模块化定义的规范化产出，出自淘宝。</li>\n<li>ES6：import，export</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"12-Array的方法\"><a href=\"#12-Array的方法\" class=\"headerlink\" title=\"12.Array的方法\"></a>12.Array的方法</h3><p>**splice(index, howmany, item1,…itemx); **返回删除的项</p>\n<p>index-规定添加或删除的位置，使用负数，从数组尾部规定位置</p>\n<p>howmany-要删除的数量，如果为0，则不删除项目</p>\n<p>item1…itemx-向数组添加的新项目</p>\n<h5 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>concat()</td>\n<td>合并数组，返回一个<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>slice()</td>\n<td>从数组中<strong>提取</strong>指定的一个或多个元素，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>splice()</td>\n<td>从数组中<strong>删除</strong>指定的一个或多个元素，返回结果为<strong>被删除元素组成的新数组</strong></td>\n<td>会改变原数组</td>\n</tr>\n</tbody></table>\n<p>splice()有三种使用方法：</p>\n<ul>\n<li><strong>删除：</strong>传入两参。起始位置，删除的项数</li>\n<li><strong>插入：</strong>传入三个或三个以上的参数。起始位置，0，插入的元素</li>\n<li><strong>替换：</strong>传入三个或三个以上的参数。起始位置，要删除的项数，插入的元素</li>\n</ul>\n<h5 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>indexOf()</td>\n<td>从前往后索引，检索一个数组中是否含有指定的元素</td>\n<td></td>\n</tr>\n<tr>\n<td>lastIndexOf()</td>\n<td>从后往前索引，检索一个数组中是否含有指定的元素</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>every()</td>\n<td>确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true</td>\n<td></td>\n</tr>\n<tr>\n<td>filter()</td>\n<td>过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>forEach()</td>\n<td>和 for 循环类似，但需要兼容 IE8 以上</td>\n<td>forEach() 没有返回值。也就是说，它的返回值是 undefined</td>\n</tr>\n<tr>\n<td>map()</td>\n<td>过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为<strong>新的数组</strong></td>\n<td>不会改变原数组</td>\n</tr>\n<tr>\n<td>some()</td>\n<td>数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true</td>\n<td>一真即真。只要有一项返回 true，最终的结果就返回 true</td>\n</tr>\n</tbody></table>\n<h5 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h5><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>reverse()</td>\n<td>对数组反转</td>\n<td></td>\n</tr>\n<tr>\n<td>sort()</td>\n<td>按升序排列数组项，按照Unicode编码，对每个数组项调用toString()</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>如果在使用sort()方法<strong>不带参</strong>，默认按照<strong>Unicode编码</strong>，对数组元素从小到大排序。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort()); <span class=\"comment\">// [ 1, 10, 11, 2, 3, 5 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，数字11排在了2的前面，因为<code>sort()</code>方法是按照<strong>Unicode编码</strong>进行排序的。</p>\n<p>sort()方法可以接收一个比较函数作为参数，以便指定比较的规则。在sort()添加一个回调函数，回调函数中需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数。</p>\n<p>浏览器会根据回调函数的返回值来决定元素的排序：</p>\n<ul>\n<li><strong>如果返回一个大于 0 的值，则元素会交换位置</strong></li>\n<li><strong>如果返回一个小于 0 的值，则元素位置不变</strong></li>\n<li><strong>如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置</strong></li>\n</ul>\n<p>下面是一个简单的比较函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort(compare)); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>更简化的写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b; <span class=\"comment\">// 升序</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>或箭头函数（推荐）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [ 1, 2, 3, 5, 10, 11 ]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-防抖与节流\"><a href=\"#13-防抖与节流\" class=\"headerlink\" title=\"13.防抖与节流\"></a>13.防抖与节流</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 防抖</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, delay = <span class=\"number\">200</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    timeout &amp;&amp; <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    timeout = <span class=\"built_in\">setTimeout</span>(fn.bind(<span class=\"built_in\">this</span>), delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节流</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, threshold = <span class=\"number\">200</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> current = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - <span class=\"number\">0</span>;</span><br><span class=\"line\">    timeout &amp;&amp; <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current - start &gt;= threshold) &#123;</span><br><span class=\"line\">      fn.call(<span class=\"built_in\">this</span>, ...arguments);</span><br><span class=\"line\">      start = current;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(fn.bind(<span class=\"built_in\">this</span>), threshold, ...arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"HTML部分\"><a href=\"#HTML部分\" class=\"headerlink\" title=\"HTML部分\"></a>HTML部分</h2><h3 id=\"标签语义化\"><a href=\"#标签语义化\" class=\"headerlink\" title=\"标签语义化\"></a>标签语义化</h3><p>HTML 标签语义化是让大家直观的认识标签(markup)和属性(attribute)的用途和作用。</p>\n<p>如<code>&lt;header&gt;</code>，<code>&lt;footer&gt;</code>，<code>&lt;article&gt;</code>，<code>&lt;section&gt;</code></p>\n<h2 id=\"CSS部分\"><a href=\"#CSS部分\" class=\"headerlink\" title=\"CSS部分\"></a>CSS部分</h2><h3 id=\"1-css元素权重\"><a href=\"#1-css元素权重\" class=\"headerlink\" title=\"1.css元素权重\"></a>1.css元素权重</h3><table>\n<thead>\n<tr>\n<th align=\"left\">行内样式</th>\n<th>1000</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ID选择器</td>\n<td>0100</td>\n</tr>\n<tr>\n<td align=\"left\">class选择器</td>\n<td>0010</td>\n</tr>\n<tr>\n<td align=\"left\">标签、伪类</td>\n<td>0001</td>\n</tr>\n<tr>\n<td align=\"left\">*</td>\n<td>0000</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-position定位属性\"><a href=\"#2-position定位属性\" class=\"headerlink\" title=\"2.position定位属性\"></a>2.position定位属性</h3><ul>\n<li><strong>static：</strong>默认正常流</li>\n<li><strong>absolute：</strong>完全脱标，完全不占位置，父类要有定位（relative，absolute，fixed），若没有则以Document文档定位</li>\n<li><strong>relative：</strong>相对于其在标准流中的位置，不脱标，占据原来位置</li>\n<li><strong>fixed：</strong>完全脱标，完全不占位置，只认浏览器的可视窗口</li>\n<li><strong>sticky：</strong>根据正常文档流定位，不脱标</li>\n</ul>\n<h3 id=\"3-display属性\"><a href=\"#3-display属性\" class=\"headerlink\" title=\"3.display属性\"></a>3.display属性</h3><ul>\n<li><strong>inline：</strong>行内元素</li>\n<li><strong>block：</strong>块级元素</li>\n<li><strong>inline-block：</strong>行内块元素</li>\n<li><strong>flex：</strong>弹性盒，单轴</li>\n<li><strong>grid：</strong>网格，双轴</li>\n</ul>\n<h3 id=\"4-浮动属性\"><a href=\"#4-浮动属性\" class=\"headerlink\" title=\"4.浮动属性\"></a>4.浮动属性</h3><p>相邻浮动的块元素可以并在一行，超出父级宽度就换行。<em>浮动让行内元素或块元素转化为行内块元素（不确定）。</em></p>\n<p>高度塌陷：父元素如果没有设置尺寸，父元素内整体浮动的元素无法撑开父元素，父元素需要清除浮动。</p>\n<ol>\n<li>在父元素内部最后添加一个没有高度的元素，设置clear: both;</li>\n<li>使用::after伪类为父元素添加后标签</li>\n<li>通过对父元素设置overflow属性，使父元素形成BFC，父元素高度计算会包括浮动元素的高度。</li>\n</ol>\n<h3 id=\"6-圣杯与双飞翼布局\"><a href=\"#6-圣杯与双飞翼布局\" class=\"headerlink\" title=\"6.圣杯与双飞翼布局\"></a>6.圣杯与双飞翼布局</h3><p>两种布局都是三栏布局，两边固定宽度，中间自适应，中间栏要放在文挡流前面以优先渲染。</p>\n<p><strong>圣杯布局</strong></p>\n<p>首先设置三栏浮动，设置中间div宽度100%，左右div被挤到后一行。此时给中间div设置左右padding以便给左右div留出位置。为了让左div回到上一行，设置其position为relative并margin-left设为-100%，再添加left: -300px使其回到第一行最左侧。同理，右div设置position为relative并margin-left：-200px，right：-200px。</p>\n<p><strong>双飞翼布局</strong></p>\n<p>中间的div多了一个子容器，通过控制其子容器的margin或padding空出左右两列的宽度。</p>\n<h3 id=\"7-居中问题\"><a href=\"#7-居中问题\" class=\"headerlink\" title=\"7.居中问题\"></a>7.居中问题</h3><p><strong>水平居中</strong></p>\n<p>行内元素一行文字</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>okkkk<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/04/22/7f255ae33214/image-20220422203142481.png\" alt=\"image-20220422203142481\"></p>\n<p>行内元素多行文字</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Facere eius praesentium saepe, exercitationem enim magni</span><br><span class=\"line\">    a. Ea aut fugit recusandae a quod animi quibusdam repellendus vel? Dolorem molestiae eius fugiat?Lorem ipsum,</span><br><span class=\"line\">    dolor sit amet consectetur adipisicing elit. Consectetur quis ratione est optio expedita vero hic sapiente enim</span><br><span class=\"line\">    minima placeat mollitia recusandae deserunt sed, laboriosam dolore. Odit beatae provident nisi!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/04/22/7f255ae33214/image-20220422203626056.png\" alt=\"image-20220422203626056\"></p>\n<p>块级元素方法一</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;inner&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>块级元素方法二</p>\n<p>先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(-<span class=\"number\">50%</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素方法三</p>\n<p>通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素方法四</p>\n<p>通过flex将父容器设置为为Flex布局，再设置子元素居中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>垂直居中</strong></p>\n<p>单行行内元素</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多行内联元素垂直居中 flex</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多行内联元素垂直居中 table</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.content</span> <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">  <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素垂直居中一</p>\n<p>通过绝对定位元素距离顶部50%，并设置margin-top向上偏移元素高度的一半</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素垂直居中二</p>\n<p>当垂直居中的元素的高度和宽度未知时，可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: coral;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-<span class=\"number\">50%</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>块级元素垂直居中三 flex</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: khaki;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-性能优化\"><a href=\"#8-性能优化\" class=\"headerlink\" title=\"8.性能优化\"></a>8.性能优化</h3><h2 id=\"算法部分\"><a href=\"#算法部分\" class=\"headerlink\" title=\"算法部分\"></a>算法部分</h2><h3 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h3><h4 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> temp;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span> ; j &lt; arr.length; ++j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class=\"line\">      temp = arr[j];</span><br><span class=\"line\">      arr[j] = arr[i];</span><br><span class=\"line\">      arr[i] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n^2)</p>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minIndex = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; ++j) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class=\"line\">        minIndex = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    temp = arr[i];</span><br><span class=\"line\">    arr[i] = arr[minIndex];</span><br><span class=\"line\">    arr[minIndex] = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n^2)</p>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertionSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> preIndex, current;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">    preIndex = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">    current = arr[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class=\"line\">      arr[preIndex + <span class=\"number\">1</span>] = arr[preIndex];</span><br><span class=\"line\">      preIndex--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[preIndex + <span class=\"number\">1</span>] = current;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n^2)</p>\n<h4 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr, left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp, l = left, r = right;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (left &gt;= right) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  temp = arr[left];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//先从右往左开始搜索, 直到找到一个比temp小的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arr[right] &gt;= temp &amp;&amp; left &lt; right) right--;</span><br><span class=\"line\">    arr[left] = arr[right];</span><br><span class=\"line\">    <span class=\"comment\">//从左往右开始搜索，直到找到一个比temp大的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arr[left] &lt;= temp &amp;&amp; left &lt; right) left++;</span><br><span class=\"line\">    arr[right] = arr[left];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arr[left] = temp;</span><br><span class=\"line\">  quickSort(arr, l, left);</span><br><span class=\"line\">  quickSort(arr, left + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度最差O(n^2)，平均为O(nlogn)</p>\n<h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>为使桶排序更加高效，需要做到两点：</p>\n<ol>\n<li>额外空间充足下，尽可能增加桶的数量</li>\n<li>使用的映射函数能够将输入的N个数据均匀的分配到K个桶中</li>\n</ol>\n<h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><h4 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h4><h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><h4 id=\"BFS（广度优先）\"><a href=\"#BFS（广度优先）\" class=\"headerlink\" title=\"BFS（广度优先）\"></a>BFS（广度优先）</h4><h4 id=\"DFS（深度优先）\"><a href=\"#DFS（深度优先）\" class=\"headerlink\" title=\"DFS（深度优先）\"></a>DFS（深度优先）</h4><h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3><h3 id><a href=\"#\" class=\"headerlink\" title></a></h3><h2 id=\"网络部分\"><a href=\"#网络部分\" class=\"headerlink\" title=\"网络部分\"></a>网络部分</h2><h3 id=\"1-OSI七层模型\"><a href=\"#1-OSI七层模型\" class=\"headerlink\" title=\"1.OSI七层模型\"></a>1.OSI七层模型</h3><p>应用层：HTTP、HTTPS、FTP、SSH</p>\n<p>表示层</p>\n<p>会话层</p>\n<p>传输层：TCP、UDP</p>\n<p>网络层：IP、ARP</p>\n<p>数据链路层</p>\n<p>物理层</p>\n<h3 id=\"2-HTTP协议常用状态码\"><a href=\"#2-HTTP协议常用状态码\" class=\"headerlink\" title=\"2.HTTP协议常用状态码\"></a>2.HTTP协议常用状态码</h3><p>1xx：信息，请求收到，继续处理<br>2xx：成功，行为被成功地接受、理解和采纳    200<br>3xx：重定向，为了完成请求，必须进一步执行的动作<br>4xx：客户端错误，请求包含语法错误或者请求无法实现    400    403    404<br>5xx：服务器错误，服务器不能实现一种明显无效的请求    500    502</p>\n<h3 id=\"3-tcp三次握手四次挥手\"><a href=\"#3-tcp三次握手四次挥手\" class=\"headerlink\" title=\"3.tcp三次握手四次挥手\"></a>3.tcp三次握手四次挥手</h3><p><img src=\"/2022/04/22/7f255ae33214/1460000020610340.png\" alt=\"三次握手.png\"></p>\n<p><img src=\"/2022/04/22/7f255ae33214/1460000020610341.png\" alt=\"image.png\"></p>\n<p><strong>第四次挥手释放连接，等待2MSL的意义？</strong></p>\n<p><strong>MSL</strong>是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>\n<p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>\n<p><strong>两个理由：</strong></p>\n<ol>\n<li>保证客户端发送的最后一个ACK报文段能够到达服务端。<br>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li>\n<li>防止“已失效的连接请求报文段”出现在本连接中。<br>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>\n</ol>\n<h3 id=\"4-http与https\"><a href=\"#4-http与https\" class=\"headerlink\" title=\"4.http与https\"></a>4.http与https</h3><p>http协议以明文方式传输，易被中间人窃取。HTTPS在HTTP的基础上加入了SSL/TLS协议，依靠证书来验证服务器的身份，并为浏览器与服务器之间的通信加密。</p>\n<p><img src=\"/2022/04/22/7f255ae33214/70.png\" alt=\"img\"></p>\n<h3 id=\"5-Http简述\"><a href=\"#5-Http简述\" class=\"headerlink\" title=\"5.Http简述\"></a>5.Http简述</h3><p>Http协议是超文本传输协议的缩写，是位于应用层的协议，是基于TCP/IP通信协议来传递数据，HTTP不提供任何方式的数据加密。</p>\n<h2 id=\"框架部分\"><a href=\"#框架部分\" class=\"headerlink\" title=\"框架部分\"></a>框架部分</h2><h3 id=\"1-vue的生命周期\"><a href=\"#1-vue的生命周期\" class=\"headerlink\" title=\"1.vue的生命周期\"></a>1.vue的生命周期</h3><p><img src=\"/2022/04/22/7f255ae33214/lifecycle.svg\" alt=\"实例的生命周期\"></p>\n<h3 id=\"2-双向绑定\"><a href=\"#2-双向绑定\" class=\"headerlink\" title=\"2.双向绑定\"></a>2.双向绑定</h3><p><strong>Vue2.x</strong></p>\n<p>实现核心是数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>，对data的每个属性进行了getter和setter的拦截。</p>\n<p>1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数<br>3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>4、mvvm入口函数，整合以上三者</p>\n<h3 id=\"3-diff算法\"><a href=\"#3-diff算法\" class=\"headerlink\" title=\"3.diff算法\"></a>3.diff算法</h3><p>vue的diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。</p>\n<p>diff整体策略为：<strong>深度优先，同层比较</strong></p>\n<ol>\n<li>比较只会在同层级进行, 不会跨层级比较</li>\n<li>比较的过程中，循环从两边向中间收拢</li>\n</ol>\n<p><img src=\"/2022/04/22/7f255ae33214/9e3c68d1b0884d9ca0f8ffc5ee64a28etplv-k3u1fbpfcp-watermark.image\" alt=\"img\"></p>"}],"PostAsset":[{"_id":"source/_posts/博客施工记录/illust_95296062_20220118_234600.jpg","slug":"illust_95296062_20220118_234600.jpg","post":"ckzi2bhob000easwzgrok6lrf","modified":0,"renderable":0},{"_id":"source/_posts/博客施工记录/image-20220122110959737.png","slug":"image-20220122110959737.png","post":"ckzi2bhob000easwzgrok6lrf","modified":0,"renderable":0},{"_id":"source/_posts/博客施工记录/image-20220122110435088.png","slug":"image-20220122110435088.png","post":"ckzi2bhob000easwzgrok6lrf","modified":0,"renderable":0},{"_id":"source/_posts/31天JavaScript学习-第15天/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png","post":"cl2hhl29y00067owzc36f1d8j","slug":"687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png","modified":1,"renderable":1},{"_id":"source/_posts/31天JavaScript学习-第21天/rendering.svg","post":"cl2hhl2a5000t7owzaruz9m04","slug":"rendering.svg","modified":1,"renderable":1},{"_id":"source/_posts/31天JavaScript学习-第7天/image-20220228150415930.png","post":"cl2hhl2aa001a7owz2thv8317","slug":"image-20220228150415930.png","modified":1,"renderable":1},{"_id":"source/_posts/31天JavaScript学习-第7天/image-20220228150429925.png","post":"cl2hhl2aa001a7owz2thv8317","slug":"image-20220228150429925.png","modified":1,"renderable":1},{"_id":"source/_posts/31天JavaScript学习-第7天/SouthEast.png","post":"cl2hhl2aa001a7owz2thv8317","slug":"SouthEast.png","modified":1,"renderable":1},{"_id":"source/_posts/31天JavaScript学习-第8天/image-20220228210259817.png","post":"cl2hhl2ab001d7owz4klrdifm","slug":"image-20220228210259817.png","modified":1,"renderable":1},{"_id":"source/_posts/31天JavaScript学习-第8天/image-20220228211923561.png","post":"cl2hhl2ab001d7owz4klrdifm","slug":"image-20220228211923561.png","modified":1,"renderable":1},{"_id":"source/_posts/31天JavaScript学习-第9天/image-20220303154500631.png","post":"cl2hhl2ab001g7owz4qk5h7uq","slug":"image-20220303154500631.png","modified":1,"renderable":1},{"_id":"source/_posts/前端面试汇总/1460000020610340.png","post":"cl2hhl2ap002e7owz2iwwe6vm","slug":"1460000020610340.png","modified":1,"renderable":1},{"_id":"source/_posts/前端面试汇总/1460000020610341.png","post":"cl2hhl2ap002e7owz2iwwe6vm","slug":"1460000020610341.png","modified":1,"renderable":1},{"_id":"source/_posts/前端面试汇总/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png","post":"cl2hhl2ap002e7owz2iwwe6vm","slug":"687474703a2f2f696d672e736d79687661652e636f6d2f32303231303531375f313433312e706e67.png","modified":1,"renderable":1},{"_id":"source/_posts/前端面试汇总/70.png","post":"cl2hhl2ap002e7owz2iwwe6vm","slug":"70.png","modified":1,"renderable":1},{"_id":"source/_posts/前端面试汇总/9e3c68d1b0884d9ca0f8ffc5ee64a28etplv-k3u1fbpfcp-watermark.image","post":"cl2hhl2ap002e7owz2iwwe6vm","slug":"9e3c68d1b0884d9ca0f8ffc5ee64a28etplv-k3u1fbpfcp-watermark.image","modified":1,"renderable":1},{"_id":"source/_posts/前端面试汇总/image-20220422203142481.png","post":"cl2hhl2ap002e7owz2iwwe6vm","slug":"image-20220422203142481.png","modified":1,"renderable":1},{"_id":"source/_posts/前端面试汇总/image-20220422203626056.png","post":"cl2hhl2ap002e7owz2iwwe6vm","slug":"image-20220422203626056.png","modified":1,"renderable":1},{"_id":"source/_posts/前端面试汇总/lifecycle.svg","post":"cl2hhl2ap002e7owz2iwwe6vm","slug":"lifecycle.svg","modified":1,"renderable":1},{"_id":"source/_posts/前端面试汇总/v2-e4815bc5d515f8d6bc4c5c8217c397ee_1440w.jpg","post":"cl2hhl2ap002e7owz2iwwe6vm","slug":"v2-e4815bc5d515f8d6bc4c5c8217c397ee_1440w.jpg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckzi2bho60003aswzf95ebcdu","category_id":"ckzi2bho90006aswzfa4c21il","_id":"ckzi2bhob000baswzf6eo3sz8"},{"post_id":"ckzi2bhob000easwzgrok6lrf","category_id":"ckzi2bho90006aswzfa4c21il","_id":"ckzi2bhoc000gaswzgltm0mhn"},{"post_id":"ckzm4vwez000044wzgzri9all","category_id":"ckzi2bho90006aswzfa4c21il","_id":"ckzm4vwf8000244wzenf12kis"},{"post_id":"cl2hhl29w00057owz75lo55lg","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a1000d7owz38qx1zaq"},{"post_id":"cl2hhl29q00007owz2es2au4l","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a3000i7owz3yv8giaw"},{"post_id":"cl2hhl29y00067owzc36f1d8j","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a3000l7owzbznsd2ww"},{"post_id":"cl2hhl2a0000a7owzdfwm4st4","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a4000o7owzb9ztco8j"},{"post_id":"cl2hhl29s00017owzhbhnfrl6","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a5000r7owz3i60di7j"},{"post_id":"cl2hhl2a1000c7owzck6a69c9","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a6000u7owz9v3ye3ap"},{"post_id":"cl2hhl2a2000h7owzbroo4u1z","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a6000x7owzfb7uc10m"},{"post_id":"cl2hhl29v00047owze8bzelbf","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a700117owzdhnshpuc"},{"post_id":"cl2hhl2a3000k7owz5bxdcqnm","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a900147owz81qr1x3u"},{"post_id":"cl2hhl2a4000n7owz6u540xqf","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2a900187owz8j7e2qyi"},{"post_id":"cl2hhl2a4000q7owz3lfz1flg","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2aa001b7owz5o4b0sv1"},{"post_id":"cl2hhl2a5000t7owzaruz9m04","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2ab001e7owz97qq1lpu"},{"post_id":"cl2hhl2a6000w7owzd2qobqyx","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2ac001h7owz05vpfurh"},{"post_id":"cl2hhl2a700107owz1kwnb20a","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2ac001k7owz14iz3qx0"},{"post_id":"cl2hhl2a800137owz2ebwhar8","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2ad001n7owz77w4f9ms"},{"post_id":"cl2hhl2a900167owzcgwz9fkg","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2ad001q7owz64zp07to"},{"post_id":"cl2hhl2aa001a7owz2thv8317","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2ae001t7owz4szc5m0q"},{"post_id":"cl2hhl2ab001d7owz4klrdifm","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2af001v7owz2fczfmnq"},{"post_id":"cl2hhl2ab001g7owz4qk5h7uq","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2ah001z7owzhporfzp0"},{"post_id":"cl2hhl2ac001j7owz889n6kcu","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2ai00227owz2ryh8gy8"},{"post_id":"cl2hhl2ad001m7owza51862pr","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2aj00247owz2byd2xp5"},{"post_id":"cl2hhl2ad001p7owz060j43sj","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2ak00287owzf59q26vr"},{"post_id":"cl2hhl2ae001s7owz1dcj9h6s","category_id":"cl2hhl2ag001w7owz2cz5cetm","_id":"cl2hhl2ak00297owz1zkp9cp6"},{"post_id":"cl2hhl2ai00217owzaqa81rme","category_id":"cl2hhl2aj00257owzb52r6o9o","_id":"cl2hhl2ak002b7owzfp0aahc5"},{"post_id":"cl2hhl2ap002e7owz2iwwe6vm","category_id":"cl2hhl29u00027owzekd1ey0k","_id":"cl2hhl2as002g7owzfcnc47h1"}],"PostTag":[{"post_id":"ckzi2bho60003aswzf95ebcdu","tag_id":"ckzi2bhoa0007aswz4mou8drt","_id":"ckzi2bhob000caswz5z7kearv"},{"post_id":"ckzi2bho60003aswzf95ebcdu","tag_id":"ckzi2bhoa000aaswzfyuh0slk","_id":"ckzi2bhob000daswzbj2mfif8"},{"post_id":"ckzi2bhob000easwzgrok6lrf","tag_id":"ckzi2bhoc000faswz2wns8rwg","_id":"ckzi2bhod000jaswz4c4jfi48"},{"post_id":"ckzi2bhob000easwzgrok6lrf","tag_id":"ckzi2bhoc000haswz08554n5u","_id":"ckzi2bhod000kaswz17oad2qq"},{"post_id":"ckzi2bhob000easwzgrok6lrf","tag_id":"ckzi2bhod000iaswz9nl0aedn","_id":"ckzi2bhod000laswzhd0kht26"},{"post_id":"ckzm4vwez000044wzgzri9all","tag_id":"ckzm4vwf6000144wzhwdkf8g5","_id":"ckzm4vwf9000444wz7zc74lne"},{"post_id":"ckzm4vwez000044wzgzri9all","tag_id":"ckzm4vwf8000344wz7bg3ek91","_id":"ckzm4vwfa000544wz02xignf5"},{"post_id":"cl2hhl29w00057owz75lo55lg","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a000097owzgnj909re"},{"post_id":"cl2hhl29q00007owz2es2au4l","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a1000b7owz2r301j3j"},{"post_id":"cl2hhl29y00067owzc36f1d8j","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a2000g7owz7s6d2ycj"},{"post_id":"cl2hhl2a0000a7owzdfwm4st4","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a3000j7owz0b4dayo9"},{"post_id":"cl2hhl29s00017owzhbhnfrl6","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a4000m7owz2gomh7m5"},{"post_id":"cl2hhl2a1000c7owzck6a69c9","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a4000p7owzh1hxdg7c"},{"post_id":"cl2hhl2a2000h7owzbroo4u1z","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a5000s7owzd9c5bnbv"},{"post_id":"cl2hhl29v00047owze8bzelbf","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a6000v7owz9nzs4kkt"},{"post_id":"cl2hhl2a3000k7owz5bxdcqnm","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a7000z7owz1lbv4gcm"},{"post_id":"cl2hhl2a4000n7owz6u540xqf","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a800127owzbjx32c75"},{"post_id":"cl2hhl2a4000q7owz3lfz1flg","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2a900157owz2i4bbgny"},{"post_id":"cl2hhl2a700107owz1kwnb20a","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2aa00197owz05w41tqi"},{"post_id":"cl2hhl2a800137owz2ebwhar8","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2aa001c7owz72ow59bz"},{"post_id":"cl2hhl2a5000t7owzaruz9m04","tag_id":"cl2hhl2a6000y7owzccm05ehc","_id":"cl2hhl2ab001f7owzbo8v9wu3"},{"post_id":"cl2hhl2a900167owzcgwz9fkg","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2ac001i7owzac3l9rss"},{"post_id":"cl2hhl2aa001a7owz2thv8317","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2ac001l7owz6isehsop"},{"post_id":"cl2hhl2a6000w7owzd2qobqyx","tag_id":"cl2hhl2a900177owz8kaw1rzg","_id":"cl2hhl2ad001o7owz8uea5v5f"},{"post_id":"cl2hhl2ab001d7owz4klrdifm","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2ae001r7owzd84w6p0u"},{"post_id":"cl2hhl2ab001g7owz4qk5h7uq","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2ae001u7owz12li2qk7"},{"post_id":"cl2hhl2ac001j7owz889n6kcu","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2ag001y7owzafan4dzd"},{"post_id":"cl2hhl2ad001m7owza51862pr","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2ah00207owz0sdkcfw6"},{"post_id":"cl2hhl2ad001p7owz060j43sj","tag_id":"cl2hhl29v00037owzb628asb3","_id":"cl2hhl2aj00237owzb8xl9as6"},{"post_id":"cl2hhl2ae001s7owz1dcj9h6s","tag_id":"cl2hhl2ag001x7owzd1ncdj8p","_id":"cl2hhl2ak00277owz23tv2vu4"},{"post_id":"cl2hhl2ai00217owzaqa81rme","tag_id":"cl2hhl2aj00267owzalukg225","_id":"cl2hhl2ak002c7owzd2if8qef"},{"post_id":"cl2hhl2ai00217owzaqa81rme","tag_id":"cl2hhl2ak002a7owz39t12hxe","_id":"cl2hhl2ak002d7owzf5knagwu"},{"post_id":"cl2hhl2ap002e7owz2iwwe6vm","tag_id":"cl2hhl2ar002f7owzfsqj4owk","_id":"cl2hhl2as002h7owzg8pb45zs"}],"Tag":[{"name":"健身","_id":"ckzi2bho90005aswzcp492hoq"},{"name":"mmdetection","_id":"ckzi2bhoa0007aswz4mou8drt"},{"name":"目标检测","_id":"ckzi2bhoa000aaswzfyuh0slk"},{"name":"hexo","_id":"ckzi2bhoc000faswz2wns8rwg"},{"name":"Github Actions","_id":"ckzi2bhoc000haswz08554n5u"},{"name":"blog","_id":"ckzi2bhod000iaswz9nl0aedn"},{"name":"pip","_id":"ckzm4vwf6000144wzhwdkf8g5"},{"name":"conda","_id":"ckzm4vwf8000344wz7bg3ek91"},{"name":"JavaScript","_id":"cl2hhl29v00037owzb628asb3"},{"name":"CSS","_id":"cl2hhl2a6000y7owzccm05ehc"},{"name":"nodejs","_id":"cl2hhl2a900177owz8kaw1rzg"},{"name":"linux","_id":"cl2hhl2ag001x7owzd1ncdj8p"},{"name":"文献积累","_id":"cl2hhl2aj00267owzalukg225"},{"name":"写作","_id":"cl2hhl2ak002a7owz39t12hxe"},{"name":"面试","_id":"cl2hhl2ar002f7owzfsqj4owk"}]}}