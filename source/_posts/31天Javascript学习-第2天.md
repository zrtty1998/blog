---
title: 31天Javascript学习-第2天
reprint: false
date: 2022-02-21 15:10:24
updated: 2022-02-21 15:10:29
conver:
categories: 前端
tags:
  - JavaScript
---

# 变量作用域和内存问题

<!--more-->

## 变量

JS的变量有两种不同的数据类型的值：**基本类型值**和**引用类型值**。

**基本数据类型**：

基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。

**引用数据类型**：

对象是保存到**堆内存**中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间；而**变量保存了对象的内存地址**（对象的引用），保存在栈内存当中。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。

JS 中，所有的**变量**都是保存在**栈内存**中的。

其最大区别是在参数传值：

- 基本数据类型：传数值
- 引用数据类型：传地址

JS中所有函数的参数都是**按值传递**的。

## 作用域

JS中，一共两种作用域（ES5），为了减少命名冲突

- **全局作用域**：作用于整个script标签内部或JS文件中，
- **函数作用域**（局部作用域）

### window对象

全局作用域在页面打开时创建，在页面关闭时销毁。全局作用域中有一个全局对象window，代表浏览器的窗口。

- 创建的**变量**都会作为window对象的**属性**保存。如全局作用域中的`var a = 100`，这里`a`等价于`window.a`。
- 创建的**函数**都会作为window对象的**方法**保存。

### 作用域链

代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）。其为了保证对执行环境有权访问的所有变量和函数的有序访问。

其规则是：在内部作用域中可以访问到外部作用域的变量，反之无法访问。

当函数作用域操作一个变量时，遵循**就近原则**，先在自身作用域中寻找，找不到再向上一级作用域中查找。

### 变量声明提前（变量提升）

使用var关键字声明的变量，会在所有代码执行之前被声明，但不会赋值。若声明变量不是使用var关键字，则不会提前声明。

例：

```js
console.log(a);

var a = 123; // undefined
```

变量a被提前声明了，但没有赋值，所以为undefined。

### 函数声明提前

使用**函数声明**的形式创建的函数，会被声明提前。

函数声明：`function foo(){}`

使用**函数表达式**创建的函数，不会被声明提前。

函数表达式：`var foo = function(){};`

### 函数作用域中的声明提前

在函数作用域中，也有声明提前的特性。

### 没有块级作用域(ES5)

JS没有块级作用域，即由`{}`包裹起来的代码中的变量，只能在该块的内部使用。

## 内存问题

JS具有自动垃圾收集机制，常用有两种垃圾收集方式：

- 标记清除
- 引用计数

